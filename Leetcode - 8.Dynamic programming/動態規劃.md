
## **Lintcode模板 - 动态规划 Dynamic Programming**

## **使用条件**

- 使用场景：
    - 求方案总数（90%）
    - 求最值（80%）
    - 求可行性（80%）
- 不适用的场景：
    - 找所有具体的方案（准确率 99%）
    - 输入数据无序（除了背包问题外，准确率 60%~70%）
    - 暴力算法已经是多项式时间复杂度（准确率 80%）
- 动态规划四要素（对比递归的四要素）：
    - 状态 (State) -- 递归的定义
    - 方程 (Function) -- 递归的拆解
    - 初始化 (Initialization) -- 递归的出口
    - 答案 (Answer) -- 递归的调用

## **几种常见的动态规划：**

### **1. 背包型**

- 给出 n 个物品及其大小，问是否能挑选出一些物品装满大小为 m 的背包
- 题目中通常有“和”与“差”的概念，数值会被放到状态中
- 通常是二维的状态数组，前 i 个组成和为 j 状态数组的大小需要开 `(n + 1) * (m + 1)`

**几种背包类型：**

- 背包
    - 状态 state
        - `dp[i][j]` 表示前 i 个数里挑若干个数是否能组成和为 j
    - 方程 function
        - `dp[i][j] = dp[i - 1][j]` or `dp[i - 1][j - A[i - 1]]` 如果 `j >= A[i - 1]`
        - `dp[i][j] = dp[i - 1][j]` 如果 `j < A[i - 1]`
        - 第 `i` 个数的下标是 `i - 1`，所以用的是 `A[i - 1]` 而不是 `A[i]`
    - 初始化 initialization
        - `dp[0][0] = true`
        - `dp[0][1...m] = false`
    - 答案 answer
        - 使得 `dp[n][v], 0 s <= v <= m`为 `true` 的最大 v
- 多重背包
    - 状态 state
        - `dp[i][j]` 表示前 `i` 个物品挑出一些放到 `j` 的背包里的最大价值和
    - 方程 function
        - `dp[i][j] = max(dp[i - 1][j - count * A[i - 1]] + count * V[i - 1])`
        - 其中 `0 <= count <= j / A[i - 1]`
    - 初始化 initialization
        - `dp[0][0..m] = 0`
    - 答案 answer
        - `dp[n][m]`

### **2. 区间型**

- 题目中有 `subarray` / `substring` 的信息
    - 大区间依赖小区间
    - 用 `dp[i][j]` 表示数组/字符串中 `i`，`j` 这一段区间的最优值/可行性/方案总数
- 状态 state
    - `dp[i][j]` 表示数组/字符串中 `i`，`j` 这一段区间的最优值/可行性/方案总数
- 方程 function
    - `dp[i][j] = max/min/sum/or (dp[i,j 之内更小的若干区间])`

### **3. 匹配型**

- 通常给出两个字符串
- 两个字符串的匹配值依赖于两个字符串前缀的匹配值
- 字符串长度为 `n` , `m` 则需要开 `(n + 1) x (m + 1)` 的状态数组
- 要初始化 `dp[i][0]` 与 `dp[0][i]`
- 通常都可以用滚动数组进行空间优化
    - 状态 state
        - `dp[i][j]` 表示第一个字符串的前 `i` 个字符与第二个字符串的前 `j` 个字符怎么样怎么样(max/min/sum/or)

### **4. 划分型**

- 是前缀型动态规划的一种, 有前缀的思想
- 如果指定了要划分为几个部分：
    - `dp[i][j]` 表示前 `i` 个数/字符划分为 `j` 个 部分的最优值/方案数/可行性
- 如果没有指定划分为几个部分:
    - `dp[i]` 表示前 `i` 个数/字符划分为若干个 部分的最优值/方案数/可行性
- 状态 state
    - 指定了要划分为几个部分:dp[i][j] 表示前 i 个数/字符划分为 j 个部分的最优值/方案数/可行性
    - 没有指定划分为几个部分: dp[i] 表示前 i 个数/字符划分为若干个部分的最优值/方案数/可行性

### **5. 接龙型**

- 通常会给一个接龙规则，问你最长的龙有多长
- 状态表示通常为: `dp[i]` 表示以坐标为 `i` 的元素结尾的最长龙的长度
- 方程通常是: `dp[i] = max{dp[j] + 1}`, `j` 的后面可以接上 `i`
- LIS 的二分做法选择性的掌握，但并不是所有的接龙型 DP 都可以用二分来优化
- 状态 state
    - 状态表示通常为: `dp[i]` 表示以坐标为 `i` 的元素结尾的最长龙的长度
- 方程 function
    - `dp[i] = max{dp[j] + 1}`, `j` 的后面可以接上 `i`

## **复杂度**

- 时间复杂度:
    - O(状态总数 * 每个状态的处理耗费)_O_(状态总数∗每个状态的处理耗费)
    - 等于 _O_(状态总数∗决策数)
- 空间复杂度
    - O(状态总数) (不使用滚动数组优化)_O_(状态总数)(不使用滚动数组优化)
    - O(状态总数 / n)(使用滚动数组优化, n 是被滚动掉的那一个维度)_O_(状态总数/_n_)(使用滚动数组优化,_n_是被滚动掉的那一个维度)


以下是整理的动态规划相关题目表格，包含题目编号、题目名称、题目简述、样例和解法五个栏位：

| **题目编号**            | **题目名称 (英文/中文)**                                  | **题目简述 (中文)**                         | **样例**                                             | **解法**                              |
| ------------------- | ------------------------------------------------- | ------------------------------------- | -------------------------------------------------- | ----------------------------------- |
| 77<br>**<br>(m)<br> | 最长公共子序列 [[Longest Common Subsequence]]            | 找到两个字符串的最长公共子序列长度。                    | 输入:  <br>text1 = "abcde", text2 = "ace"  <br>输出: 3 | 使用二维动态规划表记录两个字符串的匹配情况，逐步更新最长子序列长度。  |
| 119<br>*<br>(h)     | 编辑距离 [[Edit Distance]]                            | 找到两个字符串之间的最小编辑距离，包括插入、删除和替换操作。        | 输入:  <br>word1 = "horse", word2 = "ros"  <br>输出: 3 | 使用二维动态规划表记录转换的最小操作次数，更新每步操作结果。      |
| 76<br>*<br>(m)      | 最长上升子序列 [[Longest Increasing Subsequence]]        | 找到数组中的最长严格递增子序列。                      | 输入:  <br>nums = [10,9,2,5,3,7,101,18]  <br>输出: 4   | 使用动态规划记录以每个元素为结尾的最长子序列长度，遍历数组更新最大值。 |
| 92<br><br>(m)       | 背包问题 [[Backpack]]                                 | 给定一个背包的最大容量和一组物品的体积，找到可以装下的最大体积。      | 输入:  <br>m = 10, nums = [3,4,8,5]  <br>输出: 9       | 使用动态规划记录每个容量下的最大体积，逐步更新最优解。         |
| 149<br>*<br>(m)     | [[Best Time to Buy and Sell Stock]]买卖股票的最佳时机      | 找到最大利润，允许一次买入和一次卖出股票。                 | 输入:  <br>prices = [7,1,5,3,6,4]  <br>输出:  <br>5    | 使用哈希表记录最低价格和当前利润。                   |
| 150<br>*<br>(m)     | [[Best Time to Buy and Sell Stock II]]买卖股票的最佳时机II | 找到最大利润，可以多次买入和卖出股票。                   | 输入:  <br>prices = [7,1,5,3,6,4]  <br>输出:  <br>7    | 使用哈希表动态记录买入和卖出操作。                   |
| 1164<br><br>(m)<br> | [[Wiggle Subsequence]]摆动序列                        | 给定一个数组，找到最长的摆动子序列，摆动子序列的相邻数字之差总是正负交替。 | 输入:  <br>nums = [1,7,4,9,2,5]  <br>输出:  <br>6      | 使用动态规划记录以当前值结尾的最长摆动子序列长度。           |
