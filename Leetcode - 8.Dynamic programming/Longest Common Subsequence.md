lintcode 77  找到两个字符串的最长公共子序列长度

**样例 1：**
输入：
```
a = "ABCD"
b = "EDCA"
```
输出：
```
1
```
解释：
LCS是 'A' 或 'D' 或 'C'  

**样例 2：**
输入：
```
a = "abcde"
b = "ace" 
```
输出：
```
3
```
解释：
LCS 是 "ace" 


```python
    def longest_common_subsequence(self, a: str, b: str) -> int:
        if not a or not b:
            return 0
            
        n, m = len(a), len(b)
        # state & initialization
        dp = [[0] * (m + 1) for i in range(n + 1)]
        
        # function
        for i in range(1, n + 1):
            for j in range(1, m +  1):
                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])
                if a[i - 1] == b[j - 1]:
                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + 1)

        # answer
        return dp[n][m]
```
pass

a = "abcde"   n  = 5
b = "ace"       m = 3
dp = 
[[0,0,0,0],
 [0,1,0,0],
 [0,0,0,0],
 [0,0,0,0],
 [0,0,0,0],
 [0,0,0,0]]


這段程式碼實現了經典的動態規劃算法來解決「最長公共子序列」(Longest Common Subsequence, LCS) 問題。讓我來詳細解釋它的解法，並用 `a = "abcde"`, `b = "ace"` 舉例說明。

### 最長公共子序列 (LCS) 問題簡介

最長公共子序列問題是要找出兩個序列中最長的子序列，這個子序列在兩個原始序列中都出現過，但它們的順序不一定連續。

**例子：**

- `a = "abcde"`
- `b = "ace"`
- 最長公共子序列是 `"ace"`，長度為 3。

### 動態規劃解法詳解

這個解法使用了一個二維數組 `dp` 來儲存子問題的解。

**1. 狀態定義 (State Definition)**

`dp[i][j]` 表示字符串 `a` 的前 `i` 個字符 (`a[0...i-1]`) 和字符串 `b` 的前 `j` 個字符 (`b[0...j-1]`) 的最長公共子序列的長度。

**2. 初始化 (Initialization)**

- `dp` 數組的大小為 `(n+1) x (m+1)`，其中 `n` 是 `a` 的長度，`m` 是 `b` 的長度。之所以加 1 是為了處理空字符串的情況（即 `i=0` 或 `j=0`）。
    
- `dp[0][j] = 0` (對於所有 `j`)：當字符串 `a` 為空時，與 `b` 的任何前 `j` 個字符的LCS長度都為 0。
    
- `dp[i][0] = 0` (對於所有 `i`)：當字符串 `b` 為空時，與 `a` 的任何前 `i` 個字符的LCS長度都為 0。
    
- 程式碼中的 `dp = [[0] * (m + 1) for i in range(n + 1)]` 已經自動將所有元素初始化為 0，這符合我們的初始化要求。
    

**3. 狀態轉移方程 (Function/Transition)**

我們從 `dp[1][1]` 開始遍歷，一直到 `dp[n][m]`。對於每一個 `dp[i][j]`，我們考慮 `a[i-1]` (即 `a` 的第 `i` 個字符) 和 `b[j-1]` (即 `b` 的第 `j` 個字符) 的情況：

- **情況 1：`a[i-1] == b[j-1]` (當前字符匹配)** 如果 `a` 的第 `i` 個字符和 `b` 的第 `j` 個字符相同，那麼它們可以作為LCS的一部分。此時，`dp[i][j]` 的長度將是 `a` 的前 `i-1` 個字符和 `b` 的前 `j-1` 個字符的LCS長度再加 1。 即：`dp[i][j] = dp[i-1][j-1] + 1`
    
- **情況 2：`a[i-1] != b[j-1]` (當前字符不匹配)** 如果 `a` 的第 `i` 個字符和 `b` 的第 `j` 個字符不相同，那麼它們不能同時作為LCS的一部分。此時，我們需要考慮兩種可能性，並取其中LCS較長的那種：
    
    - `dp[i-1][j]`：`a` 的前 `i-1` 個字符和 `b` 的前 `j` 個字符的LCS長度 (相當於從 `a` 中移除 `a[i-1]`)。
        
    - `dp[i][j-1]`：`a` 的前 `i` 個字符和 `b` 的前 `j-1` 個字符的LCS長度 (相當於從 `b` 中移除 `b[j-1]`)。
        
    - 因此：`dp[i][j] = max(dp[i-1][j], dp[i][j-1])`
        
- **綜合考慮** 程式碼中將這兩種情況合併了。`dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])` 這行代碼首先處理了字符不匹配的情況。如果字符匹配 `a[i-1] == b[j-1]`，那麼 `dp[i][j]` 會在 `max(dp[i][j], dp[i - 1][j - 1] + 1)` 這一行被更新，因為 `dp[i-1][j-1] + 1` 一定比 `dp[i-1][j]` 或 `dp[i][j-1]` 更大（除非 `a[i-1]` 或 `b[j-1]` 導致了LCS的斷裂，但在這個問題中，我們總是希望增加LCS的長度）。
    

**4. 最終答案 (Answer)**

當所有的 `dp[i][j]` 都計算完畢後，`dp[n][m]` 就儲存了字符串 `a` 和 `b` 的最長公共子序列的長度。

### 舉例說明：`a = "abcde"`, `b = "ace"`

- `n = len(a) = 5`
    
- `m = len(b) = 3`
    

初始化 `dp` 數組 (大小 6x4，所有值為 0)：

```
    ""  a   c   e
"" [0, 0, 0, 0]
a  [0, 0, 0, 0]
b  [0, 0, 0, 0]
c  [0, 0, 0, 0]
d  [0, 0, 0, 0]
e  [0, 0, 0, 0]
```

現在我們一步步填充 `dp` 數組：

**i = 1 (a[0] = 'a')**

- **j = 1 (b[0] = 'a')**
    
    - `a[0] == b[0]` ('a' == 'a')
        
    - `dp[1][1] = dp[0][0] + 1 = 0 + 1 = 1`
        
- **j = 2 (b[1] = 'c')**
    
    - `a[0] != b[1]` ('a' != 'c')
        
    - `dp[1][2] = max(dp[1][1], dp[0][2]) = max(1, 0) = 1`
        
- **j = 3 (b[2] = 'e')**
    
    - `a[0] != b[2]` ('a' != 'e')
        
    - `dp[1][3] = max(dp[1][2], dp[0][3]) = max(1, 0) = 1`
        

`dp` 數組變為：

```
    ""  a   c   e
"" [0, 0, 0, 0]
a  [0, 1, 1, 1]
b  [0, 0, 0, 0]
c  [0, 0, 0, 0]
d  [0, 0, 0, 0]
e  [0, 0, 0, 0]
```

**i = 2 (a[1] = 'b')**

- **j = 1 (b[0] = 'a')**
    
    - `a[1] != b[0]` ('b' != 'a')
        
    - `dp[2][1] = max(dp[2][0], dp[1][1]) = max(0, 1) = 1`
        
- **j = 2 (b[1] = 'c')**
    
    - `a[1] != b[1]` ('b' != 'c')
        
    - `dp[2][2] = max(dp[2][1], dp[1][2]) = max(1, 1) = 1`
        
- **j = 3 (b[2] = 'e')**
    
    - `a[1] != b[2]` ('b' != 'e')
        
    - `dp[2][3] = max(dp[2][2], dp[1][3]) = max(1, 1) = 1`
        

`dp` 數組變為：

```
    ""  a   c   e
"" [0, 0, 0, 0]
a  [0, 1, 1, 1]
b  [0, 1, 1, 1]
c  [0, 0, 0, 0]
d  [0, 0, 0, 0]
e  [0, 0, 0, 0]
```

**i = 3 (a[2] = 'c')**

- **j = 1 (b[0] = 'a')**
    
    - `a[2] != b[0]` ('c' != 'a')
        
    - `dp[3][1] = max(dp[3][0], dp[2][1]) = max(0, 1) = 1`
        
- **j = 2 (b[1] = 'c')**
    
    - `a[2] == b[1]` ('c' == 'c')
        
    - `dp[3][2] = max(dp[3][1], dp[2][2])` (這部分是 `max(1, 1) = 1`)
        
    - 然後因為匹配，`dp[3][2] = max(dp[3][2], dp[2][1] + 1) = max(1, 1 + 1) = 2`
        
- **j = 3 (b[2] = 'e')**
    
    - `a[2] != b[2]` ('c' != 'e')
        
    - `dp[3][3] = max(dp[3][2], dp[2][3]) = max(2, 1) = 2`
        

`dp` 數組變為：

```
    ""  a   c   e
"" [0, 0, 0, 0]
a  [0, 1, 1, 1]
b  [0, 1, 1, 1]
c  [0, 1, 2, 2]
d  [0, 0, 0, 0]
e  [0, 0, 0, 0]
```

**i = 4 (a[3] = 'd')**

- **j = 1 (b[0] = 'a')**
    
    - `a[3] != b[0]` ('d' != 'a')
        
    - `dp[4][1] = max(dp[4][0], dp[3][1]) = max(0, 1) = 1`
        
- **j = 2 (b[1] = 'c')**
    
    - `a[3] != b[1]` ('d' != 'c')
        
    - `dp[4][2] = max(dp[4][1], dp[3][2]) = max(1, 2) = 2`
        
- **j = 3 (b[2] = 'e')**
    
    - `a[3] != b[2]` ('d' != 'e')
        
    - `dp[4][3] = max(dp[4][2], dp[3][3]) = max(2, 2) = 2`
        

`dp` 數組變為：

```
    ""  a   c   e
"" [0, 0, 0, 0]
a  [0, 1, 1, 1]
b  [0, 1, 1, 1]
c  [0, 1, 2, 2]
d  [0, 1, 2, 2]
e  [0, 0, 0, 0]
```

**i = 5 (a[4] = 'e')**

- **j = 1 (b[0] = 'a')**
    
    - `a[4] != b[0]` ('e' != 'a')
        
    - `dp[5][1] = max(dp[5][0], dp[4][1]) = max(0, 1) = 1`
        
- **j = 2 (b[1] = 'c')**
    
    - `a[4] != b[1]` ('e' != 'c')
        
    - `dp[5][2] = max(dp[5][1], dp[4][2]) = max(1, 2) = 2`
        
- **j = 3 (b[2] = 'e')**
    
    - `a[4] == b[2]` ('e' == 'e')
        
    - `dp[5][3] = max(dp[5][2], dp[4][3])` (這部分是 `max(2, 2) = 2`)
        
    - 然後因為匹配，`dp[5][3] = max(dp[5][3], dp[4][2] + 1) = max(2, 2 + 1) = 3`
        

最終 `dp` 數組：

```
    ""  a   c   e
"" [0, 0, 0, 0]
a  [0, 1, 1, 1]
b  [0, 1, 1, 1]
c  [0, 1, 2, 2]
d  [0, 1, 2, 2]
e  [0, 1, 2, 3]
```

最終答案 `dp[n][m]`，即 `dp[5][3]` 的值是 3。這與我們預期的 `"ace"` 長度為 3 相符。

### 時間複雜度和空間複雜度

- **時間複雜度：** 外層循環 `n` 次，內層循環 `m` 次，每次循環內部操作是常數時間。所以總時間複雜度為 O(ntimesm)。
    
- **空間複雜度：** 使用了一個 `(n+1) x (m+1)` 的二維數組 `dp`，所以空間複雜度為 O(ntimesm)。
    

這個動態規劃方法是解決LCS問題的標準且高效的算法。