
|                                                                                                                                                                                                                                                        |                                                                                                              |                                                           |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------- |
| Array  [[###### 數組]]<br>String  [[###### 字符串]]<br>Prefix Sum Array  [[###### 前綴和數組]]<br>Sorting [[###### 排序]]<br>line sweep [[###### 掃描線]]                                                                                                             |                                                                                                              | (18)<br>(36)<br>(16)<br>(2)<br>(1)                        |
| Bindary Search [[###### 二分法]]                                                                                                                                                                                                                          | Array二分查找, 搜索二维矩阵, 斐波纳契数列                                                                                    | (22)                                                      |
| Two Pointers [[###### 雙指針]]                                                                                                                                                                                                                            | 回文串, K数之和, 分割数组, 去除重复                                                                                        | (30)                                                      |
| Linked List  [[###### 鍊表]]<br>Doubly linked list  雙向链表                                                                                                                                                                                                 | LRU                                                                                                          | (24)<br>(2)                                               |
| Queue  [[###### 隊列]]<br>deque  雙向隊列<br>Monotone queue  [[###### 單調隊列]]                                                                                                                                                                                 | [[###### BFS ]] 层次遍历, 最短路径, 滑动窗口<br>*能用BFS就不要用DFS<br>连通块, 拓扑排序一定要用BFS 否則會錯誤<br><br>BFS有兩種方法 - queue or deque | (8)<br>(6)<br>(26)                                        |
| Stack [[###### 棧]]<br>Monotonic stack  [[###### 單調棧]]                                                                                                                                                                                                  | [[###### DFS]], 组合排列(10%), Binary Tree(90%)<br><br>DFS有兩種方法- recursion, no recursion                         | (13)<br>(18)<br>(16)                                      |
| Hash Map [[###### 哈希表]]<br>Union find  [[###### 併查集]]<br>Iterator  [[###### 迭代器]]                                                                                                                                                                      |                                                                                                              | (15)<br>(22)<br>(12)                                      |
| Binary Tree [[###### 二叉树]]<br>Binary Search Tree  [[###### 二叉搜索树]]<br>Heap [[###### 堆]]<br>Trie [[###### 字典树]]<br>Segmetn Tree  [[###### 线段树]]<br>Balanced Binary Tree [[###### 平衡二叉树]]<br>Binary Indexed Tree  [[###### 树状数组]]<br>Graph  [[###### 圖]] |                                                                                                              | (14)<br>(24)<br>(19)<br>(15)<br>(10)<br>(2)<br>(4)<br>(5) |
| DP [[###### 動態規劃]]                                                                                                                                                                                                                                     |                                                                                                              | (8)                                                       |
| Math 數學  [[###### 數學]]                                                                                                                                                                                                                                 |                                                                                                              | (1)                                                       |

|                  |                                                                                                                                                                                                                                                                                   |
| ---------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Array            | nums.sort()  <br>nums2 = num2.sorted()<br>nums.reverse()<br>nums2 = num2.reversed()<br>[[位元運算]] XOR(^), AND(&), (\|, ~, <<, >>)                                                                                                                                                   |
| String           | str.strip().split()<br>collections.Counter(str)<br>(char1, char2) in zip(str1, str2)<br>i, (char1, char2) in enumerate(zip(str1, str2))<br>ord(ch)-ord('a')<br>str1.find(str2)<br>[[hash table]] use dict()<br>for char in string <br>     dicr[char] = dict.get(char, 0) + 1<br> |
| Prefix Sum Array | for i, num in enumerate(nums)                                                                                                                                                                                                                                                     |
|                  |                                                                                                                                                                                                                                                                                   |
|                  |                                                                                                                                                                                                                                                                                   |


# **<mark style="background: #FF5582A6;">數組（Array）</mark>的詳細介紹**
###### 數組

| 题目编号                 | 题目名称（英文）                                                                                  | 题目简述（中文）                                      | 样例                                                                                                                            | 解法                                          |
| -------------------- | ----------------------------------------------------------------------------------------- | --------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------- |
| 100<br><br>(e)       | [[Remove Duplicates]]<br>删除排序数组中的重复数字<br>                                                 | 給定一個排序數組，刪除重複元素，並返回數組的新長度                     | 输入：<br>nums = [1,1,2]<br><br>输出：<br>[1,2]                                                                                     | 使用雙指針：一個指針遍歷數組，另一個指針記錄非重複元素的位置。             |
| 30<br>*<br>(m)<br>   | [[Insert Interval]]<br>插入区间                                                               | 给定一组非重叠的区间和一个新的区间，将新区间合并到已有的区间中（可能需要合并重叠的部分）。 | 输入: <br>intervals = <br>[(1,2),(3,5),(6,7),<br>(8,10),(12,16)] <br>newInterval = (4,9) <br><br>输出: <br>[(1,2),(3,10),(12,16)] | 遍历已有区间，找到需要合并的位置，进行合并并插入新的区间。               |
| 156<br>**<br>(e)<br> | [[Merge Intervals]]<br>合并区间                                                               | 给定一组区间，合并所有重叠的区间。                             | 输入: <br>[(1,3),(2,6),<br>(8,10),(15,18)]<br> <br>输出: [(1,6),<br>(8,10),(15,18)]                                               | 按区间起点排序，遍历并合并重叠区间。                          |
| 8<br>*<br>(e)        | [[Rotate String]]旋转字符数组                                                                   | 给定一个字符串和一个偏移量，根据偏移量旋转字符串。                     | 输入: <br>"abcdefg"<br>offset = 3 <br><br>输出: <br>"efgabcd"<br><br>O(n),O(n)                                                    | 将字符串分为两部分，分别反转，然后再整体反转。                     |
| 39<br><br>(e)        | [[Recover Rotated Sorted Array]]恢复旋转排序数组                                                  | 恢复被旋转过的排序数组，使其重新有序。                           | 输入: <br>[4, 5, 1, 2, 3] <br><br>输出: <br>[1, 2, 3, 4, 5]<br><br>O(n),O(1)                                                      | 找到旋转点，将数组分为两部分，分别反转，然后再整体反转。                |
| 62<br>*<br>(m)<br>   | [[Search in Rotated Sorted Array\|Search in Rotated Sorted Array]]搜索旋转排序数组<br><br>(也在二分法) | 在旋转过的排序数组中搜索目标值，返回其下标。                        | 输入: <br>[4, 5, 6, 7, 0, 1, 2] <br>target = 0 <br><br>输出: 4<br><br>二分 O(logn) O(n)                                             | 使用二分查找，判断中间元素与左右边界的关系，确定搜索范围。               |
| 63<br><br>(m)<br>    | [[Search in Rotated Sorted Array II]]搜索旋转排序数组 II<br><br>(也在二分法)                           | 在旋转过的排序数组中搜索目标值，数组中可能包含重复元素。                  | 输入: <br>[2,5,6,0,0,1,2]<br>target = 0 <br><br>输出:<br>true                                                                     | 使用二分查找，判断中间元素与目标值的关系，并处理可能的重复元素情况。          |
| 46<br>*<br>(e)       | [[Majority Number]]主元素                                                                    | 找到数组中的主元素，出现次数超过数组长度的一半。                      | 输入: <br>[1, 1, 1, 2, 2] <br><br>输出: 1<br><br>O(n),O(1)                                                                        | 使用摩尔投票算法，维护一个候选元素和计数器，遍历数组更新候选元素。           |
| 50<br><br>(e)        | [[Product of Array Exclude Itself]]数组剔除元素后的乘积                                             | 给定一个整数数组，返回一个新数组，其中每个元素是原数组中除自身外其他元素的乘积。      | 输入: <br>[1, 2, 3,4] <br><br>输出: <br>[24, 12, 8, 6]<br><br>O(n),O(n)                                                           | 使用前缀积和后缀积，分别计算每个位置左侧和右侧的乘积，然后相乘得到结果。        |
| 1310<br>*<br>(m)     | [[Product of Array Except Self]]数组除了自身的乘积                                                 | 给定一个整数数组，返回每个元素除自身外其他元素的乘积，要求不能使用除法运算。        | 输入: <br>[1,2,3,4] <br><br>输出: <br>[24,12,8,6]<br><br>O(n),O(n)                                                                | 使用前缀乘积和后缀乘积，逐个计算每个位置的结果。                    |
| 111<br>*<br>(e)      | [[Climbing Stairs]]爬楼梯                                                                    | 一次可以爬 1 步或 2 步，求爬到第 n阶台阶的总方法数。                | 输入: <br>n = 3 <br><br>输出: 3<br><br>O(n)                                                                                       | 使用动态规划或斐波那契数列公式递推计算方法数。                     |
| 162<br>*<br>(m)<br>  | [[Set Matrix Zeroes]]矩阵归零                                                                 | 给定一个二维矩阵，若某个元素为 0，则将该元素所在行和列的所有元素设为 0。        | 输入: [<br>[1,2,3],<br>[4,0,6],<br>[7,8,9]] <br><br>输出: [ <br>[1,0,3],<br>[0,0,0],<br>[7,0,9]]<br><br>O(m*n),O(m+n)             | 使用额外空间记录 0 的位置，或利用矩阵的第一行和第一列作为标记。           |
| 101<br><br>(e)       | [[Remove Duplicates from Sorted Array II]]删除排序数组中的重复数字（二)                                 | 删除排序数组中出现超过两次的重复项，使每个元素最多出现两次，并返回新的数组长度。      | 输入: <br>[1,1,1,2,2,3] <br><br>输出: <br>5 <br>([1,1,2,2,3])                                                                     | 使用双指针，一个指向当前遍历位置，一个指向更新位置，控制每个元素的出现次数不超过两次。 |
| 1355<br>*<br>(e)     | [[Pascal's Triangle]]杨辉三角                                                                 | 给定一个整数 n，生成帕斯卡三角形的前 n 行。                      | 输入: 5 <br><br>输出: [ <br>[1],<br>[1,1],<br>[1,2,1],<br>[1,3,3,1],<br>[1,4,6,4,1]]<br><br>O(n²),O(n²)                           | 使用循环逐行生成，每行的值由上一行计算得到。                      |
| 1354<br><br>(e)      | [[Pascal's Triangle II]]杨辉三角形II                                                           | 给定一个索引 k，返回帕斯卡三角形的第 k 行。(從0開始)                | 输入: 0 <br>输出: [1]<br><br>输入: 3 <br>输出: [1,3,3,1]<br><br>從0行開始,第n行n+1數字                                                        | 使用动态规划，仅存储上一行值，逐步生成下一行。                     |
| 82<br><br>(e)        | [[Single Number]]落单的数                                                                     | 给定一个非空数组，其中每个元素出现两次，只有一个元素出现一次，找出该元素。         | 输入: <br>[4,1,2,1,2] <br><br>输出: 4<br><br>O(n),O(1)                                                                            | 使用XOR异或操作，所有出现两次的元素会抵消为 0，剩下的即为单独的元素。       |
| 1320<br>*<br>(e)     | [[Contains Duplicate]]包含重复值                                                               | 判断数组中是否存在重复元素。                                | 输入: <br>[1,2,3,1] <br><br>输出: true                                                                                            | 使用哈希表记录出现的元素，若遇到重复则返回 true。                 |
| 397<br>*<br>(e)<br>G | 最长上升连续子序列 [[Longest Continuous Increasing Subsequence]]                                   | 找到一個數組中，最长的连续严格上升子序列的长度。                      | 输入: <br>nums = [ 1,5,2,3,4 ]  <br><br>输出: 3   <br>([2,3,4])<br><br>O(n),O(1)                                                  | 使用遍历一次数组的方法，记录当前的连续上升子序列长度，动态更新最大值。         |



# **<mark style="background: #FF5582A6;">字符串（String）</mark>的詳細介紹**
###### 字符串

| 题目编号                      | 题目名称（英文）                                                     | 题目简述（中文）                                                                                     | 样例                                                                                                                                    | 解法                                                          |
| ------------------------- | ------------------------------------------------------------ | -------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------- |
| 13<br>*<br>(e)            | [[Implement strStr]]字符串查找                                    | 实现 `strStr()` 函数，返回子字符串在母字符串中首次出现的索引，若不存在则返回 -1。                                             | 输入: <br>source = <br>"abcdabcdefg", <br>target = "bcd" <br><br>输出: 1<br><br>暴力匹配<br>O(m*n),O(1)                                       | 使用双指针從0,0出發遍历源字符串，检查目标字符串是否匹配                               |
| 594<br>**<br>(h)          | 字符串查找 II [[strStr II]]                                       | 在字符串中查找子字符串，返回第一次出现的起始索引，若未找到返回-1。                                                           | 输入: <br>source = <br>"abcdabcdefg", <br>target = <br>"bcd" <br><br>输出: 1<br><br>基於雜湊<br>O(m+n),O(1)                                   | 用Rabin-Karp (滾動哈希) 字符串匹配演算法匹配target, source的hash value      |
| 647<br>*<br>(m)<br>       | [[Find All Anagrams in a String]]子串字谜                        | 在字符串中找到目标字符串所有变位词的起始索引                                                                       | 输入:  <br>s = "cbaebabacd"  <br>p = "abc"  <br><br>输出:  [0,6] <br><br>("cba","bac")                                                    | 使用滑动窗口和哈希表记录字符频率。                                           |
| 648<br><br>(m)            | [[Unique Word Abbreviation]]单词缩写集                            | 实现一个单词缩写系统，检查一个缩写是否唯一。縮寫就是頭+中間字母個數+尾                                                         | 输入:  <br>dictionary = <br>["deer","door",<br>"cake","card"]  <br>isUnique("dear") <br> <br>输出:  <br>false  ("dear" -> "d2r")          | 使用哈希表记录单词及其缩写关系，动态检查唯一性。                                    |
| 384<br>*<br>(m)           | [[Longest Substring Without Repeating Characters]]無重複字符的最長子串 | 給定一個字符串，找出其中不包含重複字符的最長子串的長度。                                                                 | 输入：<br>s = "abcabcbb"<br><br>输出：<br>output = 3  ("abc")                                                                               | 使用滑動窗口來維護一個當前有效的無重複字符子串。當set()出現重複字符時，窗口左邊界右移以維持無重複狀態。      |
| 422<br><br>(e)            | [[Length of Last Word]]最后一个单词的长度                             | 返回字符串中最后一个单词的长度，单词之间以空格分隔。                                                                   | 输入: "Hello World" <br><br>输出: 5<br><br>s.strip().split()                                                                              | 从字符串末尾向前遍历，跳过末尾空格，计算最后一个单词的长度。                              |
| 408<br><br>(e)            | [[Add Binary]]二进制求和                                          | 给定两个二进制字符串，返回它们的和（用二进制字符串表示）。                                                                | 输入: "11", "1" <br><br>输出: "100"                                                                                                       | 从后向前遍历两个字符串，逐位相加并处理进位问题。                                    |
| 415<br>*<br>(m)           | [[Valid Palindrome]]有效回文串                                    | 判断一个字符串是否为回文，只考虑字母和数字字符，忽略大小写。                                                               | 输入: "A man, a plan, a canal: Panama" <br><br>输出: true                                                                                 | 使用双指针从字符串两端向中间移动，跳过非字母数字字符，比较字符是否相同。                        |
| 837<br>*<br>(m)<br>!      | [[Palindromic Substrings]]回文子串                               | 给定一个字符串，计算字符串中回文子串的个数。                                                                       | 输入: "aba" <br><br>输出: 4<br><br>("a", "b", "a", "aba")                                                                                 | 使用中心扩展法或动态规划，逐个检查每个子串是否为回文并计数。                              |
| 891<br><br>(m)<br>!<br>   | [[Valid Palindrome II]]有效回文串（二）                              | 判断一个字符串是否可以通过删除最多一个字符变成回文。                                                                   | 输入: "abca" <br><br>输出: true                                                                                                           | 使用双指针从两端向中间移动，遇到不匹配时尝试跳过左指针或右指针的字符继续判断是否为回文。                |
| 627<br>*<br>(e)           | [[Longest Palindrome]]最长回文串                                  | 给定一个字符串，找到能够通过重新排列组成的最长回文串的长度。                                                               | 输入: "abccccdd" <br><br>输出: 7<br><br>("dccaccd")                                                                                       | 使用hash table统计各字符的出现次数，计算偶數並刪去 or用Counter                   |
| 53<br><br>(e)             | [[Reverse Words in a String]]翻转字符串                           | 给定一个字符串，逐个翻转字符串中的每个单词。                                                                       | 输入: "the sky is blue"<br> <br>输出: "blue is sky the"                                                                                   | 先去除多余空格，将字符串拆分为单词列表，反转列表后再拼接成字符串。                           |
| 927<br>*<br>(m)<br>       | [[Reverse Words in a String II]]I翻转字符串II                     | 给定一个字符数组，逐个翻转字符串中的每个单词。                                                                      | 输入: "the sky is blue" <br><br>输出: "blue is sky the"<br><br>(不用內建函數s.strip().split())                                                  | 先整体反转字符数组，然后逐个反转每个单词。                                       |
| 1173<br><br>(e)<br>       | [[Reverse Words in a String III]]翻转字符串 III                   | 给定一个字符串，逐个反转字符串中的每个单词，但保持单词的顺序不变。                                                            | 输入: "Let's take LeetCode contest" <br><br>输出: "s'teL ekat edoCteeL tsetnoc"                                                           | 拆分字符串为单词列表，逐个反转每个单词后拼接成字符串。                                 |
| 1282<br><br>(e)           | [[Reverse Vowels of a String]]翻转字符串中的元音字母                    | 反转字符串中的元音字母。                                                                                 | 输入: "hello" <br><br>输出: "holle"                                                                                                       | 使用双指针从(0, N)向中间移动，如果兩個指針都是元音, 交换元音字母的位置。                    |
| 773<br><br>(e)            | [[Valid Anagram]]有效的字母异位词                                    | 判断两个字符串是否是字母异位词，即两个字符串包含的字符相同，顺序可以不同。                                                        | 输入: <br>s = "anagram", <br>t = "nagaram" <br><br>输出: true                                                                             | 使用两个dict统计两个字符串中各字符的出现次数，比较是否相同。                            |
| 1270<br><br>(e)<br>       | [[Ransom Note]]勒索信                                           | 判断一个字符串能否由另一个字符串中的字符构成。                                                                      | 输入: <br>ransomNote = "aa", <br>magazine = "aab" <br><br>输出: true                                                                      | 使用兩個Counter统计杂志字符串中各字符的出现次数，检查赎金信字符串中的字符是否都能由杂志提供。          |
| 209<br>*<br>(e)           | [[First Unique Character in a String]]第一个只出现一次的字符            | 找到字符串中第一个不重复的字符，返回其索引，若不存在则返回 -1。                                                            | 输入: "leetcode" <br><br>输出: 0                                                                                                          | 使用哈希表统计各字符的出现次数，然后遍历字符串找到第一个出现次数为 1 的字符。                    |
| 655<br><br>(e)            | [[Add Strings]]大整数加法                                         | 给定两个非负整数的字符串表示，计算它们的和，并以字符串形式返回。                                                             | 输入: <br>num1 = "11"<br>num2 = "123" <br><br>输出: "134"                                                                                 | 从后向前遍历两个字符串，逐位相加并处理进位问题。                                    |
| 1243<br><br>(e)           | [[Number of Segments in a String]]字符串中的单词数                   | 统计字符串中的单词数量，单词由非空格字符组成。                                                                      | 输入: "Hello, my name is John" <br><br>输出: 5                                                                                            | 遍历字符串，统计相邻非空格字符段的数量。                                        |
| 213<br><br>(e)<br>        | [[String Compression]]字符串压缩                                  | 对字符串进行基本的压缩，使用字符计数的方式，将压缩后的字符数组长度返回。                                                         | 输入：str = "aabcccccaaa"<br><br>输出："a2b1c5a3"                                                                                           | 使用双指针遍历字符数组，记录每个字符的出现次数，进行原地修改。                             |
| 1227<br><br>(e)<br>!!<br> | [[Repeated Substring Pattern]]重复的子串模式                        | 判断一个非空字符串是否可以由它的一个子串重复多次构成。                                                                  | 输入: "abab" <br><br>输出: true<br><br>KMP (Knuth-Morris-Pratt)<br>Algorithm<br>                                                          | 将字符串自身拼接一次，去掉头尾字符后检查是否包含原字符串。                               |
| 1193<br><br>(e)<br>       | [[Detect Capital]]检测大写的正确性                                   | 判断一个单词中的大写字母使用是否正确，正确的情况包括全部大写、全部小写、只有首字母大写。                                                 | 输入: "USA" <br><br>输出: true                                                                                                            | 检查字符串是否全部大写、全部小写或只有首字母大写。                                   |
| 1178<br><br>(e)<br>       | [[Student Attendance Record I]]学生出勤记录 I                      | 判断一个学生的出勤记录是否符合奖励条件：连续迟到不超过两次，总缺席次数不超过一次。                                                    | 输入: "PPALLP" <br><br>输出: true<br><br>(A缺席L遲到P到場)                                                                                      | 遍历字符串，统计 'A' 的数量，并检查是否存在连续三个 'L'。                           |
| 1169<br>*<br>(m)          | [[Permutation in String]]字符串的排列                              | 给定两个字符串，判断 s1 的某个排列是否是 s2 的子串。                                                               | 输入: <br>s1 = "ab", <br>s2 = "eidbaooo" <br><br>输出: true                                                                               | 使用滑动窗口维护 s2 中与 s1 等长的子串，统计字符频次并比较是否相等。                      |
| 1086<br><br>(e)           | [[Repeated String Match]]重复字符串匹配                             | 判断一个字符串a需要重复多少次，才能使另一个字符串b成为其子串。                                                             | 输入: <br>a = "abcd", <br>b = "cdabcdab" <br><br>输出: 3                                                                                  | 重复字符串 a，直到其长度大于等于 b，检查是否包含 b，若不包含则再重复一次，若仍不包含则返回 -1。        |
| 1079<br><br>(e)<br>       | [[Count Binary Substrings]]连续子串计数                            | 计算二进制字符串中连续子字符串的数量，这些子字符串中 0 和 1 的个数相等且相邻。                                                   | 输入: <br>"00110011" <br><br>输出: 6<br><br>("0011", "01", "1100", <br>"10", "0011", and "01")                                            | 统计连续相同字符的数量，逐对比较相邻组的大小，取较小值累加到结果中。                          |
| 1041<br>*<br>(m)<br>      | [[Reorganize String]]重构字符串                                   | 给定一个字符串，重新排列使得相邻字符不相同，若无法实现则返回空字符串。                                                          | 输入: "aab" <br><br>输出: "aba"                                                                                                           | 使用优先队列存储字符及其频次，按照频次从高到低排列，逐个取出字符并重新排列。                      |
| 1025<br><br>(m)           | [[Custom Sort String]]自定义字符串排序                               | 给定两个字符串 s 和 t，根据 s 的顺序对 t 中的字符重新排序。                                                          | 输入: <br>s = "cba", <br>t = "abcd" <br><br>输出: "cbad"                                                                                  | 使用哈希表记录 s中字符的优先级，按照优先级对 t 进行排序。                             |
| 1013<br>*<br>(e)<br>      | [[Unique Morse Code Words]]独特的摩尔斯编码                          | 给定一个字符串数组，将每个单词翻译为摩斯密码，返回不同翻译后的单词数量。                                                         | 输入:<br> words = <br>["gin", "zen", <br>"gig", "msg"] <br><br>输出: 2                                                                    | 使用哈希表存储摩斯密码翻译后的单词，统计唯一的单词数量。                                |
| 1394<br><br>(e)           | [[Goat Latin]]山羊拉丁文                                          | 按照规则将一个句子中的单词转换为 Goat Latin：若单词以元音开头，添加 "ma"；若以辅音开头，移到单词末尾并添加 "ma"。在句子的每个单词的末尾添加一个字母'a'，从1开始 | 输入: <br>"I speak Goat Latin" <br><br>输出: <br>"Imaa peaksmaaa <br>oatGmaaaa atinLmaaaaa"                                               | 遍历单词，判断首字母是元音还是辅音，进行相应转换并添加 'ma' 和重复的 'a'。                  |
| 1435<br><br>(m)<br>!!     | [[Find And Replace in String]]字符串中的查找与替换                     | 给定一个字符串、索引数组、源数组和目标数组，将字符串中匹配源数组的子串替换为目标数组对应的值。                                              | 输入: <br>s = "abcd", <br>indexes = <br>[0, 2]<br>sources = <br>["a", "cd"]<br>targets = <br>["eee", "ffff"] <br><br>输出: "eeebffff"     | 按照索引逆序遍历，逐个检查子串是否匹配，若匹配则进行替换。                               |
| 1425<br><br>(e)<br>       | [[Backspace String Compare]]比较含退格的字符串                        | 判断两个字符串在模拟退格操作后是否相等，'#' 表示退格符。                                                               | 输入: <br>s = "ab#c"<br>t = "ad#c" <br><br>输出: true<br><br>(都得到"ac")                                                                    | 從後往前遍歷 s 和 t, 可以直接跳過被刪除的字母 ，最后比较栈中的字符串是否相等。                 |
| 1510<br><br>(e)           | [[Buddy Strings]]亲密字符串                                       | 判断两个字符串是否可以通过交换其中的两个字符变成相等。                                                                  | 输入: <br>A = "aaaaaaabc"<br>B = "aaaaaaacb"<br><br>输出: true                                                                            | 若字符串长度不同则直接返回 false；若相等则检查是否有重复字符；否则记录不同位置的字符，判断是否可以通过交换相等。 |
| 171<br>**<br>(m)          | 乱序字符串 [[Anagrams]]                                           | 给定一个字符串列表，找出其中所有乱序的字符串组。                                                                     | 输入:  <br>strs = <br>["eat", "tea", "tan", <br>"ate", "nat", "bat"]  <br><br>输出: <br>[ ["eat","tea","ate"],<br>["tan","nat"],["bat"] ] | 将字符串排序后作为key存入字典，按key分组。                                    |
| 1127<br><br>(m)           | 在字符串中添加粗体标签 [[Add Bold Tag in String]]                       | 在字符串中所有出现在给定单词列表中的子串周围添加粗体标签，结果字符串用最少的标签包裹所有符合条件的部分。                                         | 输入:  <br>s = "abcxyz123", <br>words = <br>["abc","123"] <br> <br>输出: <br>"<b>abc</b>xyz<b>123</b>"                                    | 使用布尔数组标记哪些位置需要加粗体标签，再按范围合并标签。                               |
| 10<br><br>(m)             | 字符串的不同排列 [[String Permutation II]]                           | 给定一个字符串，返回其所有不同的排列（考虑字符重复）。                                                                  | 输入:  <br>s = "aab" <br> <br>输出: <br>["aab", "aba", <br>"baa"]                                                                         | 使用DFS生成排列，并用集合去重或在递归中跳过重复字符。                                |
| 1169<br>*<br>(m)          | [[String Permutation]] 字符串的排列                                | 判断一个字符串是否是另一个字符串的排列。                                                                         | 输入:  <br>s1 = "abc", <br>s2 = "bca"  <br><br>输出:  <br>true                                                                            | 使用哈希表记录字符频率，检查两个字符串是否匹配。                                    |
| 145<br><br>(e)<br>        | [[Lowercase to Uppercase]]大小写转换                              | 将给定的字符串中的小写字母转换为大写字母。                                                                        | 输入:  <br>char = "a"  <br><br>输出:  <br>"A"                                                                                             | 使用哈希表记录字母映射关系，动态转换。                                         |
| 146<br><br>(e)            | [[Lowercase to Uppercase II]]大小写转换II                         | 将字符串中的所有小写字母转换为大写字母。                                                                         | 输入:  <br>s = "abc"  <br><br>输出:  <br>"ABC"                                                                                            | 遍历字符串，用哈希表映射小写字母到大写字母。                                      |

**Python 常用字串方法列表

**一、 字串內容檢查 (返回 `True` 或 `False`)**

|方法 (Method)|解釋|返回值 (Return Value)|
|:--|:--|:--|
|`s.isalnum()`|檢查是否所有字元都是字母或數字|`True` / `False`|
|`s.isalpha()`|檢查是否所有字元都是字母|`True` / `False`|
|`s.isascii()`|檢查是否所有字元都是 ASCII 字元|`True` / `False`|
|`s.isdecimal()`|檢查是否所有字元都是十進制數字 (0-9)|`True` / `False`|
|`s.isdigit()`|檢查是否所有字元都是數字 (包含 Unicode 數字)|`True` / `False`|
|`s.isidentifier()`|檢查是否是有效的 Python 識別符|`True` / `False`|
|`s.islower()`|檢查是否所有需區分大小寫的字元都是小寫|`True` / `False`|
|`s.isnumeric()`|檢查是否所有字元都是數值型字元 (最寬鬆)|`True` / `False`|
|`s.isprintable()`|檢查是否所有字元都是可列印字元|`True` / `False`|
|`s.isspace()`|檢查是否所有字元都是空白字元|`True` / `False`|
|`s.istitle()`|檢查是否是標題格式|`True` / `False`|
|`s.isupper()`|檢查是否所有需區分大小寫的字元都是大寫|`True` / `False`|
|`s.startswith(prefix)`|檢查字串是否以指定的前綴 `prefix` 開始|`True` / `False`|
|`s.endswith(suffix)`|檢查字串是否以指定的後綴 `suffix` 結束|`True` / `False`|

**二、 大小寫轉換與格式化 (返回新字串)**

|方法 (Method)|解釋|返回值 (Return Value)|
|:--|:--|:--|
|`s.capitalize()`|將首字元轉大寫，其餘轉小寫|新字串|
|`s.casefold()`|更強的小寫轉換，主要用於不區分大小寫比較|新字串|
|`s.lower()`|將所有字元轉小寫|新字串|
|`s.upper()`|將所有字元轉大寫|新字串|
|`s.swapcase()`|將字元大小寫互換|新字串|
|`s.title()`|將字串轉為標題格式 (每個單字首字母大寫)|新字串|

**三、 字串分割、連接與替換 (返回新字串或列表)**

|方法 (Method)|解釋|返回值 (Return Value)|
|:--|:--|:--|
|`s.split([sep[, maxsplit]])`|以 `sep` 分割字串 (預設空白)|列表 (List)|
|`s.rsplit([sep[, maxsplit]])`|從右邊開始以 `sep` 分割字串|列表 (List)|
|`sep.join(iterable)`|使用 `sep` 作為分隔符連接 `iterable` 中的字串元素|新字串|
|`s.replace(old, new[, count])`|將字串中的 `old` 替換為 `new` (可指定次數)|新字串|

**四、 字串查找 (返回索引或 -1)**

|方法 (Method)|解釋|返回值 (Return Value)|
|:--|:--|:--|
|`s.find(sub[, start[, end]])`|查找 `sub` 首次出現的索引，找不到返回 `-1`|整數 (int)|
|`s.rfind(sub[, start[, end]])`|查找 `sub` 最後一次出現的索引，找不到返回 `-1`|整數 (int)|
|`s.index(sub[, start[, end]])`|查找 `sub` 首次出現的索引，找不到會報錯 (ValueError)|整數 (int)|
|`s.rindex(sub[, start[, end]])`|查找 `sub` 最後一次出現的索引，找不到會報錯|整數 (int)|

**五、 移除字串兩端字元 (返回新字串)**

| 方法 (Method)         | 解釋                     | 返回值 (Return Value) |
| :------------------ | :--------------------- | :----------------- |
| `s.strip([chars])`  | 移除字串兩端指定的字元 (預設移除空白字元) | 新字串                |
| `s.lstrip([chars])` | 移除字串左端指定的字元 (預設移除空白字元) | 新字串                |
| `s.rstrip([chars])` | 移除字串右端指定的字元 (預設移除空白字元) | 新字串                |



# **<mark style="background: #BBFABBA6;">前綴和數組（Prefix Sum Array）</mark>的詳細介紹**
###### 前綴和數組

see [[Prefix summary]]

|                                    | nums = [1, 2, 3, 4]                   |     |
| ---------------------------------- | ------------------------------------- | --- |
| 前綴和 (Prefix Sum)                   | prefix_sum = [0, 1, 3, 6, 10]         |     |
| 後綴和 (Suffix Sum)                   | suffix_sum = [10, 9, 7, 4, 0]         |     |
| 前綴積 (Prefix Product)               | prefix_product = [1, 1, 2, 6, 24]     |     |
| 後綴積 (Suffix Product)               | suffix_product = [24, 24, 12, 4, 1]   |     |
|                                    |                                       |     |
| nums[1:3] 區域內和<br>=nums[1]+nums[2] | prefix_sum[3] - refix_sum[1]          |     |
| output[2] 元素以外乘積                   | Prefix Product[2] x Suffix Product[3] |     |
如果是有最長或最短子數組 這時用Two pointers method更好

| 题目编号                    | 题目名称（英文）                                           | 题目简述（中文）                                 | 样例                                                                                                                                                             | 解法                                                                                        |
| ----------------------- | -------------------------------------------------- | ---------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------- |
| **138**<br>*<br>(e)<br> | [[Subarray Sum]]<br>子数组之和为零<br>                    | 给定一个整数数组，找到和为零的子数组，返回第一个出现的子数组的起始和结束下标。  | 输入: <br>[-3, 1, 2, -3, 4] <br><br>输出: <br>[0, 2]<br><br>(和為0 [-3, 1, 2])<br>O(n)                                                                               | 使用前缀和数组，记录每个前缀和第一次出现的位置，若再次出现相同的前缀和，则表示子数组和为零。                                            |
| 139<br><br>(m)          | [[Subarray Sum Closest]]最接近零的子数组和                  | 给定一个整数数组，找到和最接近零的子数组，返回其起始和结束下标。         | 输入: <br>[-3, 1, 1, -3, 5] <br><br>输出: [0, 2]<br><br>(**和接近0** <br>[-3, 1, 1])<br>O(n),O(n)                                                                     | 计算前缀和数组，对其排序，寻找相邻前缀和差值最小的两个元素，其对应的子数组和最接近零。                                               |
| 838<br><br>(e)<br>      | [[Subarray Sum Equals K]]子数组和为K的個數                 | 给定一个整数数组和一个整数 k，找到和等于 k 的连续子数组的个数。       | 输入: <br>nums = <br>[1,1,1], <br>k = 2 <br><br>输出: 2<br><br>(**和為K的個數** <br>[0,1],[1,2])<br>O(n),O(n)                                                           | 使用前缀和数组，利用哈希表记录前缀和出现的次数，遍历数组时检查当前前缀和减去 k 是否在哈希表中，若存在则表示找到一个符合条件的子数组。                      |
| 1712<br>*<br>(m)<br>    | [[Binary Subarrays With Sum]]子数组和为S的二元子数组数量        | 给定一个二进制数组和一个整数 `S`，返回和为 `S` 的子数组数量。      | 输入: <br>nums = <br>[1,0,1,0,1], <br>S = 2 <br><br>输出: 4<br><br>[1,0,1]  (id=0,1,2)<br>[1,0,1]  (id=2,3,4)<br>[1,0,1,0], [0,1,0,1]<br>(**和為S的個數**)<br>O(n),O(n) | 使用前缀和数组，利用哈希表记录前缀和出现的次数，遍历数组时检查当前前缀和减去 `S` 是否在哈希表中，若存在则累加计数。                              |
| 1844<br>*<br>(m)        | [[Subarray Sum Equals to K II]] 子数组和为K的最短子数组       | 给定一个整数数组和一个整数k，你需要找到和为k的最短非空子数组，并返回它的长度。 | 输入:  <br>nums = [1, 1, 1, 2], k = 3  <br>输出: 2  <br><br>(**和為0找最短**[1,2])<br>O(n),O(n)                                                                         | 使用前缀和与哈希表记录出现的和，通过快速查找加速匹配和为K的子数组数量。(用Two pointers?)                                      |
| 911<br>*<br>(m)         | [[Maximum Size Subarray Sum Equals k]]子数组和为K的最長子数组 | 给定一个整数数组和一个整数 k，找到和等于 k 的最长子数组，返回其长度。    | 输入: <br>nums = [1, -1, 5, -2, 3]<br>k = 3 <br><br>输出: 4  <br>([1,-1,5,-2])<br><br>(**和為K找最長**[1,2])<br>O(n),O(n)                                               | 使用前缀和数组，利用哈希表记录前缀和第一次出现的位置，遍历数组时检查当前前缀和减去 k 是否在哈希表中，若存在则计算子数组长度并更新最大长度。(用Two pointers?)   |
| 406<br>*<br>(m)         | [[Minimum Size Subarray Sum]] 子数组和大於K的最短子数组        | 找出数组中和大于或等于 S 的最小连续子数组长度。                | 输入:  <br>nums = <br>[2,3,1,2,4,3], <br>s = 7  <br><br>输出: 2  <br>([4,3])<br><br>(**和大於S找最短**)                                                                  | 使用滑动窗口动态调整窗口范围，记录最短长度。(最長最短用Two pointers.)                                                |
| 41<br>*<br>(e)          | [[Maximum Subarray]]子数组和最大的和                       | 找到数组中和最大的连续子数组。                          | 输入: <br>[-2,2,-3,4,-1,2,1,-5,3]<br> <br>输出: 6 <br>([4,-1,2,1,-5,3])<br><br>(**和最大的和**)                                                                         | 使用前綴和，维护当前子数组的最大和，更新全局最大和。                                                                |
| 402<br><br>(m)<br>      | [[Continuous Subarray Sum]]子数组和最大的子数组              | 给定一个整数数组，请找出一个连续子数组，使得该子数组的和最大           | 输入: <br>[ -3, 1, 3, -3, 4 ]<br><br>输出: <br>[ 1,3,-3,4 ]<br><br>(**和最大的子數組**)<br>O(n),O(1)                                                                      | 使用前缀和数组，並計算minsum 记录最小前缀和. 用雙指針紀錄子數組啟始結束索引                                                |
| 42<br><br>(m)<br>!!     | [[Maximum Two Subarrays]]和最大的两个不重叠子数组              | 找到数组中和最大的两个不重叠子数组。                       | 输入: <br>[1, 3, -1, 2, -1, 2] <br><br>输出: 7<br><br>(**兩個子數組相加和最大**)<br>([1,3] and [2,-1,2])<br>O(n),O(n)                                                        | 使用动态规划，分别从左到右和从右到左计算最大子数组和，然后寻找两个不重叠部分的最大和。                                               |
| 1850<br>*<br>(m)        | 捡苹果 [[Pick Apples]]                                | 给定每棵树上的苹果数量和两个篮子容量，找到可以收集的最大苹果数量。        | 输入:  <br>apples = <br>[6, 1, 4, 6, 3, 2, 7, 4]<br>basket1 = 3<br>basket2 = 2  <br><br>输出: 24<br><br>(**兩個子數組相加和最大**)<br>([4,6,3],[7,4])<br>O(n),(n)            | 使用滑动窗口记录当前窗口的苹果数量，动态调整窗口范围，找到最大值。                                                         |
| 1075<br><br>(m)<br>     | [[Subarray Product Less Than K]]乘积小于K的子数组          | 给定一个正整数数组和一个整数 k，计算乘积小于 k 的连续子数组的个数。     | 输入: <br>nums = <br>[10, 5, 2, 6]<br>k = 100 <br><br>输出: 8<br><br>(**乘積小於k的數組數目**)<br>([10],[5],[2],[6],[10,5],<br>[5,2],[2,6],[5,2,6],[10,5,2])<br>O(n), O(1)  | 使用滑动窗口方法，维护一个窗口使其乘积小于 k，计算以当前元素为结尾的符合条件的子数组个数。                                            |
| 994<br><br>(m)<br>      | [[Contiguous Array]] 0 和 1 数量相等的最长子数组              | 给一个二进制数组，找到 0 和 1 数量相等的子数组的最大长度          | 输入: <br>[0,1,0] <br><br>输出: 2<br><br>(**0和1數量相同子數組**)<br>([0,1])<br>O(n),O(n)<br>                                                                              | 将**数组中的 0 转换为 -1**，然后计算前缀和数组，利用哈希表记录前缀和第一次出现的位置，若再次出现相同的前缀和，则表示找到一个符合条件的子数组，计算其长度并更新最大长度。 |
| 943<br><br>(e)          | [[Range Sum Query - Immutable]]区间和查询 - 不可变的        | 给定一个不可变的整数数组，计算任意区间 `[i, j]` 的和。         | 输入: <br>nums = <br>[-2, 0, 3, -5, 2, -1]<br>sumRange(0, 2) <br><br>输出: 1<br><br>(**區間的和**)<br>O(n),O(n)                                                        | 预处理前缀和数组，计算每个位置的前缀和，区间和为两个前缀和之差。                                                          |
| 665<br><br>(m)<br>!!    | [[Range Sum Query 2D - Immutable]]平面范围求和 -不可变矩阵    | 给定一个不可变的二维矩阵，计算任意子矩形的和。                  | 输入: <br>matrix = <br>[ [1,2,3],[4,5,6],[7,8,9] ]<br>sumRegion(1,1,2,2) <br><br>输出: 28<br><br>(**二维前缀和数组**)<br>O(mn),O(1)                                       | 构建二维前缀和数组，计算子矩形和为多个前缀和之差。                                                                 |
| 1068<br><br>(e)         | [[Find Pivot Index]]寻找数组的中心索引                      | 找到數組中一個索引，使得左側所有元素的和等於右側所有元素的和           | 输入：<br>nums = <br>[1,7,3,6,5,6]<br><br>输出：<br>output = 3<br><br>(**index讓左右的和相等**)<br>([1,7,3],[5,6])<br>O(n),O(1)                                             | 使用前綴和計算數組的總和，再通過遍歷計算每個索引的左側和，判斷是否滿足條件                                                     |

###### 排序 
參考 [[排序]]

| **题目编号**        | **题目名称 (英文/中文)**                 | **题目简述 (中文)**                     | **样例**                                                                        | **解法**                |
| --------------- | -------------------------------- | --------------------------------- | ----------------------------------------------------------------------------- | --------------------- |
| 463<br>*<br>(e) | 整數排序 [[Classical Sort Integers]] | 对给定的整数数组进行排序，并返回排序后的数组。           | 输入:  <br>nums = <br>[3,2,1,4,5]  <br><br>输出: [1,2,3,4,5]<br><br>O(nlogn),O(n) | 使用快速排序或内置排序方法对数组进行排序。 |
| 1585<br><br>(e) | 移动石子 [[Moving Stones]]           | 给定一堆石子，确定通过最少和最多的步数可以将所有石子移到连续位置。 | 输入:  <br>stones = <br>[1,5,10]  <br><br>输出: [1,8]                             | 将石子排序后计算最小移动和最大移动次数。  |

###### 掃描線
參考[[掃描線]]

| **题目编号**        | **题目名称 (英文/中文)**          | **题目简述 (中文)**             | **样例**                                                                                  | **解法**                          |
| --------------- | ------------------------- | ------------------------- | --------------------------------------------------------------------------------------- | ------------------------------- |
| 850<br>*<br>(h) | 员工空闲时间 Employee Free Time | 给定多个员工的会议时间，找出所有员工的空闲时间段。 | 输入:  <br>schedule = <br>[<br>[1,2,5,6],<br>[1,3],<br>[4,10]<br>]<br><br>输出: <br>[(3,4)] | 将所有会议区间合并后，使用扫描线找出相邻区间之间的空闲时间段。 |


### 二分法的題目

###### 二分法

參考 [[二分法]]

| 题目编号               | 题目名称（英文）                                                      | 题目简述（中文）                                                                    | 样例                                                                                         | 解法                                                                                                                                                                                                                            |
| ------------------ | ------------------------------------------------------------- | --------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 457<br><br>(e)     | [[Classical Binary Search]]<br>经典二分查找问题                       | 在排序数组中找target，返回该数出现的任意位置，如果不存在，返回 -1。                                      | 输入: <br>nums = <br>[1,2,2,3,4,4]<br>target=2<br><br>输出: <br>1 or 2                         | Array從頭尾開始用雙指針start, end取中位數mid比較target.然後取左半邊array或右半邊array繼續逼近, 最後start, end應該落在target區間的左右                                                                                                                                 |
| 14<br><br>(e)      | [[Binary Search]]<br>二分查找                                     | 给定一个排序的整数数组（升序）和一个要查找的整数 `target`，用O(logn)的时间查找第一次出现的下标                     | 输入: <br>nums = <br>[1,4,4,5,7,<br>7,8,9,9,10]<br>target=1<br><br>输出: <br>0                 | Array從頭尾開始用雙指針start, end取中位數mid比較target.然後取左半邊array或右半邊array繼續逼近, 最後start, end應該落在target區間的左右, 取start                                                                                                                         |
| 458<br><br>(e)     | [[Last Position of Target]]<br>目标最后位置                         | 给一个升序数组，找到 `target` 最后一次出现的位置，如果没出现过返回 `-1`                                 | 输入：<br>[1,2,2,4,5,5]<br>target = 2<br><br>输出：2                                             | Array從頭尾開始用雙指針start, end取中位數mid比較target.然後取左半邊array或右半邊array繼續逼近, 最後start, end應該落在target區間的左右, 取end                                                                                                                           |
| 447<br><br>(m)     | [[Search in a Big Sorted Array]]<br>在大数组中查找                   | 数组很大通过固定的接口 ArrayReader.get(k) 来访问第k个数.找到target第一次出现的位置                     | 输入: <br>[1, 3, 6, .]<br>target = 3<br><br>输出: 1                                            | 先利用ArrayReader.get()找到比target大的index (在while迴圈x2直到大於target),然後就利用bindary search. Array的值用ArrayReader.get()取得                                                                                                                  |
| 460<br>*<br>(m)    | [[Find K Closest Elements]]<br>在排序数组中找最接近的K个数                 | 在升序排列A中找与target最接近的k个整数                                                     | 输入: <br>A = [1, 2, 3]<br>target = 2<br>k = 3<br><br>输出: <br>[2, 1, 3]                      | 先利用Binary Search找到最接近target的數, 然後用雙指針向左向右尋找最接近target直到找到k個                                                                                                                                                                    |
| 585<br><br>(m)     | [[Maximum Number in Mountain Sequence]]<br>山脉序列中的最大值          | 给 `n` 个整数的山脉数组，即先增后减的序列，找到山顶（最大值）                                           | 输入: <br>[1, 2, 4, 8, 6, 3] <br><br>输出: 8                                                   | Array從頭尾開始用雙指針start, end取中位數mid, 然後比較array[mid]-array[mid-1]. 如果小於0則以mid為end繼續逼近. 到最後取array[start],array[end]的最大值                                                                                                             |
| 159<br>*<br>(m)    | [[Find Minimum in Rotated Sorted Array]]<br>寻找旋转排序数组中的最小值     | 假设一个按升序排好序的数组在其某一未知点发生了旋转。你需要找到其中最小的元素。                                     | 输入：<br>[4, 5, 6, 7, 0, 1, 2]<br><br>输出：0                                                   | Array從頭尾開始用雙指針start, end取中位數mid, 然後如果array[mid]大於array[end], 則mid取代start. 繼續逼近. 到最後取array[start],array[end]的最小值                                                                                                               |
| 62<br>*<br>(m)     | [[Search in Rotated Sorted Array]]<br>搜索旋转排序数组                | 有序数组以某个元素作为支点进行了旋转. 给定一个目标值target进行搜索，假设数组中不存在重复的元素。                        | 输入：<br>[4, 5, 1, 2, 3]<br>target = 1<br><br>输出：2                                           | Array從頭尾開始用雙指針start, end取中位數mid,先判斷mid是左半邊(arraymid大於array[end])或右半邊. 如果在mid左半邊, 如果target在start跟mid之間則將end換成mid繼續, 否則start換成mid. 如果在mid右半邊, 如果target在mid跟end之間則將start換成mid繼續, 否則end換成mid.                                     |
| 75<br><br>(m)      | [[Find Peak Element]]<br>寻找峰值                                 | 给定一个长度为 n 的整数数组 nums，相邻位置的数字是不同的. nums 至少存在一个峰值。寻找峰值                        | 输入：<br>[1, 2, 1, 3, <br>4, 5, 7, 6]<br><br>输出：1                                            | 尋找任一個峰. Array用二分法尋找target.用雙指針start, end取中位數mid. 如果mid比右邊一個高(nums[mid]>nums[mid+1]), mid取代end. 反之則用mid取代start                                                                                                                 |
| 183<br><br>(h)     | [[Wood Cut]]<br>木材加工                                          | 想把一些木头L切割成一些长度相同的小段木头，需要得到的小段的数目至少为 k。给定L和k，计算能够得到的小段木头的最大长度。               | 输入:<br>L = <br>[232, 124, 456]<br>k = 7<br><br>输出: 114                                     | 求得到至少k段木頭的最大長度. 先建立一個函數,get_pieces()輸入長度輸出pieces數. 木頭長度用start=1,end=max(nums=456)進行binary search, 尋找木頭段數最接近k的長度                                                                                                               |
| 28<br><br>(e)      | [[Search a 2D Matrix]]<br>搜索二维矩阵                              | 搜索 m × n矩阵中的值 target。每行中的整数从左到右是排序的。每行的第一个数大于上一行的最后一个整数。                    | 输入:<br>[<br>[1, 3, 5],<br>[10, 11, 16],<br>[23, 30, 34]<br>]<br>target = 3<br><br>输出: true | 條件:搜索 m × n矩阵中的值 target是否存在. 每行中的整数从左到右是排序的。每行的第一个数大于上一行的最后一个整数. 所以這二維矩陣=一維連續矩陣, 使用Bindary Search, value=matrix[mid//col][mid%col] 將二維轉成一維                                                                                    |
| 38<br><br>(m)      | [[Search a 2D Matrix II]]<br>搜索二维矩阵2                          | 搜索m×n矩阵中的值，返回这个值出现的次数。每行中的整数从左到右是排序的。每一列的整数从上到下是排序的。在每一行或每一列中没有重复的整数。       | 输入:<br>[<br>[1, 3, 5],<br>[2, 4, 7],<br>[3, 5, 9]<br>]<br>target = 3<br><br>输出: 2          | 條件:搜索 m × n矩阵中的值 target有幾個. 每行中的整数从左到右是排序的。每一列的整数从上到下是排序的。在每一行或每一列中没有重复的整数。可以使用从右上角开始的搜索 策略搜索target出現的次數. 右上角開始(0,len(matrix[0])-1)如果大於target則往左移動(i-=1), 如果小於target則往下移動(j+=1).                                              |
| 600<br><br>(h)     | [[Smallest Rectangle Enclosing Black Pixels]]<br>包裹黑色像素点的最小矩形 | 一个由二进制矩阵表示的图，0白色，1黑色。黑色像素点是联通的，给一个黑色像素点的坐标 (x, y) ，返回囊括所有黑色像素点的矩阵的最小面积。     | 输入：<br>["0010",<br>"0110",<br>"0100"]，<br>x=0，<br>y=2<br><br>输出：6                          | 我们可以通过DFS或BFS来找到所有的黑色像素点，确定其矩形边界。此外，也可以利用二分搜索来快速找到黑色像素的边界（上下左右）。從上往下到x搜尋到第一個包含1的行, 以及其他三個方向搜尋(下左右). 從上往下到x搜尋先取mid然後用binaey search可以用 any(image[mid][j] == '1' for j in range(minR, maxR))確定那個row有沒有1                          |
| 437<br>*<br>(m)    | [[Copy Books]]<br>书籍复印                                        | 给定n本书，第i本书有pages[i]页。有k个人来抄这些书。每抄一页书都要花1分钟。为了让最慢的抄书人能在最早的时间完成书的分配，最好的策略是什么？ | 输入: <br>[3, 2, 4]<br>k = 2<br><br>输出: 5                                                    | 求k個人複印完所有的書需要多少時間(example: k=1->9min,k=2->5min,k=3->4min). 用binary search在區間start=4,end=9尋找小於人數k的時間. 建立一個function get_least_people()輸入pages跟時間輸出人數. 在function內可以如下操作譬如time=6min, 從第一本書開始3<6, 3+2<6, 而3+2+4>6所以要加一個人. 所以輸出人數=2 |
| 366<br><br>(e)     | [[Fibonacciseries]]<br>斐波纳契数列                                 | 斐波纳契数列是指：前2个数是 0 和 1 。第 i 个数是第 i-1 个数和第i-2 个数的和                             | 输入: <br>series=<br>0, 1, 1, 2, <br>3, 5, 8, 13, <br>21, 34..                               | 尋找Fibonacci數列的第N的數. 可以建立一個fib=[0,1]. for迴圈從2開始到n+1. i=2時0+1=1更新成[1,1],i=3時更新成[1,2], i=4時更新成[3,2]. 其中1+2=array[3]使用fib[i%2] = fib[0]+fib[1]更新數值輪流存在fib[0]跟fib[1]                                                               |
| 60<br><br>(e)      | [[Search Insert Position]]搜索插入位置                              | 在排序数组中找到目标值的插入位置。                                                           | 输入: <br>[1, 3, 5, 6]<br>target = 5 <br><br>输出: 2                                           | 使用二分查找找到目标值或其应插入的位置。                                                                                                                                                                                                          |
| 61<br><br>(m)      | [[Search for a Range]]搜索区间                                    | 在排序数组中找到目标值的起始和结束位置。                                                        | 输入: <br>[5, 7, 7, 8, 8, 10]<br>target = 8 <br><br>输出: <br>[3, 4]                           | 使用二分查找分别找到目标值的起始和结束位置。                                                                                                                                                                                                        |
| 662<br><br>(e)<br> | [[Guess Number Higher or Lower]]猜数游戏                          | 实现猜数字游戏，目标是找到一个 1 到 n 范围内的数字。                                               | 输入:  <br>n = 10<br>pick = 6  <br><br>输出:  <br>6                                            | 使用二分搜索逐步缩小范围。                                                                                                                                                                                                                 |
| 666<br><br>(m)     | [[Guess Number Higher or Lower II]]猜数游戏 II                    | 找到最小的最大花费金额来猜中数字。                                                           | 输入:  <br>n = 10  <br><br>输出:  <br>16                                                       | 使用动态规划模拟猜测过程，优化最大花费。                                                                                                                                                                                                          |
| 148<br><br>(m)<br> | [[Sort Colors]]颜色分类                                           | 对数组中的三种颜色（0、1、2）进行排序。                                                       | 输入:  <br>nums = [2,0,2,1,1,0]  <br>输出:  <br>[0,0,1,1,2,2]                                  | 使用哈希表记录每种颜色的频率后重建数组。                                                                                                                                                                                                          |
| 143<br><br>(m)     | [[Sort Colors II]]颜色分类 II                                     | 对包含 k 种颜色的数组进行排序，颜色从 1 到 k。                                                 | [3,2,2,1,4]  <br>k = 4  <br><br>输出:  <br>[1,2,2,3,4]                                       | 使用哈希表记录每种颜色出现的频率后重建数组。                                                                                                                                                                                                        |
| 144<br><br>(m)<br> | [[Interleaving Positive and Negative Numbers]]交错正负数           | 重新排列数组使得正负数交替出现。                                                            | 输入:  <br>nums = <br>[-1,-2,1,2]  <br><br>输出:  <br>[1,-1,2,-2]                              | 使用哈希表和双指针分别记录正数和负数并交替排列。                                                                                                                                                                                                      |








### 雙指針的題目
###### 雙指針
參考 [[雙指針]]


|                                                              |     |
| ------------------------------------------------------------ | --- |
| 在list找兩個或多個數的和為k:   sort -> 雙指針<br>在list找連續子數組的和為k:      前綴和 |     |
| 比較(1)Fast Sorting (2)雙指針                                     |     |
|                                                              |     |
|                                                              |     |

| **题目编号**                 | **题目名称 (英文/中文)**                                                            | **题目简述 (中文)**                                       | **样例**                                                                                                                                                         | **解法**                                                 |
| ------------------------ | --------------------------------------------------------------------------- | --------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------ |
| 607<br>*<br>(e)          | [[Two Sum III]]<br>两数之和 III                                                 | 实现一个数据结构支持插入数字和查询是否存在两个数字和等于目标值。                    | 输入:  <br>add(1), add(3), add(5), <br>find(4), find(7)<br> <br>输出: True, False<br><br>O(n),O(n)                                                                 | 使用哈希表存储数字及其出现次数，遍历检查目标差值是否存在。                          |
| 56<br>**<br>(e)<br>0<br> | [[Two Sum]]<br>两数之和                                                         | 在数组中找到两个数，使得它们的和等于目标值，返回它们的下标。                      | 输入: <br>[2, 7, 11, 15]<br>target = 9 <br><br>输出: [0, 1]<br><br>O(nlogn),O(n)                                                                                   | 先排序然後用雙指針從左右往中間, 和target比較決定往右往左                       |
| 609<br>*<br>(m)          | [[Two Sum - Less than or equal to target]]<br>两数和 - 小于或等于目标值                | 找出数组中所有和小于或等于目标值的两数组合个数。                            | 输入:  <br>[2,7,11,15]<br>target = 24 <br> <br>输出: 5<br><br>O(nlogn),O(1)                                                                                        | 先排序数组，使用双指针计算符合条件的组合个数。                                |
| 443<br>*<br>(m)          | 两数之和 II [[Two Sum - Greater than target]]                                   | 找出数组中所有和大于目标值的两数组合个数。                               | 输入:  <br>nums = <br>[2,7,11,15] <br>target = 10  <br><br>输出: 4<br><br>O(nlogn),O(1)                                                                            | 先排序数组，使用双指针计算符合条件的组合个数。                                |
| 610<br>*<br>(m)          | 两数和 - 差等于目标值 [[Two Sum - Difference equals to target]]                      | 找到数组中两个数，其差等于目标值，返回它们的索引。                           | 输入:  <br>nums = <br>[2,7,11,15]<br>target = 5  <br><br>输出: <br>[0,1]<br><br>O(n),O(1)                                                                          | 使用哈希表记录遍历过的数字，查找是否存在与当前数的差等于目标值的数。                     |
| 57<br>**<br>(m)          | 三数之和 [[3Sum]]                                                               | 找到数组中所有和为零的三元组，结果不能包含重复的三元组。                        | 输入:  <br>nums = <br>[-1,0,1,2,-1,-4]  <br><br>输出: [ <br>[-1,-1,2], <br>[-1,0,1] <br>]<br><br>O(n^2),O(1)                                                       | 先排序数组，再固定一个数字，使用双指针寻找剩余两个数字的组合。                        |
| 59<br><br>(m)<br>        | [[3 Sum Closest]]最接近的三数之和                                                   | 找到数组中三个数的和最接近目标值。                                   | 输入:  <br>nums = <br>[-1,2,1,-4]  <br>target = 1 <br> <br>输出:  <br>2                                                                                            | 排序后使用双指针遍历，动态更新最接近的和。                                  |
| 58<br>**<br>(m)          | 四数之和  [[4Sum]]                                                              | 给一个包含n个数的整数数组S，在S中找到所有使得和为给定整数target四元组(a, b, c, d) | 输入:  <br>numbers = <br>[2,7,11,15]<br>target=3<br><br>输出: []<br><br>O(n^3),O(1)                                                                                | 固定两个点，然后用双指针的做法，扫描一下后续数组，记录答案即可。                       |
| 976<br>*<br>(m)          | 四数之和 II [[4Sum II]]                                                         | 找出数组中所有和为目标值的四元组，结果不能包含重复的四元组。                      | 输入:  <br>nums = <br>[1,0,-1,0,-2,2]<br>target = 0 <br> <br>输出: [<br>[-2,-1,1,2],<br>[-2,0,0,2],<br>[-1,0,0,1]]<br><br>O(n^2),O(n^2)                            | 先排序数组，固定两个数字，使用双指针查找剩余两个数字的组合。                         |
| 89<br>*<br>(h)<br>!!     | K数之和 [[KSum]]                                                               | 找出数组中和等于目标值的 k 个数的组合。                               | 输入:  <br>nums = <br>[1,0,-1,0,-2,2]<br>target = 0<br>k = 4  <br><br>输出: [ <br>[-2,-1,1,2],<br>[-2,0,0,2],<br>[-1,0,0,1] ]<br><br>O(n×k×target),<br>O(k×target) | 用DP遍歷不同方案                                              |
| 90<br>*<br>(m)           | K数之和 II [[k Sum II]]                                                        | 找出数组中和等于目标值的 k 个数的所有组合，每个数只能使用一次。                   | 输入:  <br>nums = <br>[10,1,2,7,6,1,5]<br>target = 8, <br>k = 2  <br><br>输出: [ <br>[1,7],[2,6] <br>]<br><br>O(2^n),O(k)                                          | 使用DFS遞歸遍歷所有可能的子集，過程中剪枝以提高效率                            |
|                          | **滑動窗口**                                                                    |                                                     |                                                                                                                                                                |                                                        |
| 604<br>*<br>(e)          | 滑动窗口内数的和 [[Window Sum]]                                                     | 给定一个数组和窗口大小 k，返回每个窗口的元素和。                           | 输入:  <br>nums = <br>[1,2,3,4,5]<br>k = 3  <br><br>输出: [6,9,12]                                                                                                 | 使用双指针滑动窗口计算每个窗口的和，避免重复计算。                              |
| 32<br>**<br>(m)          | 最小子串覆盖 [[Minimum Window Substring]]                                         | 找到字符串中包含目标字符的最小子串。                                  | 输入:  <br>s = <br>"adobecodebanc"<br>t = "abc"  <br><br>输出: "banc"                                                                                              | 使用滑动窗口（双指针）维护窗口的字符计数，动态更新最小子串。                         |
| 1246<br>**<br>(m)        | 替换后的最长重复字符 [[Longest Repeating Character Replacement]]                      | 给定一个字符串和一个数字 k，找到替换 k 个字符后最长的重复子串长度。                | 输入:  <br>s = "AABABBA"<br>k = 1  <br><br>输出: 4                                                                                                                 | 使用滑动窗口记录窗口内的字符频率，动态调整窗口大小并计算最大长度。                      |
| 386<br>*<br>(m)          | 最多有 k 个不同字符的最长子字符串 [[Longest Substring with At Most K Distinct Characters]] | 找出字符串中包含最多 k 个不同字符的最长子串长度。                          | 输入:  <br>s = "eceba"<br>k = 2  <br><br>输出: 3                                                                                                                   | 使用滑动窗口记录窗口内的字符频率，动态调整窗口大小并计算最大长度。                      |
| 1375<br>*<br>(m)         | 至少 K 个不同字符的子串 [[Substring With At Least K Distinct Characters]]             | 找到字符串中包含至少 K 个不同字符的子串的数量。                           | 输入:  <br>s = "abcabc"<br>k = 2  <br><br>输出: 10                                                                                                                 | 使用滑动窗口维护窗口内的字符计数，动态更新子串数量。                             |
| 1849<br>*<br>(m)         | 爱生气的书店老板 [[Grumpy Bookstore Owner]]                                         | 给定书店顾客满意度和老板是否生气的记录，找到可以让最多顾客满意的时间段。                | 输入:  <br>customers = <br>[1,0,1,2,1,1,7,5]<br>grumpy = <br>[0,1,0,1,0,1,0,1]<br>X = 3  <br><br>输出: 16<br><br>O(n),O(n)                                         | 使用滑动窗口记录满意度的变化量，动态调整窗口大小，计算最大满意度。                      |
| 1643<br>*<br>(m)         | 摘水果 [[Pick Fruits]]                                                         | 找到连续摘取两种水果的最大数量。                                    | 输入:  <br>fruits = <br>[1,2,1,2,3,2,1]<br>  <br>输出: 4  <br>([1,2,1,2])                                                                                          | 使用滑动窗口记录当前水果种类和数量，动态调整窗口范围，找到最大长度。                     |
|                          |                                                                             |                                                     |                                                                                                                                                                |                                                        |
|                          | **分割數組**                                                                    |                                                     |                                                                                                                                                                |                                                        |
| 539<br>**<br>(e)         | 移动零 [[Move Zeroes]]                                                         | 将数组中的所有零移动到末尾，同时保持非零元素的相对顺序。                        | 输入:  <br>nums = [0,1,0,3,12]  <br>输出: [1,3,12,0,0]                                                                                                             | 使用双指针都從0,0往右，一个指针遍历数组，另一个指针指向下一个非零元素的位置。               |
| 31<br>**<br>(m)          | 分割数组 [[Partition Array]]                                                    | 给定一个数组和目标值，将数组分割成两部分，使得左边的所有数小于目标值，右边的所有数大于等于目标值。   | 输入:  <br>nums = [3,2,2,1]<br>target = 2  <br><br>输出: [1,2,2,3]                                                                                                 | (Quick sort)使用双指针，从两端向中间移动，将小于目标值的数移到左边，大于等于目标值的数移到右边。 |
| 328<br>*<br>(m)          | 字符串划分 [[String Partition]]                                                  | 将字符串分割为多个部分，使得每个部分只包含一种字符。                          | 输入:  <br>s = "abacbc" <br> <br>输出: <br>["aba","cbc"]<br><br>O(n),O(1)                                                                                          | 使用双指针记录当前字符范围，找到每段分割点，动态更新结果。                          |
| 373<br>*<br>(e)          | 奇偶分割数组 [[Partition Array by Odd and Even]]                                  | 将数组分割为奇数在前，偶数在后，同时保持它们的相对顺序。                        | 输入:  <br>nums = <br>[1,4,2,3,5,6]  <br><br>输出: <br>[1,3,5,4,2,6]                                                                                               | 使用双指针，从两端向中间移动，将奇数和偶数交换位置。                             |
| 49<br>*<br>(e)           | 字符大小写排序 [[Sort Letters by Case]]                                            | 给定一个字符串，将其中的小写字母排在前面，大写字母排在后面。                      | 输入:  <br>s = "abCDeF" <br> <br>输出: "abeCDF"                                                                                                                    | 使用双指针从两端向中间移动, 分别找到未排小写字母和大写字母，交换位置，保持顺序。              |
|                          |                                                                             |                                                     |                                                                                                                                                                |                                                        |
| 64<br>*<br>(e)           | 合并排序数组（简单版） [[Merge Sorted Array (easy version)]]                           | 将两个已排序数组合并为一个排序数组。                                  | 输入<br>A = [1,2,3]<br>m = 3<br>B = [4,5]<br>n = 2<br><br>输出:<br>[1,2,3,4,5]                                                                                     | 从两个数组的index=0,0开始比较，将较大元素依次插入 nums1 的后半部分。             |
| 6<br>*<br>(e)            | 合并排序数组 [[Merge Two Sorted Arrays]]                                          | 将两个已排序数组合并为一个排序数组。                                  | 输入<br>A = [1,2,3,4]<br>B = [2,4,5,6]<br><br>输出:<br>[1,2,2,3,4,4,5,6]                                                                                           | 从两个数组的index=0,0开始比较，将较大元素依次插入 nums1 的后半部分。             |
|                          | Others                                                                      |                                                     |                                                                                                                                                                |                                                        |
| 1219<br>*<br>(m)         | 加热器 [[Heaters]]                                                             | 给定房屋和加热器的位置，找到每个房屋需要的最小加热半径，使所有房屋都能被覆盖。             | 输入:  <br>houses = <br>[1,2,3,4]<br>heaters = <br>[1,4]  <br><br>输出: 1                                                                                          | 对房屋和加热器排序，使用双指针找到每个房屋的最近加热器，计算最大半径。                    |
| 382<br>*<br>(m)          | 三角形计数 [[Triangle Count]]                                                    | 找出数组中满足三角形条件的三元组个数。                                 | 输入:  <br>nums = <br>[4,2,3,4]  <br><br>输出: 4<br><br>O(n^2),O(1)                                                                                                | 先排序数组，固定一边长，使用双指针left, right查找满足条件的三元组。                |
| 200<br>**<br>(m)         | 最长回文子串 [[Longest Palindromic Substring]]                                    | 找到字符串中的最长回文子串。                                      | 输入:  <br>s = "babad" <br> <br>输出: <br>"bab" 或 "aba"<br><br>O(n^2),O(1)                                                                                         | 使用双指针扩展中心，判断两侧字符是否相等，更新最长回文子串。                         |
| 1870<br>*<br>(m)         | 全零子串的数量 [[Number of Substrings with All Zeroes]]                            | 找出字符串中只包含 0 的子串数量。                                  | 输入:<br>"00010011"<br><br>输出:9                                                                                                                                  | 使用双指针统计连续 0 的长度，计算包含的所有子串数量。                           |
| 521<br>*<br>(e)          | 去除重复元素 [[Remove Duplicate Numbers in Array]]                                | 从数组中去除所有重复元素，返回剩余的数组长度。                             | 输入:  <br>nums = [1,1,2,2,3]  <br>输出: 3                                                                                                                         | 使用双指针遍历数组，将未重复的元素移到数组前部。                               |
| 390<br>*<br>(h)          | 寻找峰值 II [[Find Peak Element II]]                                            | 找到二维数组中的一个峰值位置，峰值是指元素大于其上下左右的邻居值。                   | 输入: <br>    [<br>      [1, 5, 3],<br>      [4,10, 9],<br>      [2, 8, 7]<br>    ]<br><br>输出: [1,1]<br><br>解释: 只有这一个峰值<br>O(mlogn),O(1)                         | 使用双指针逐步缩小矩阵范围，找到峰值位置。                                  |



# **<mark style="background: #FF5582A6;">链表（Linked List）</mark>的详细介绍**

###### 鍊表

| 题目编号                 | 题目名称（英文）                                                  | 题目简述（中文）                                                       | 样例                                                                                                                                                                           | 解法                                                                 |
| -------------------- | --------------------------------------------------------- | -------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------ |
| 35<br>*<br>(e)       | [[Reverse Linked List]]翻转链表                               | 反转一个链表。                                                        | 输入: <br>1->2->3->null <br><br>输出: <br>3->2->1->null                                                                                                                          | 使用迭代或递归方法反转链表。迭代方法中，遍历链表，将当前节点的 next 指向前一个节点。递归方法中，递归反转子链表，然后调整指针。 |
| 36<br><br>(m)<br>    | [[Reverse Linked List II]]翻转链表II                          | 反转链表中第 m 个节点到第 n 个节点之间的部分。1 ≤ m ≤ n ≤ 链表长度。                    | 输入: <br>1->2->3->4->5->null<br>m = 2<br>n = 4 <br><br>输出: <br>1->4->3->2->5->null                                                                                            | 使用迭代方法，找到第 m-1 个节点，反转第 m 到第 n 个节点，然后重新连接链表。                        |
| 96<br><br>(e)<br>    | [[Partition List]]链表划分                                    | 给定一个链表和一个值 x，分隔链表，使得所有小于 x 的节点在大于或等于 x 的节点之前。保留两个部分内节点的初始相对顺序。 | 输入: <br>1->4->3->2->5->2->null<br>x = 3 <br><br>输出: <br>1->2->2->4->3->5->null                                                                                               | 使用两个指针分别处理小于 x 和大于等于 x 的节点，最后将两个链表连接。<br><br>                      |
| 112<br><br>(e)<br>   | [[Remove Duplicates from Sorted List]]删除排序链表中的重复元素        | 删除排序链表中的重复元素，使每个元素只出现一次。                                       | 输入: <br>1->1->2->3->3->null <br><br>输出: <br>1->2->3->null                                                                                                                    | 遍历链表，删除重复的节点。                                                      |
| 113<br><br>(m)       | [[Remove Duplicates from Sorted List II]]删除排序链表中的重复元素II   | 删除排序链表中的重复元素，重复的节点全部删除，只保留没有重复的数字。                             | 输入: <br>1->2->3->3->4->4->5->null <br><br>输出: <br>1->2->5->null                                                                                                              | 使用双指针遍历链表，跳过重复的节点。                                                 |
| 165<br>*<br>(e)      | [[Merge Two Sorted Lists]]合并两个排序链表                        | 将两个排序链表合并为一个新的排序链表。                                            | 输入: <br>1->2->4->null, <br>1->3->4->null <br><br>输出: <br>1->1->2->3->4->4->null                                                                                              | 使用迭代或递归方法合并两个链表。迭代方法中，使用两个指针遍历两个链表，按顺序连接节点。递归方法中，递归合并子链表。          |
| 166<br><br>(e)       | [[Nth to Last Node in List]]链表倒数第n个节点                     | 找到链表中倒数第 n 个节点。                                                | 输入: <br>1->2->3->4->5->null<br>n = 2 <br><br>输出: 4                                                                                                                           | 使用双指针，先让第一个指针移动 n 步，然后两个指针一起移动，直到第一个指针到达末尾，第二个指针即为倒数第 n 个节点。       |
| 167<br><br>(e)<br>   | [[Add Two Numbers]]链表求和                                   | 给定两个非空链表，表示两个非负整数。数字以逆序存储，每个节点包含一个数字。将两个数相加，并以相同形式返回一个链表。      | 输入: <br>(2 -> 4 -> 3) + <br>(5 -> 6 -> 4) <br><br>输出: 7 -> 0 -> 8                                                                                                            | 使用指针遍历两个链表，逐位相加，处理进位，生成新的链表。                                       |
| 170<br><br>(m)<br>   | [[Rotate List]]旋转链表                                       | 给定一个链表，向右旋转链表，使每个节点向右移动 k 个位置，其中 k 是非负数。                       | 输入: <br>1->2->3->4->5->null<br>k = 2 <br><br>输出: <br>4->5->1->2->3->null                                                                                                     | 计算链表长度，找到新的头节点位置，重新连接链表。<br><br>                                   |
| 174<br>*<br>(e)<br>  | [[Remove Nth Node From End of List]]删除链表中倒数第 n 个节点        | 删除链表的倒数第 n 个节点，并返回链表的头节点。                                      | 输入: <br>1->2->3->4->5->null<br>n = 2 <br><br>输出: <br>1->2->3->5->null                                                                                                        | 使用双指针，先让第一个指针移动 n 步，然后两个指针一起移动，直到第一个指针到达末尾，删除第二个指针指向的节点。           |
| 452<br><br>(e)       | [[Remove Linked List Elements]]删除链表中的元素                   | 删除链表中等于给定值 val 的所有节点。                                          | 输入: <br>1->2->6->3->4->5->6->null<br>val = 6 <br><br>输出: <br>1->2->3->4->5->null                                                                                             | 遍历链表，删除值为 val 的节点。                                                 |
| 223<br><br>(m)<br>   | [[Palindrome Linked List]]回文链表                            | 判断链表是否为回文链表。                                                   | 输入: <br>1->2->2->1->null <br><br>输出: true                                                                                                                                    | 使用快慢指针找到链表中点，反转后半部分链表，然后比较前半部分和反转后的后半部分是否相同。                       |
| 372<br><br>(e)<br>   | [[Delete Node in a Linked List]]删除链表节点                    | 删除链表中的一个非末尾节点，给定该节点的指针。                                        | 输入: <br>1->2->3->4->5->null, <br>删除节点 3 <br><br>输出: <br>1->2->4->5->null                                                                                                     | 将要删除的节点的值替换为下一个节点的值，然后删除下一个节点。                                     |
| 1292<br><br>(m)      | [[Odd Even Linked List]]奇偶链表                              | 给定一个单链表，将所有奇数节点和偶数节点分组在一起，保持它们的相对顺序，并返回重新排列后的链表。               | 输入: <br>1->2->3->4->5->null <br><br>输出: <br>1->3->5->2->4->null                                                                                                              | 使用两个指针分别指向奇数节点和偶数节点，将它们分离并重新连接。                                    |
| 904<br><br>(m)       | [[Plus One Linked List]]加一链表                              | 给定一个链表，表示一个非负整数，每个节点包含一位数字，返回加 1 后的链表。                         | 输入: <br>1->2->3->null <br><br>输出: <br>1->2->4->null                                                                                                                          | 反转链表，从头开始加 1，处理进位问题，最后再反转链表。                                       |
| 221<br><br>(m)       | [[Add Two Numbers II]]链表求和 II                             | 给定两个链表，表示两个非负整数，数字按正常顺序存储，返回它们的和（以链表形式）。                       | 输入: <br>(7 -> 2 -> 4 -> 3) + <br>(5 -> 6 -> 4) <br><br>输出: <br>7 -> 8 -> 0 -> 7                                                                                              | 反转链表，逐位相加处理进位，然后再反转链表得到结果。                                         |
| 1609<br>*<br>(e)<br> | [[Middle of the Linked List]]链表的中间结点                      | 找到链表的中间节点，若有两个中间节点，返回第二个中间节点。                                  | 输入: <br>1->2->3->4->5->null <br><br>输出: <br>3->4->5->null                                                                                                                    | 使用快慢指针，快指针移动两步，慢指针移动一步，当快指针到达末尾时，慢指针即为中间节点。                        |
| 105<br><br>(m)       | [[Copy List with Random Pointer]]复制带随机指针的链表               | 给定一个链表，其中每个节点包含一个额外的随机指针，指向链表中的任意节点或 null。返回其深拷贝。              | 输入: <br>head = [<br>[7,null],[13,0],<br>[11,4],[10,2],<br>[1,0]] <br><br>输出: 深拷贝链表                                                                                           | 使用哈希表存储旧节点与新节点的映射，遍历链表创建新节点并建立连接。                                  |
| 106<br><br>(m)       | [[Convert Sorted List to Binary Search Tree]]有序链表转换为二叉搜索树 | 将一个升序排列的链表转换为高度平衡的二叉搜索树。                                       | 输入: <br>head = [-10,-3,0,5,9] <br><br>输出: <br>树根节点为 0                                                                                                                        | 使用快慢指针找到链表中间节点作为根节点，递归构建左右子树。                                      |
| 102<br>*<br>(m)<br>  | [[Linked List Cycle]]带环链表                                 | 判断链表中是否有环。                                                     | 输入: <br>head = [3,2,0,-4]<br>pos = 1 <br><br>输出: true                                                                                                                        | 使用快慢指针，若快指针和慢指针相遇，则链表中存在环。                                         |
| 103<br><br>(h)       | [[Linked List Cycle II]]带环链表 II                           | 找到链表环的起始节点，若无环则返回 null。                                        | 输入: <br>head = [3,2,0,-4]<br>pos = 1 <br><br>输出: <br>返回指向节点 2 的指针                                                                                                            | 使用快慢指针找到相遇点，然后一个指针从头开始，另一个指针从相遇点开始，每次移动一步，直到两个指针相遇即为环的起始节点。        |
| 99<br>*<br>(m)       | [[Reorder List]]重排链表                                      | 给定一个链表，将其重新排序为 L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → ……            | 输入: <br>1->2->3->4->5->null <br><br>输出: <br>1->5->2->4->3->null                                                                                                              | 使用快慢指针找到链表中点，反转后半部分链表，然后将两部分交替连接。                                  |
| 134<br>**<br>(h)     | LRU缓存策略 [[LRU Cache]]                                     | 实现一个数据结构支持LRU缓存机制，包含获取和放入两个操作，并保持最近使用的数据优先。                    | 输入:  <br>LRUCache cache = new LRUCache(2);  <br>cache.put(1, 1);  <br>cache.put(2, 2);  <br>cache.get(1);  <br>cache.put(3, 3);  <br>cache.get(2);  <br><br>输出:  <br>[1, -1] | 使用哈希表和双向链表，哈希表用于快速定位，链表维护使用顺序，将最新访问的数据移到链表头部。                      |
| 24<br>*<br>(h)       | [[LFU Cache]]   LFU缓存策略                                   | 实现 LFU 缓存，支持 `get` 和 `put` 操作。                                 |                                                                                                                                                                              | 使用哈希表和双向链表动态维护最少使用的元素。                                             |
| 104<br>**<br>(m)     | 合并k个排序链表 [[Merge K Sorted Lists]]                         | 合并k个排序链表，返回一个升序合并后的链表。                                         | 输入:  <br>lists = [<br>[1,4,5],<br>[1,3,4],<br>[2,6]] <br> <br>输出: <br>[1,1,2,3,4,4,5,6]                                                                                      | 使用优先队列（最小堆）动态获取每个链表当前最小值，将其连接到结果链表中，重复直到所有链表为空。                    |
| 453<br><br>(e)<br>   | [[Flatten Binary Tree to Linked List]]将二叉树拆成链表            | 将二叉树展开为单链表，按先序遍历顺序排列。                                          | 输入:  <br>root = <br>[1,2,5,3,4,null,6]  <br><br>输出:  <br>[1,null,2,null,3,null,<br>4,null,5,null,6]                                                                          | 使用递归或栈模拟先序遍历，将左右子树依次连接到当前节点后面。                                     |
| 116<br>*<br>(m)      | [[Jump Game]]跳跃游戏                                         | 给定一个非负整数数组，判断是否能跳到最后一个位置。                                      | 输入:  <br>nums = <br>[2,3,1,1,4]  <br><br>输出:  <br>true                                                                                                                       | 从后向前遍历，记录最远可跳位置，若当前位置能到达最远可跳位置，则继续检查下一个位置。                         |




# **<mark style="background: #FF5582A6;">队列（Queue）</mark>的详细介绍**

 ###### 隊列

| 题目编号                | 题目名称（英文）                                               | 题目简述（中文）                                             | 样例                                                                                                                        | 解法                                                                                                              |
| ------------------- | ------------------------------------------------------ | ---------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------- |
| 494<br>*<br>(e)<br> | [[Implement Stack using Queues]]双队列实现栈                 | 使用队列实现栈，支持 `push(x)`、`pop()`、`top()` 和 `empty()` 操作。 | 输入：<br>push(1)<br>pop()<br>push(2)<br>isEmpty() // return false<br>top() // return 2<br>pop()<br>isEmpty() // return true | 使用两个队列实现栈功能：一个队列用于存储元素，另一个队列用于辅助反转元素顺序。每次插入元素时，将新元素添加到辅助队列，然后将主队列的所有元素依次移动到辅助队列，交换主辅队列。                         |
| 40<br><br>(m)       | [[Implement Queue by Two Stacks]]用栈实现队列                | 使用两个栈实现队列，支持 `push(element)`、`pop()` 和 `top()` 操作。   | 队列操作 = <br>    push(1)<br>    pop()    <br>    push(2)<br>    push(3)<br>    top()    <br>    pop()                       | 使用两个栈实现队列功能：一个栈用于入队操作，另一个栈用于出队操作。当出队栈为空时，将入队栈的所有元素依次弹出并压入出队栈，然后从出队栈弹出元素以实现队列的先进先出特性。                            |
| 999<br><br>(m)<br>  | [[Design Circular Deque]]用循环数组实现双向队列                   | 设计实现双端循环队列，支持插入、删除、获取队首和队尾元素、检查队列是否为空或已满等操作。         |                                                                                                                           | 使用固定大小的数组实现循环双端队列，维护头尾指针和当前元素数量，实现各项操作。                                                                         |
| 642<br><br>(e)      | [[Moving Average from Data Stream]]数据流滑动窗口平均值          | 给定一个整数流和窗口大小，计算滑动窗口的平均值。                             |                                                                                                                           | 使用一个队列存储滑动窗口中的元素，并维护窗口元素总和。每次插入新元素时，若队列长度超过窗口大小，则移除队列头部元素，并更新总和，然后计算平均值。                                        |
| 362<br>**<br>(h)    | [[Sliding Window Maximum]]滑动窗口的最大值                     | 给定一个整数数组和滑动窗口大小，找出每个窗口中的最大值。                         | 输入: <br>nums = <br>[1,3,-1,-3,<br>5,3,6,7]<br><br>k = 3 <br>输出: <br>[3,3,5,5,6,7]                                         | 使用双端队列（deque）维护当前窗口的最大值索引。遍历数组时，移除队列中不在当前窗口范围内的元素，并移除队列中小于当前元素的所有元素，然后将当前元素索引添加到队列。当前元素索引大于等于窗口大小时，队首即为当前窗口最大值。 |
| 360<br><br>(h)<br>  | [[Sliding Window Median]]滑动窗口的中位数                      | 给定一个整数数组和滑动窗口大小，计算滑动窗口中位数。                           | 输入:<br>[1,2,7,8,5]<br>3<br><br>输出:<br>[2,7,7]                                                                             | 使用两个优先队列（最大堆和最小堆）来维护当前窗口的元素，以便快速获取中位数。每次滑动窗口时，移除离开窗口的元素，添加进入窗口的元素，调整两个堆的平衡，然后根据窗口大小确定中位数。                       |
| 1031<br><br>(m)<br> | [[Is Graph Bipartite]]?图可以被二分么                         | 判断给定的无向图是否是二分图。                                      | 输入: <br>graph = [<br>[1,3],[0,2],<br>[1,3],[0,2]<br>] <br><br>输出: true                                                    | 使用队列进行广度优先搜索（BFS），尝试将图中的节点染色为两种颜色。若某个节点的相邻节点已经被染成相同颜色，则图不是二分图；否则继续染色，直到遍历所有节点。                                  |
| 71<br><br>(m)<br>   | [[Binary Tree Zigzag Level Order]]Traversal二叉树的锯齿形层次遍历 | 给定一个二叉树，返回其节点值的锯齿形层次遍历（即第一层从左到右，第二层从右到左，依此类推）。       | 输入: <br>{3,9,20,#,#,15,7} <br><br>输出: [<br>[3],<br>[20, 9], <br>[15, 7]]                                                  | 使用双端队列进行广度优先搜索（BFS），根据当前层的遍历方向决定节点值的添加顺序，实现锯齿形遍历。                                                               |




# **<mark style="background: #ADCCFFA6;">单调队列（Monotone Queue）</mark>的详细介绍**

###### 單調隊列

| 题目编号                 | 题目名称（英文）                                                | 题目简述（中文）                                              | 样例                                                                                                   | 解法                                   |
| -------------------- | ------------------------------------------------------- | ----------------------------------------------------- | ---------------------------------------------------------------------------------------------------- | ------------------------------------ |
| 653<br><br>(h)       | [[Expression Add Operators]]添加运算符                       | 给定一个仅包含数字的字符串和一个目标值，为该字符串插入操作符，使得计算结果等于目标值，返回所有可能的结果。 | 输入:  <br>num = "123"  <br>target = 6  <br><br>输出:  <br>["1+2+3", <br>"1_2_3"]                        | 使用回溯法或单调队列，逐步插入操作符计算结果。              |
| 603<br><br>(m)       | [[Largest Divisible Subset]]最大整除子集                      | 找到给定数组中最长的可整除子集。                                      | 输入:  <br>nums = [1,2,3]  <br><br>输出:  <br>[1,2]                                                      | 使用动态规划和单调队列记录每个子集的最大长度及路径。           |
| 903<br><br>(m)       | [[Range Addition]]范围加法                                  | 给定一个长度为 n 的数组和一组更新操作，返回更新后的数组。                        | 输入:  <br>length = 5  <br>updates = [ <br>[1,3,2],[2,4,3],[0,2,-2] ]  <br><br>输出:  <br>[ -2,0,3,5,3 ] | 使用差分数组记录区间增量，最后计算前缀和得到结果。            |
| 1276<br>*<br>(e)<br> | [[Sum of Two Integers]]两整数之和                            | 使用位运算计算两个整数的和，而不能使用 `+` 和 `-` 操作符。                    | 输入:  <br>a = 1, b = 2  <br>输出:  <br>3                                                                | 使用位运算模拟加法过程，按位计算进位和当前位值。             |
| 1275<br><br>(m)      | [[Super Pow]]超级幂次                                       | 计算 `a^b % 1337`，其中 `b` 是一个非常大的整数以数组形式给出。              | 输入:  <br>a = 2<br>b = [3]  <br><br>输出:  <br>8                                                        | 使用快速幂和单调队列，动态处理大整数。                  |
| 1507<br>*<br>(h)     | 和至少为 K 的最短子数组 [[Shortest Subarray with Sum at Least K]] | 给定一个整数数组，找到和至少为K的最短子数组长度，若不存在返回-1。                    | 输入:  <br>nums = <br>[2, -1, 2]<br>k = 3  <br><br>输出: 3                                               | 使用单调队列记录前缀和，动态检查当前子数组和是否满足条件并更新最短长度。 |


### BFS(寬度優先搜索)的題目
###### BFS 
參考 [[BFS]]

| **题目编号**                   | **题目名称 (英文/中文)**                                   | **题目简述 (中文)**                                                                           | **样例**                                                                                                                                                                                                                            | **解法**                                                                                                          |
| -------------------------- | -------------------------------------------------- | --------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------- |
| 433<br>**<br>(e)           | 岛屿的个数 [[Number of Islands]]                        | 给定一个二维网格，计算其中岛屿的数量。                                                                     | 输入：<br>[<br>  [1,1,0,0,0],<br>  [0,1,0,0,1],<br>  [0,0,0,1,1],<br>  [0,0,0,0,0],<br>  [0,0,0,0,1]<br>]<br><br>输出：<br>3                                                                                                            | 使用 BFS 遍历每个岛屿，将相邻陆地标记为已访问。                                                                                      |
| 1080<br><br>(e)            | [[Max Area of Island]] (最大岛屿面积)                    | 找到二维网格中最大的岛屿面积。                                                                         | 输入: grid = [ <br>[0, 0, 1, 0],  <br>[1, 1, 1, 0],<br>[0, 1, 0, 0] ]<br><br>输出:  5                                                                                                                                                 | 使用 DFS 或 BFS 遍历岛屿，累计连通的 1 的数量。                                                                                  |
| 611<br>**<br>(m)<br><br>PR | 骑士的最短路线 [[Knight Shortest Path]]                   | 在棋盘上从起点移动到终点，返回骑士所需的最小步数。                                                               | 输入:[ <br>[0,0,0],<br>[0,0,0],<br>[0,0,0]]<br>source<br>= [2, 2] <br>destination <br>= [2, 2] <br><br>输出: 2                                                                                                                        | 使用 BFS 搜索骑士的合法移动路径，记录访问状态以避免重复。                                                                                 |
| 630<br>*<br>(m)            | 骑士的最短路径 II [[Knight Shortest Path II]]             | 限制骑士只能向前或向后跳，找到最小步数。                                                                    | 输入:[<br>[0,0,0,0],<br>[0,0,0,0],<br>[0,0,0,0]]<br><br>输出: 3                                                                                                                                                                       | 使用 BFS 搜索路径，并限制合法移动方向。                                                                                          |
| 598<br>*<br>(m)<br><br>PR  | 僵尸矩阵 [[Zombie in Matrix]]                          | 给定一个二维网格，找到将所有人类转化为僵尸所需的最短时间。                                                           | 输入:<br>grid = [<br>[0,1,0],<br>[1,0,0],<br>[0,0,0]]<br><br>输出: 2<br>                                                                                                                                                              | 使用 BFS 模拟传播过程，记录时间步数。**多源 BFS**                                                                                 |
| 3726<br><br>(m)            | [[Rotting Oranges]]腐烂的橘子                           | 给定一个二维网格，其中每个单元格可以是 0（空单元格）、1（新鲜橘子）或 2（腐烂橘子）。找出让所有橘子腐烂所需的最少时间。                          | 输入: [<br>[2,1,1],<br>[1,1,0],<br>[0,1,1]] <br><br>输出: 4                                                                                                                                                                           | 使用队列存储所有初始的腐烂橘子位置，执行多源广度优先搜索（BFS）。每次从队列中取出一个腐烂橘子，标记相邻的新鲜橘子为腐烂，并将其加入队列，同时更新时间计数。若 BFS 结束后仍存在新鲜橘子，返回 -1，否则返回时间计数。 |
| 1428<br>**<br>(m)          | 钥匙和房间 [[Keys and Rooms]]                           | 判断是否可以使用钥匙打开所有房间。                                                                       | 输入:  <br>rooms = [ <br>[1],[2],<br>[3],[]]  <br><br>输出: true<br>                                                                                                                                                                  | 使用 BFS 搜索所有可以访问的房间，检查是否访问了所有房间。                                                                                 |
| 1565<br><br>(m)            | 飞行棋I [[Modern Ludo I]]                             | 模拟一个飞行棋游戏，找到从起点到终点的最小步数。棋盘上可能存在一些特殊的传送门. 每次掷骰子可以前进 1 到 6 格                              | 输入:  <br>n = 15, <br>connections<br>= [ <br>[2,10],<br>[7,14]]  <br><br>输出: 4                                                                                                                                                     | 使用广度优先搜索 (BFS) 建模为图的最短路径问题，动态更新步数。                                                                              |
| 1446<br><br>(m)            | [[01 Matrix Walking Problem]] 01矩阵走路问题             | 给定一个由 0 和 1 组成的矩阵，返回一个矩阵，其中每个单元格的值是其到最近的 0 的距离。                                         | 输入: [<br>[0,0,0],<br>[0,1,0],<br>[1,1,1]] <br><br>输出: [<br>[0,0,0],<br>[0,1,0],<br>[1,2,1]]                                                                                                                                       | 使用广度优先搜索（BFS），从所有值为 0 的单元格开始，将其周围的单元格加入队列，更新这些单元格的距离值并标记为已访问。每次从队列中取出一个单元格，继续更新其相邻单元格，直到队列为空。**多源 BFS**         |
| 974<br><br>(m)             | [[01 Matrix]] 01 矩阵                                | 给定一个由 0 和 1 组成的矩阵，返回一个矩阵，其中每个单元格的值是其到最近的 0 的距离。                                         | 输入: [<br>[0,0,0],<br>[0,1,0],<br>[1,1,1]] <br><br>输出: [<br>[0,0,0],<br>[0,1,0],<br>[1,2,1]]                                                                                                                                       | 使用广度优先搜索（BFS），从所有值为 0 的单元格开始，将其周围的单元格加入队列，更新这些单元格的距离值并标记为已访问。每次从队列中取出一个单元格，继续更新其相邻单元格，直到队列为空。                   |
| 137<br>**<br>(m)           | 克隆图 [[Clone Graph]]                                | 给定一个无向图，返回其深度克隆后的新图。                                                                    | 输入:<br>{1,2,4#2,1<br>,4#4,1,2}<br><br>输出: <br>{1,2,4#2,1<br>,4#4,1,2}                                                                                                                                                             | 使用哈希表记录已访问节点，结合 BFS 克隆节点及其邻接点。                                                                                  |
| 1413<br><br>(m)            | 树 [[Tree]]                                         | 构建哈希表存储树的父节点和子节点关系，支持树的增删查操作。                                                           | 输入:  <br>x = [1,1], <br>y = [2,3], <br>a =[1,2], <br>b = [2,3]<br><br>输出: [2,1]                                                                                                                                                   | 使用嵌套哈希表存储节点关系，动态支持树的维护。                                                                                         |
| 127<br><br>(m)<br>PR       | [[Topological Sorting]] (拓扑排序)                     | 给定有向无环图，返回其拓扑排序结果。                                                                      | 输入:  <br>graph =[ <br>[1,2], [], <br>[3], [] ]<br> <br>输出: <br>[0, 1, 2, 3]                                                                                                                                                       | 使用入度表和队列，逐步移除入度为 0 的节点完成排序。                                                                                     |
| 615<br>**<br>(m)           | 课程表 [[Course Schedule\|Course Schedule]]           | 现在你总共有 n 门课需要选，记为 0 到 n - 1.<br>一些课程在修之前需要先修另外的一些课程，判断是否可能完成所有课程？                       | 输入: <br>n = 4,<br>prerequisites = <br>[ [1,0],[2,0],<br>[3,1],[3,2] ] <br><br>输出: True                                                                                                                                            | 使用 BFS 实现**拓扑排序**，检查图是否存在环路。                                                                                    |
| 616<br>*<br>(m)            | 课程表 II [[Course Schedule II]]                      | 判断是否可以完成所有课程，并返回完成课程的顺序。你只要返回一种就可以了。                                                    | 输入: <br>n = 4,<br>prerequisites = <br>[ [1,0],[2,0],<br>[3,1],[3,2] ] <br><br>输出: <br>[0,1,2,3] or <br>[0,2,1,3]                                                                                                                  | 使用 BFS 实现**拓扑排序**，记录节点的入度，依次完成课程。                                                                               |
| 815<br><br>(h)             | 课程表 IV [[Course Schedule IV]]                      | 判断是否可以完成所有课程，并返回完成课程的顺序。返回你可以得到所有课程的不同方法的数量。                                            | 输入:  <br>numCourses = 4, <br>prerequisites = <br>[ [0,1],[1,2],<br>[2,3] ]<br>queries = <br>[ [0,3],[3,0] ]  <br><br>输出: <br>[true,false]                                                                                         | 使用 BFS 遍历课程依赖图，记录每门课程的可达性。**拓扑排序**                                                                              |
| 605<br>*<br>(m)            | 序列重构 [[Sequence Reconstruction]]                   | 判断是否可以通过给定子序列唯一确定原序列。                                                                   | 输入:<br>org = <br>[1,2,3] <br>seqs = [ <br>[1,2],<br>[1,3] ]<br><br>输出: false                                                                                                                                                      | 使用 BFS 结合**拓扑排序**检查唯一序列。                                                                                        |
| 892<br>**<br>(h)           | 外星人字典 [[Alien Dictionary]]                         | 给定一个外星语言单词列表，返回其字母的字典顺序。                                                                | 输入：<br>["wrt","wrf","er"<br>,"ett","rftt"]<br><br>输出："wertf"                                                                                                                                                                      | 构建有向图表示字母顺序，使用 BFS 获取**拓扑排序**结果。                                                                                |
| 803<br><br>(h)<br>         | [[Shortest Distance from All Buildings]]建筑物之间的最短距离 | 给定一个二维网格，找出一个空单元格，使得从该单元格到所有建筑物的距离之和最小，并返回该距离。                                          | 输入: [<br>[1,0,2,0,1],<br>[0,0,0,0,0],<br>[0,0,1,0,0]] <br><br>输出: 7                                                                                                                                                               | 使用广度优先搜索（BFS）从每个建筑物开始，计算到其他空单元格的距离，将这些距离累加到一个矩阵中，同时记录每个空单元格可访问的建筑物数量。最后遍历矩阵，找到可访问所有建筑物且总距离最小的单元格。               |
| 573<br>*<br>(h)            | 邮局的建立 II [[Build Post Office II]]                  | 给出一个二维的网格，每一格可以代表墙 2 ，房子 1，以及空 0 (用数字0,1,2来表示)，在网格中找到一个位置去建立邮局，使得所有的房子到邮局的距离和是最小的       | 输入: [<br>[1,0,2,0,1],<br>[0,0,0,0,0],<br>[0,0,1,0,0]] <br><br>输出: 4                                                                                                                                                               | 使用 BFS 计算每个空地到所有房屋的距离和，返回最小值。                                                                                   |
| 794<br>*<br>(h)            | 滑动拼图 II [[Sliding Puzzle II]]                      | 解决一个 2x3 拼图，返回最少的移动次数。                                                                  | 输入:  <br>board = [<br>[1,2,3],<br>[4,0,5] ]  <br><br>输出: 1                                                                                                                                                                        | 使用 BFS 记录每一步的状态和路径，寻找最短解法。                                                                                      |
| 950<br>*<br>(h)            | 滑动拼图 III [[Sliding Puzzle III]]                    | 给定一个 3x3 拼图，找出完成拼图的最少步骤，或判断是否无解。<br>finish =[<br>[ 1,2,3 ],<br>[ 4,5,6 ],<br>[ 7,8,0 ]] | 输入：<br>matrix =[<br>[1,2,3],<br>[4,0,6],<br>[7,5,8] ]<br><br>输出：<br>YES<br><br>                                                                                                                                                   | 使用 BFS 搜索状态空间，结合哈希表记录已访问状态避免重复。                                                                                 |
| 789<br>*<br>(h)            | 迷宫 III [[The Maze III]]                            | 给定一个迷宫和小球的起点，找到小球到达终点的最短路径。                                                             | 输入:  <br>maze = [ <br>[0,0,1],<br>[0,0,0],<br>[1,0,0]], <br>start = [0,0], <br>destination = <br>[2,2]  <br><br>输出: 4                                                                                                             | 使用 BFS 搜索所有可能路径，记录路径长度并选择最短路径。                                                                                  |
| 1828<br>*<br>(h)           | 湖面逃跑 [[Lake Escape]]                               | 给定一个湖泊网格，判断是否可以从起点逃到目标点，并返回最短路径。 踏进冰面，他会朝同一方向滑行，直到撞上另一个雪堆。 冰面上也有他必须避开的危险的洞。             | 输入:<br>size=7<br>[ <br>[0,0,0,0,0,0,0],<br>[0,0,-1,0,0,0,0],<br>[0,0,1,-1,0,-1,0],<br>[-1,0,1,0,0,0,0],<br>[0,1,1,0,0,1,0],<br>[-1,0,-1,0,-1,0,0],<br>[0,0,0,0,0,0,0] ]<br>size=7<br>start=[4,1]<br>end=[3,2]<br><br>输出: <br>true | 使用 BFS 遍历湖泊网格，记录每一步的状态和路径。                                                                                      |
| 120<br>**<br>(h)           | 单词接龙 [[Word Ladder]]                               | 给出两个单词（start和end）和一个字典，找出从start到end的最短转换序列，输出最短序列的长度。                                   | 输入：<br>start = "hit"<br>end = "cog"<br>dict =<br>[<br>"hot","dot",<br>"dog","lot",<br>"log"]<br><br>输出： 5                                                                                                                         | 使用 BFS 搜索单词转换序列，记录每个单词的访问深度。                                                                                    |
| 121<br>*<br>(h)<br>        | 单词接龙 II [[Word Ladder II]]                         | 给出两个单词（start和end）和一个字典，找出所有从start到end的最短转换序列。                                           | 输入：<br>start = "a"<br>end = "c"<br>dict =<br>["a","b","c"]<br><br>输出：<br>[ ["a","c"] ]                                                                                                                                            | 使用 BFS 搜索所有可能路径，结合回溯生成所有最短转换序列。                                                                                 |

### DFS(深度優先搜索)的題目

###### DFS
參考 [[DFS]]

輸入  [1,2,3]

Permutations: 排列
[ [1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1] ]

Subsets: 子集
[ [], [1], [1, 2],[1, 2, 3], [1, 3], [2], [2, 3], [3] ]

Combinations: 組合
[ [1,2], [2,3], [1,3] ]

| **题目编号**                        | **题目名称 (英文/中文)**                                               | **题目简述 (中文)**                      | **样例**                                                                                                                                                                                  | **解法**                                 |
| ------------------------------- | -------------------------------------------------------------- | ---------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------- |
| 15<br>**<br>(m)<br><br>PR<br>46 | 全排列 <br>[[Permutations]]                                       | 给定一个没有重复数字的数组，返回所有可能的排列。           | 输入：<br>[1,2,3]<br><br>输出：[<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1] ]                                                                         | 使用 DFS 和回溯生成所有排列组合。                    |
| 816<br>*<br>(h)                 | 旅行商问题 <br>[[Traveling Salesman Problem]]<br>                   | 给定城市的距离矩阵，找到访问所有城市的最短路径并返回起点。      | 输入:<br>n = 3<br>tuple = [<br>[1,2,1],<br>[2,3,2],<br>[1,3,3]]<br><br>输出: 3                                                                                                              | 使用 DFS + 剪枝搜索所有路径，记录最小路径和。             |
| 17<br>**<br>(m)<br><br>PR       | 子集 <br>[[Subsets]]                                             | 给定一个没有重复元素的数组，返回所有可能的子集。           | 輸入<br>[1,2,3]<br><br>輸出<br>[ [], [1], [1, 2],<br> [1, 2, 3], [1, 3], <br>[2], [2, 3], [3] ]                                                                                             | 使用 DFS 生成所有可能的组合，逐步扩展路径。               |
| 18<br>*<br>(m)                  | 子集II <br>[[SubsetsII]]                                         | 给定一个可能包含重复元素的数组，返回所有可能的子集，且子集不能重复。 | 输入：<br>nums = [1,2,2] <br><br>输出：[ <br>  [2], [1], [1,2,2], <br>  [2,2], [1,2],[] ]                                                                                                     | 对数组排序后使用 DFS，跳过重复元素生成子集。               |
| 152<br><br>(m)                  | [[Combinations]]组合                                             | 找到从 n 个数字中选择 k 个数字的所有组合。           | 输入:  <br>n = 4  ([1,2,3,4])<br>k = 2 <br> <br>输出:  <br>[ [2,4],[3,4],[2,3],<br>[1,2],[1,3],[1,4] ]                                                                                      | 使用回溯法和哈希表记录每次选择的数字。                    |
| 153<br><br>(m)<br>              | [[Combination Sum II]]组合II                                     | 找到数组中和等于目标值的所有不重复组合。               | 输入:  <br>candidates = <br>[10,1,2,7,6,1,5]  <br>target = 8  <br><br>输出:  <br>[ [1,1,6],[1,2,5]<br>,[1,7],[2,6] ]                                                                        | 使用回溯法结合哈希表记录已访问的数字避免重复。                |
| 427<br>*<br>(m)                 | 生成括号 <br>[[Generate Parentheses]]<br>                          | 给定一个正整数 n，生成所有合法的括号组合。             | 输入: 2<br><br>输出: <br>["()()", <br>"(())"]                                                                                                                                               | 使用 DFS 和回溯生成合法括号组合，动态维护左右括号数量。(似全排列問題) |
| 582<br>*<br>(h)                 | 单词拆分II <br>[[Word BreakII]]                                    | 给定一个字符串和一个单词字典，返回该字符串的所有可能分割方案。    | 输入：<br>"lintcode"，<br>["de","ding",<br>"co","code",<br>"lint"]<br><br>输出：<br>["lint code", <br>"lint co de"]                                                                            | 使用 DFS 搜索分割点，结合回溯生成所有可能方案。             |
| 132<br>*<br>(h)                 | 单词搜索 II [[Word Search II]]                                     | 给定一个二维字符网格和单词字典，找出所有字典中的单词在网格中的位置。 | 输入:  <br>board = [<br>["o","a","b","n"],<br>["e","t","a","e"],<br>["i","h","k","r"],<br>["i","f","l","v"]], <br>words = <br>["oath","pea",<br>"eat","rain"]  <br><br>输出: ["oath","eat"] | 使用字典树存储单词，结合DFS遍历网格查找。                 |
| 1848<br>*<br>(h)                | 单词搜索 III [[Word Search III]]                                   | 给定一个单词列表和一个二维字符网格，找出所有单词在网格中的位置。   | 输入:  <br>board = [<br>["o","a","b","n"],<br>["e","t","a","e"],<br>["i","h","k","r"],<br>["i","f","l","v"]], <br>words = <br>["oath","pea",<br>"eat","rain"]  <br><br>输出: ["oath","eat"] | 使用字典树构建单词索引，结合DFS遍历网格查找所有单词。           |
| 1909<br>*<br>(m)                | 订单分配 <br>[[Order Allocation]]                                  | 给定一个数组，返回所有可能的排列组合，支持重复数字。         | 输入：[<br>[1,2,4],<br>[7,11,16],<br>[37,29,22] ]<br><br>输出：<br>[1,2,0]                                                                                                                    | 使用 DFS 和回溯生成所有排列，跳过重复组合。               |
| 1360<br>*<br>(m)                | 对称树 <br>[[Symmetric Tree]] <br>                                | 判断一棵二叉树是否为对称树。                     | 输入: <br>{1,2,2,3,4,4,3}<br><br>输出: true                                                                                                                                                 | 使用 DFS 递归比较左右子树是否对称，检查值和结构是否一致。        |
| 1271<br>*<br>(h)                | 查找集群内的<br>「关键连接」 <br>[[Critical Connections in a Network]]<br> | 找到网络中所有的关键连接，删除这些连接会导致网络分裂。        | 輸入: 4<br>[ [0,1],[1,2],<br>[2,0],[1,3] ]<br><br>輸出<br>[ [1,3] ]                                                                                                                         | 使用 Tarjan 算法实现 DFS，记录时间戳和低链接值，找出桥边。    |
| 802<br>*<br>(h)                 | 数独 <br>[[Sudoku Solver]]<br>                                   | 求解一个数独问题，返回其唯一解。                   |                                                                                                                                                                                         | 使用 DFS 尝试填充每个空格，验证数独规则，找到唯一解法。         |



# **<mark style="background: #FF5582A6;">栈（Stack）</mark>的详细介绍**

###### 棧

| 题目编号                | 题目名称（英文）                                  | 题目简述（中文）                                          | 样例                                                                                                                                         | 解法                                                                                   |
| ------------------- | ----------------------------------------- | ------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------ |
| 12<br>*<br>(m)      | [[Min Stack]]带最小值操作的栈                     | 设计一个支持常数时间内获取最小值的栈，支持 `push`、`pop` 和 `getMin` 操作。 | 输入:  <br>stack.push(-2)  <br>stack.push(0)  <br>stack.push(-3)  <br>stack.getMin() <br> <br>输出: -3                                         | 使用两个栈，一个存储元素，一个存储最小值，更新最小值时同步操作。                                                     |
| 859<br>*<br>(h)<br> | 最大栈 [[Max Stack]]                         | 设计一个支持 `push`、`pop` 和 `getMax` 操作的栈，能够返回栈中最大值。    | 输入:  <br>push(5), <br>push(1), <br>push(5), <br>getMax(), <br>pop(), <br>getMax()  <br><br>输出: <br>[5, 5]                                  | 使用两个栈，一个存储元素，另一个维护当前最大值，确保 `getMax` 操作的高效性。                                          |
| 423<br>*<br>(e)<br> | [[Valid Parentheses]] 有效的括号               | 给定一个只包含 ()、{} 和 [] 的字符串，判断字符串中的括号是否匹配             | 输入:  <br>({[()]}) <br><br>输出: True                                                                                                         | 使用 栈 逐个遍历字符串中的字符。遇到左括号时，将其压入栈中；遇到右括号时，检查栈顶是否为匹配的左括号，                                 |
| 575<br><br>(m)      | [[Decode String]]字符串解码                    | 给定一个编码字符串，解码并返回原字符串。                              | 输入:  <br>s = <br>"3[a]2[bc]" <br> <br>输出: <br>"aaabcbc"                                                                                    | 使用栈存储当前字符和数字，遇到 `]` 时解码子字符串。                                                         |
| 978<br>*<br>(m)     | 基础计算器 [[Basic Calculator]]                | 实现一个简单的计算器，支持加减法和括号。                              | 输入:  <br>"(1+(4+5+2)-3)<br>+(6+8)" <br> <br>输出: 23                                                                                         | 使用栈存储运算符和操作数，遇到括号时计算其内部表达式的值。                                                        |
| 980<br>**<br>(m)    | 基础计算器II [[Basic CalculatorII]]            | 实现一个基础计算器来计算一个简单表达式字符串。                           | 输入: <br>"3+2*2" <br><br>输出: 7                                                                                                              | 我们可以用一个栈，保存这些（进行乘除运算后的）整数的值。对于加减号后的数字，将其直接压入栈中；对于乘除号后的数字，可以直接与栈顶元素计算，并替换栈顶元素为计算后的结果。 |
| 849<br><br>(h)<br>  | 基础计算器III [[Basic Calculator III]]         | 实现一个支持加减乘除和括号的高级计算器。                              | 输入:  <br>"2*(5+5*2)/3+<br>(6/2+8)"  <br><br>输出: 21                                                                                         | 使用栈处理括号和优先级，先解析出括号内表达式，再计算最终结果。                                                      |
| 368<br>*<br>(h)     | 表达式求值 [[Expression Evaluation]]           | 给一个用字符串表示的表达式数组，求出这个表达式的值。                        |                                                                                                                                            | 使用递归的方法，先处理 +-<br>再处理 */最后再处理括号。                                                     |
| 367<br>*<br>(h)     | 表达树构造 [[Expression Tree Build]]           | 从后缀表达式构造表达式树，支持加减乘除。                              | 输入:  <br>postfix = <br>["2", "3", "+",<br> "4", "*"] <br> <br>输出: 表达式树                                                                     | 使用栈存储中间节点，遇到运算符时弹出栈顶的两个节点构建子树并压栈。                                                    |
| 1908<br>*<br>(h)    | 布尔表达式求值 [[Boolean Expression Evaluation]] | 计算布尔表达式的结果，支持 `AND`、`OR` 和 `NOT` 运算。              | 输入:  <br>expression = <br>"true AND false OR true" <br> <br>输出: true                                                                       | 使用栈解析表达式，依次处理运算符和操作数，并按优先级进行布尔运算。                                                    |
| 510<br>*<br>(h)     | 最大矩形 [[Maximal Rectangle]]                | 给定一个二维二进制矩阵，找出其中包含最多1的矩形面积。                       | 输入:  <br>matrix = [<br>["1","0","1","0","0"],<br>["1","0","1","1","1"],<br>["1","1","1","1","1"],<br>["1","0","0","1","0"]]  <br><br>输出: 6 | 将每行看作直方图高度数组，逐行调用 `Largest Rectangle in Histogram` 解法。                               |
| 126<br>*<br>(h)     | 最大树 [[Max Tree]]                          | 给定一个数组，构造一棵最大二叉树，规则是父节点大于其子节点且树的根节点为数组中最大值。       | 输入:  <br>nums = <br>[3,2,1,6,0,5]  <br><br>输出: 最大树                                                                                         | 使用单调栈构建树，维护每个节点的左右子树，遇到较大值时构造父节点并更新子树。                                               |
| 1860<br>*<br>(h)    | 0子矩阵的数量 [[The Number of 0-submatrix]]     | 计算矩阵中包含全0的子矩阵数量。                                  | 输入:  <br>matrix = [<br>[0,0,1],<br>[0,0,0],<br>[1,0,0]] <br> <br>输出: 9                                                                     | 使用栈按列计算每一行的直方图高度，调用 `Largest Rectangle in Histogram` 解法统计。                           |
| 86<br><br>(h)<br>   | [[Binary Search Tree Iterator]]二叉查找树迭代器   | 实现二叉搜索树的迭代器，支持按升序遍历树中节点值的 `next` 操作。              | 输入:  <br>root = <br>[7,3,15,null,<br>null,9,20] <br> <br>输出: 3                                                                             | 使用栈记录路径，每次访问栈顶元素的右子树。                                                                |


# **<mark style="background: #ADCCFFA6;">单调栈（Monotonic Stack）</mark>的详细介绍**

###### 單調棧

| 题目编号                 | 题目名称（英文）                                               | 题目简述（中文）                                                     | 样例                                                                                                                       | 解法                                                               |
| -------------------- | ------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------- |
| 1206<br><br>(e)<br>  | [[Next Greater Element I]]<br>下一个更大元素 I                | 给定两个数组 `nums1` 和 `nums2`，找出 `nums1` 中每个元素在 `nums2` 中的下一个更大元素 | 输入:  <br>nums1 = [4,1,2]<br>nums2 = [1,3,4,2]<br><br>输出: [-1,3,-1]                                                       | 使用 单调递减栈 来找到 nums2 中每个元素的下一个更大值, 使用 哈希表记录每个元素的下一个更大值，方便在nums1中查找 |
| 1201<br><br>(m)      | [[Next Greater Element II]]下一个更大的数 II                  | 给定一个循环数组，返回每个元素的下一个更大元素。                                     | 输入:  <br>nums = [1,2,1]  <br><br>输出: [2,-1,2]                                                                            | 使用单调栈处理数组的循环访问，维护索引映射。                                           |
| 1060<br><br>(m)      | [[Daily Temperatures]] 每日温度                            | 给定一个温度数组，返回每一天之后多少天会出现更高的温度。                                 | 输入<br>temperatures = <br>[73, 74, 75, 71, <br>69, 72, 76, 73]<br><br>输出<br>[1, 1, 4, 2, <br>1, 1, 0, 0]                  | 使用 单调栈，栈中保存温度的索引，保持递减顺序。遍历温度数组时，若当前温度高于栈顶元素对应的温度，计算间隔天数。         |
| 122<br>*<br>(h)      | [[Largest Rectangle in Histogram]]<br>直方图中最大的矩形面积      | 给定一个直方图，求直方图中最大的矩形面积                                         | 输入:  <br>height = <br>[2,1,5,6,2,3]<br><br>输出: 10                                                                        | 使用单调递增栈维护柱子的索引,每次遇到高度较低的柱子时，弹出栈顶柱子，计算以该柱子为高度的最大矩形面积              |
| 363<br>**<br>(m)     | [[Trapping Rain Water]]接雨水                             | 计算柱状图中能够存储的雨水总量。                                             | 输入:  <br>height = <br>[0,1,0,2,<br>1,0,1,3,  <br>2,1,2,1] <br> <br>输出:  <br>6                                            | 使用双指针和单调栈记录左右最大高度，计算每个位置的雨水。                                     |
| 364<br>*<br>(h)      | [[Trapping Rain Water II]]接雨水II                        | 计算二维地形能够存储的雨水总量。                                             | 输入:<br>heightMap = <br>[ [1,4,3,1,3,2],<br>[3,2,1,3,2,4],<br>[2,3,3,2,3,1] ]<br><br>输出:<br>4<br>                         | 使用最小堆模拟单调栈，动态更新边界最低高度。                                           |
| 1297<br><br>(h)<br>  | [[Count of Smaller Numbers After Self]]比自己小的元素个数       | 给定一个整数数组，返回一个新数组，新数组中第 i 个元素是 nums[i] 右侧小于 nums[i] 的元素个数。    | 输入:  <br>nums = <br>[5,2,6,1]  <br><br>输出:  <br>[2,1,1,0]                                                                | 使用单调栈维护每个元素右侧的较小值统计。                                             |
| 1274<br><br>(m)<br>  | [[Find K Pairs with Smallest Sum]]查找和最小的K对数字           | 找到两个已排序数组中和最小的 k 对数对。                                        | 输入:  <br>nums1 = [1,7,11]  <br>nums2 = [2,4,6]  <br>k = 3  <br><br>输出:  [<br>[1,2],<br>[1,4],<br>[1,6]]                  | 使用最小堆或单调栈动态生成数对并维护大小。                                            |
| 564<br><br>(m)<br>   | [[Combination Sum IV]]组合总和 IV                          | 给定一个正整数数组，计算能够组成目标值的所有组合数目。                                  | 输入:  <br>nums = [1,2,3]  <br>target = 4  <br><br>输出:  <br>7                                                              | 使用动态规划和单调栈统计每种和的组合数。                                             |
| 1272<br><br>(m)<br>  | [[Kth Smallest Element in a Sorted Matrix]]有序矩阵中的第K小元素 | 在一个行列均递增的矩阵中找到第 k 小的元素。                                      | 输入:  <br>matrix = <br>[ [1,5,9],<br> [10,11,13],<br> [12,13,15] ]  <br>k = 8  <br><br>输出:  <br>13                        | 使用最小堆或单调栈动态维护当前最小值。                                              |
| 3659<br><br>(e)<br>  | [[Design Phone Directory]]电话目录管理系统                     | 设计一个电话目录，支持分配、回收电话号码和检查号码是否可用。                               | 输入:  <br>["PhoneDirectory",<br>"get","check",<br>"release"],<br>[ [3],[],[2],[] ]  <br><br>输出:  <br>[ null,0,true,null ] | 使用单调栈模拟分配和回收过程。                                                  |
| 1852<br>*<br>(m)<br> | [[Final Discounted Price]]最终优惠价                        | 给定一个商品价格列表，计算每个商品的最终价格，最终价格为原价减去右侧第一个小于等于当前商品价格的值，如果没有则保留原价。 | 输入: <br>prices = <br>[8, 4, 6, 2, 3]  <br><br>输出: <br>[4, 2, 4, 2, 3]                                                    | 使用单调递增栈，记录索引以查找右侧第一个符合条件的价格。                                     |
| 285<br>*<br>(m)<br>  | [[Tall Building]]高楼大厦                                  | 给定每栋建筑物的高度数组，计算每栋建筑物能看到右侧至少一栋更高建筑物的最远距离。                     | 输入: <br>heights = <br>[5, 3, 8, 3, 2]  <br><br>输出: <br>[2, 1, 0, 0, 0]                                                   | 使用单调递减栈，记录右侧第一个比当前建筑高的索引。                                        |
| 1740<br>*<br>(m)<br> | [[Online Stock Span]]股票价格跨度                            | 给定一个股票价格流，计算每一天股票价格不小于今天价格的连续天数。                             | 输入: <br>prices = <br>[100, 80, 60, <br>70, 60, 75, 85]  <br><br>输出: <br>[1, 1, 1, <br>2, 1, 4, 6]                        | 使用单调递减栈，存储价格和天数以计算跨度。                                            |
| 346<br>*<br>(h)<br>  | [[xorsum of Interval extremum]]区间极值异或                  | 给定一个数组，计算所有子区间的最小值与最大值的异或和。                                  | 输入: <br>nums = <br>[3, 1, 2, 4]  <br><br>输出: 11                                                                          | 使用单调栈分别找到每个元素作为最小值和最大值时的贡献，计算结果的异或和。                             |
| 1778<br>*<br>(h)     | 奇偶跳 [[Odd Even Jump]]                                  | 给定一个数组，判断从数组每个位置出发的奇偶跳能否跳到数组末尾，返回能到达的起始位置数量。                 | 输入:  <br>arr = <br>[10,13,12,14,15]  <br><br>输出: 2                                                                       | 使用单调栈分别计算奇跳和偶跳的下一个位置，动态规划记录能到达末尾的位置。                             |
| 347<br>*<br>(h)      | 最大值期望 [[Maximum Number Expectation]]                   | 给定一个数组和一个窗口大小，找到窗口内的最大值并计算期望值。                               | 输入:  <br>nums = <br>[1,3,-1,-3,<br>5,3,6,7]<br>k = 3  <br><br>输出: <br>[3,3,5,5,6,7]                                      | 使用单调递减栈计算每个窗口的最大值，求平均作为期望值。                                      |



# **<mark style="background: #FF5582A6;">哈希表（Hash Map）</mark>的详细介绍**

###### 哈希表

| 题目编号               | 题目名称（英文）                                                 | 题目简述（中文）                             | 样例                                                                                                                                                 | 解法                                    |
| ------------------ | -------------------------------------------------------- | ------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------- |
| 124<br>*<br>(m)    | [[Longest Consecutive Sequence]]最长连续序列                   | 给定一个未排序的整数数组，找出最长连续序列的长度。            | 输入:  <br>nums = <br>[100,4,200,1,3,2]  <br><br>输出:  <br>4 (1,2,3,4)                                                                                | 使用哈希表记录数组中的数字，动态扩展连续序列的长度。            |
| 140<br><br>(m)!!!  | [[Fast Power]]快速幂                                        | 计算 `a^n % b`。                        | 输入:  <br>a = 2  <br>b = 3  <br>n = 5  <br><br>输出:  <br>2   <br>(a^n %b = <br>2^5 %3 =<br>32%3 =2)                                                  | 使用快速幂和哈希表记录中间结果。                      |
| 141<br><br>(e)     | [[Sqrt(x)]]对x开根                                          | 计算并返回非负整数 xxx 的平方根（只保留整数部分）。         | 输入: 8 <br><br>输出: 2 <br>(sqrt(8)=<br>2.828)                                                                                                        | 使用牛頓法确定平方根的整数部分。(f(x)=x^2-C=0)        |
| 142<br><br>(e)     | [[O(1) Check Power of 2]]   O(1)时间检测2的幂次                 | 判断一个整数是否是 2 的幂次。                     | 输入:  <br>n = 8  <br><br>输出:  <br>true                                                                                                              | 使用哈希表记录所有 2 的幂次进行查找。                  |
| 154<br>*<br>(h)!!! | [[Regular Expression Matching]]正则表达式匹配                   | 实现一个支持 `.` 和 `*` 的正则表达式匹配器。          | 输入:  <br>s = "aa"  <br>p = "a*" <br> <br>输出:  <br>true                                                                                             | 使用动态规划和哈希表记录子问题状态。                    |
| 685<br>*<br>(m)    | 数据流中第一个唯一的数字[[First Unique Number in Data Stream]]       | 设计一个数据结构支持数据流中的第一个唯一数字的查询和插入。        | 输入:  <br>add(2), <br>add(3), <br>add(5), <br>showFirstUnique() <br> <br>输出: 2                                                                      | 使用哈希表记录数字出现次数，并维护一个队列按顺序存储候选唯一数字。     |
| 960<br>*<br>(m)    | 数据流中第一个独特的数 II [[First Unique Number in Data Stream II]] | 设计一个数据结构支持高效查询数据流中第一个独特数字，并允许删除任意数字。 | 输入:  <br>add(2), <br>add(2), <br>add(3), <br>remove(2), <br>showFirstUnique()  <br><br>输出: 3                                                       | 哈希表记录每个数字的状态（唯一或重复），结合链表维护唯一数字的顺序。    |
| 657<br>*<br>(m)    | O(1)实现数组插入/删除/随机访问 [[Insert Delete GetRandom O(1)]]      | 设计一个数据结构支持O(1)时间的插入、删除和随机访问操作。       | 输入:  <br>insert(1), <br>remove(1), <br>getRandom()  <br><br>输出: 1                                                                                  | 使用数组存储元素，哈希表记录元素索引，实现插入和删除的快速访问。      |
| 613<br>*<br>(m)    | 优秀成绩 [[High Five]]                                       | 给定一个学生成绩的记录，返回每个学生的前五门成绩的平均值。        | 输入:  <br>records = [ <br>[1,91],[1,92],[2,93],<br>[2,99],[1,60],[2,77],<br>[1,65],[1,87],[1,100],<br>[2,100],[2,76] ]  <br><br>输出: [[1,87],[2,88]] | 使用哈希表记录学生ID及其所有成绩，排序后取前五个成绩计算平均值。     |
| 128<br>**<br>(m)   | 哈希函数 [[Hash Function]]                                   | 设计一个简单的哈希函数，将字符串映射到指定大小的哈希表。         | 输入:  <br>key = "hello"<br>HASH_SIZE = 10 <br> <br>输出: 2                                                                                            | 使用字符串的ASCII值结合哈希表大小进行取模运算。            |
| 129<br>**<br>(m)   | 重哈希 [[Rehashing]]                                        | 给定一个哈希表和一个新的大小，对其进行重新哈希，使得数据分布更加均匀。  | 输入:  <br>hash_table = <br>[null,21,null,<br>null,14,null] <br> <br>输出: <br>[null,null,null,<br>null,14,21]                                         | 遍历原哈希表，将非空元素根据新大小重新计算哈希值并插入新哈希表。      |
| 1280<br>*<br>(h)   | 将数据流变为多个不相交区间 [[Data Stream as Disjoint Intervals]]      | 给定一个整数流，实现一个数据结构支持动态维护不相交区间。         | 输入:  <br>addNum(1)<br>addNum(3)<br>getIntervals()<br>  <br>输出: [<br>[1, 1], [3, 3]]                                                                | 使用有序字典记录区间的起始和结束，插入时动态合并重叠区间。         |
| 547<br>**<br>(e)   | 两数组的交集 [[Intersection of Two Arrays]]                    | 给定两个数组，返回它们的交集，结果中不包含重复元素。           | 输入:  <br>nums1 = <br>[1,2,2,1]<br>nums2 = [2,2] <br> <br>输出: [2]                                                                                   | 使用哈希表记录第一个数组的元素，遍历第二个数组时检查是否存在于哈希表中。  |
| 548<br>*<br>(e)    | 两数组的交集 II [[Intersection of Two Arrays II]]              | 给定两个数组，返回它们的交集，结果中可以包含重复元素。          | 输入:  <br>nums1 = [1,2,2,1]<br>nums2 = [2,2]  <br><br>输出: [2,2]                                                                                     | 使用哈希表记录第一个数组中每个元素的次数，遍历第二个数组时按次数匹配交集。 |
| 793<br>*<br>(e)    | 多个数组的交集 [[Intersection of Arrays]]                       | 给定多个数组，返回它们的交集。                      | 输入:  <br>nums = [ <br>[1,2,2,1], <br>[2,2,3],[2,2,4]] <br> <br>输出: [2]                                                                             | 使用哈希表记录每个元素在所有数组中的出现次数，检查次数是否等于数组总数。  |



# **<mark style="background: #ADCCFFA6;">并查集（Union-Find）</mark>的详细介绍**

###### 併查集

| 题目编号                | 题目名称（英文）                                                                | 题目简述（中文）                           | 样例                                                                                                                                                                                            | 解法                                 |
| ------------------- | ----------------------------------------------------------------------- | ---------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------- |
| 432<br><br>(m)      | [[Find the Weak Connected Component in the Directed Graph]]找出有向图中的弱连通分量 | 找到有向图中所有的弱连通分量。                    | 输入:  <br>nodes = <br>[ [1,2],[2,3],[4,5] ]  <br><br>输出:  <br>[ [1,2,3],[4,5] ]                                                                                                                | 使用并查集维护节点的连通性，合并有边的节点。             |
| 629<br>*<br>(h)     | [[Minimum Spanning Tree]]最小生成树                                          | 在加权无向图中找到最小生成树。                    | 输入:  <br>edges = [ <br>[1,2,1],<br>[2,3,2],<br>[1,3,2] ]  <br><br>输出:  <br>3                                                                                                                  | 使用并查集和 Kruskal 算法找到最小生成树。          |
| 3672<br><br>(m)<br> | [[Connecting Cities With Minimum Cost]]最低成本联通所有城市                       | 使用最小成本连接所有城市。                      | 输入:<br>n = 3<br>connections = <br>[ [1,2,5],<br>[1,3,6],<br>[2,3,1] ]<br><br>输出: 6                                                                                                            | 使用并查集结合 Kruskal 算法计算最小生成树成本。       |
| 178<br>**<br>(m)    | 图是否是树 [[Graph Valid Tree]]                                              | 判断一个无向图是否是一棵树。                     | 输入: <br>n = 5 <br>edges = [<br>[0, 1], [0, 2], <br>[0, 3], [1, 4]]<br><br>输出: true                                                                                                            | 使用并查集判断图是否连通且无环。                   |
| 444<br>*<br>(m)     | 图是否是树 II [[Graph Valid Tree II]]                                        | 判断一个加权图是否是一棵树。                     | 输入:<br>addEdge(1, 2)<br>isValidTree()<br>addEdge(1, 3)<br>isValidTree()<br>addEdge(1, 5)<br>isValidTree()<br>addEdge(3, 5)<br>isValidTree()<br><br>输出: <br>["true","true",<br>"true","false"] | 使用并查集结合最小生成树算法（Kruskal）检查连通性和边的数量。 |
| 589<br>*<br>(m)     | 连接图 [[Connecting Graph]]                                                | 判断图中两个节点是否连通，并支持动态合并节点。            | 输入:<br>ConnectingGraph(5)<br>query(1, 2)<br>connect(1, 2)<br>query(1, 3) <br>connect(2, 4)<br>query(1, 4) <br><br>输出:<br>[false,false,true]                                                   | 使用并查集维护节点连通关系，查询时检查根节点是否相同。        |
| 590<br>*<br>(m)     | 连接图II [[Connecting Graph II]]                                           | 在图的基础上增加边权，并支持动态合并和连通性查询。          | 输入:<br>ConnectingGraph2(5)<br>query(1)<br>connect(1, 2)<br>query(1)<br>connect(2, 4)<br>query(1)<br>connect(1, 4)<br>query(1)<br><br>输出:<br>[1,2,3,3]                                         | 并查集基础上记录每个集合的边权和，查询时检查连通性并计算边权和。   |
| 591<br>*<br>(m)     | 连接图III [[Connecting Graph III]]                                         | 支持动态删除和添加边，并判断图的连通性。               | 输入:<br>ConnectingGraph3(5)<br>query()<br>connect(1, 2)<br>query()<br>connect(2, 4)<br>query()<br>connect(1, 4)<br>query()<br><br>输出:[5,4,3,3]                                                 | 使用启发式合并和路径压缩的并查集动态维护连通关系。          |
| 684<br><br>(e)<br>  | [[Redundant Connection]]缺少的字符串                                          | 在图中找到冗余的边，使得移除这条边后图仍然是连通树。         | 输入 : <br>str1 = <br>"This is an example"<br>str2 = <br>"is example"<br><br>输出 : <br>["This", "an"]                                                                                            | 使用并查集判断新边是否会形成环，若形成则为冗余边。          |
| 1087<br>*<br>(h)    | [[Redundant Connection II]]缺少的字符串II                                     | 在图中找到一条冗余的边，使得移除这条边后图仍然是连通的有向树。    | 输入:<br>edges = <br>[ [1,2],[1,3],<br>[2,3] ]<br><br>输出:<br>[2,3]                                                                                                                              | 使用并查集和入度检查判断冗余边。                   |
| 1070<br>*<br>(m)    | [[Accounts Merge]]账户合并                                                  | 合并具有相同邮件地址的账户。                     |                                                                                                                                                                                               | 使用并查集将邮箱地址合并为一个集合。                 |
| 855<br><br>(m)      | [[Sentence Similarity II]]句子相似性II                                       | 判断两个句子是否相似，每对相似单词通过列表给出。           | 输入:<br>[ "great","acting"<br>,"skills" ]<br>[ "fine","drama",<br>"talent" ]<br><br>输出:<br>true                                                                                                | 使用并查集合并相似单词，判断对应位置单词是否属于同一集合。      |
| 1043<br><br>(h)<br> | [[Couples Holding Hands]]夫妻手牵手                                          | 计算最少的交换次数，使得情侣在一起。                 | 输入:  <br>row = [0,2,1,3]  <br><br>输出:  <br>1 ([0,1,2,3])                                                                                                                                      | 使用并查集维护每对情侣的关系，合并需要交换的座位。          |
| 1718<br><br>(h)<br> | [[Minimize Malware Spread]]尽量减少恶意软件的传播                                  | 移除一个节点，尽量减少恶意软件的传播范围。              | 输入:<br>graph = <br>[ [1,1,0]<br>,[1,1,0],<br>[0,0,1] ]<br>initial = <br>[ 0,1 ]<br><br>输出:<br>0                                                                                               | 使用并查集统计每个连通分量的大小和恶意节点的分布情况。        |
| 3670<br><br>(m)<br> | [[The Earliest Moment When Everyone Become Friends]]彼此认识的最早时间           | 找到所有人成为朋友的最早时间。                    | 输入:<br>logs = <br>[ 20190101,0,1],<br>[20190104,3,4],<br>[20190107,2,3],<br>[20190109,1,2],<br>[20190110,1,3],<br>[20190113,4,5] ]<br><br>输出:<br>20190109                                     | 使用并查集动态合并好友关系，记录合并时间。              |
| 1014<br>*<br>(h)    | 打砖块 [[Bricks Falling When Hit]]                                         | 给定一个二维砖块网格和一系列敲砖操作，计算每次操作后剩余的砖块数量。 | 输入: <br>grid = [<br>[1,0,0,0],<br>[1,1,1,0]], <br>hits = [ [1,0] ]<br><br>输出: [2]<br>                                                                                                         | 逆序执行敲砖操作，使用并查集维护砖块连通性，动态更新剩余数量。    |
| 805<br>*<br>(m)     | 最大关联集合 [[Maximum Association Set]]                                      | 找到多个字符串集合中关联度最大的集合。                | 输入:  <br>ListA = <br>["abc","abc","abc"], <br>ListB = <br>["bcd","acd","def"]<br><br>输出:  <br>["abc","acd","bcd","def"]<br>                                                                   | 使用并查集合并关联集合，找到最大集合并返回。             |
| 1463<br>*<br>(m)    | 论文查重 [[Paper Review]]                                                   | 检查论文引用网络中是否存在循环引用。                 |                                                                                                                                                                                               | 使用并查集判断是否存在环路结构。                   |
| 1179<br>*<br>(m)    | 朋友圈 [[Friend Circle]]                                                   | 计算社交网络中的朋友圈数量。                     | 输入：<br>[ [1,1,0],<br>[1,1,0],<br>[0,0,1] ]<br><br>输出：2<br>                                                                                                                                    | 使用并查集合并相互认识的好友，最终统计独立朋友圈的数量。       |
| 1396<br>*<br>(m)    | 集合合并 [[Set Union]]                                                      | 支持集合的动态合并和查询操作。                    | 输入：<br>list = [<br>[1,2,3],<br>[3,9,7],<br>[4,5,10] ]<br><br>输出：2                                                                                                                             | 使用路径压缩优化并查集，实现高效的集合操作。             |
| 1628<br><br>(m)<br> | 开车问题 [[Driving Problem]]                                                | 判断多个城市之间的道路是否连通。                   | 输入:  <br>roads = [<br>[1,2],[2,3],[4,5]]<br>queries = [<br>[1,3],[2,4]]  <br><br>输出: [true, false]                                                                                            | 使用并查集动态维护城市连通性，查询时判断两个城市是否属于同一集合。  |
| 1430<br><br>(h)<br> | 相似字符串组 [[Similar String Groups]]                                        | 给定一组字符串，计算相似字符串的组数。                | 输入:  <br>strings = <br>["tars","rats",<br>"arts","star"] <br> <br>输出: 2                                                                                                                       | 使用并查集将相似的字符串合并为一个组，统计独立组的数量。       |



# **<mark style="background: #ADCCFFA6;">迭代器（Iterator）</mark>的详细介绍**
###### 迭代器

| 题目编号               | 题目名称（英文）                                | 题目简述（中文）                        | 样例                                                                        | 解法                      |
| ------------------ | --------------------------------------- | ------------------------------- | ------------------------------------------------------------------------- | ----------------------- |
| 540<br><br>(m)<br> | [[Zigzag Iterator]]左旋右旋迭代器              | 给定两个列表，实现一个迭代器，以之字形顺序输出两个列表的元素。 | 输入:  <br>v1 = [1,2]  <br>v2 = [3,4,5,6]  <br><br>输出:  <br>[1,3,2,4,5,6]   | 使用队列存储非空列表的迭代器，按顺序依次访问。 |
| 528<br><br>(m)     | [[Flatten Nested List Iterator]]摊平嵌套的列表 | 将嵌套列表展开为一个扁平化的迭代器。              | 输入:  <br>nestedList = <br>[ [1,1],2,[1,1] ]  <br><br>输出:  <br>[1,1,2,1,1] | 使用栈存储嵌套列表，递归展开当前列表项。    |
| 601<br>*<br>(m)    | [[Flatten 2D Vector]]摊平二维向量             | 将二维数组展开为一个扁平化的迭代器。              | 输入:<br>vec2d = <br>[ [1,2],[3],[4,5,6] ]<br><br>输出:<br>[ 1,2,3,4,5,6 ]    | 使用索引记录当前行和列，动态访问元素。     |



# **<mark style="background: #FF5582A6;">二叉树（Binary Tree）</mark>的详细介绍**

###### 二叉树

| 题目编号                      | 题目名称（英文）                                                       | 题目简述（中文）                   | 样例                                                                                                 | 解法                                              |
| ------------------------- | -------------------------------------------------------------- | -------------------------- | -------------------------------------------------------------------------------------------------- | ----------------------------------------------- |
| 66<br><br>(e)             | [[Binary Tree Preorder Traversal]]二叉树的前序遍历                     | 返回二叉树的前序遍历结果。              | 输入:  <br>root = <br>[1,null,2,3]  <br><br>输出:  <br>[1,2,3]                                         | 使用递归或栈完成前序遍历操作。                                 |
| 67<br>*<br>(e)            | [[Binary Tree Inorder Traversal]]- 二叉树的中序遍历                    | 返回二叉树的中序遍历结果。              | 输入:  <br>root = <br>[1,null,2,3]  <br><br>输出:  <br>[1,3,2]                                         | 使用递归或栈完成中序遍历操作。                                 |
| 68<br><br>(e)<br>         | [[Binary Tree Postorder Traversal]]- 二叉树的后序遍历                  | 返回二叉树的后序遍历结果。              | 输入:  <br>root = <br>[1,null,2,3]  <br><br>输出:  <br>[3,2,1]                                         | 使用递归或栈完成后序遍历操作。                                 |
| 70<br>*<br>(m)<br>        | [[Binary Tree Level Order Traversal II]]二叉树的层次遍历 II            | 返回二叉树的层次遍历结果（从底层到顶层）。      | 输入:  <br>root = <br>[3,9,20,null,<br>null,15,7]  <br><br>输出:  [<br>[15,7],[9,20],[3]]              | 使用队列按层遍历节点，结果反转。                                |
| 480<br>**<br>(e)          | 二叉树的<br>所有路径 <br>[[Binary Tree Paths]] <br>                    | 找出二叉树中从根到叶子的所有路径。          | 输入：<br>{1,2}<br><br>输出：<br>["1->2"]                                                                | 使用 DFS 遍历所有路径，记录从根到叶子的每条路径。                     |
| 1469<br><br>(m)           | 树上最长路径 [[Longest Path On The Tree]]                            | 找出树中任意两个节点之间的最长路径长度。       | 输入:  <br>edges = [<br>[1,2],[2,3],<br>[2,4],[4,5]]  <br><br>输出: 3                                  | 使用两次 DFS：第一次找出最远节点，第二次从最远节点计算最长路径。              |
| 94<br>*<br>(m)            | [[Binary Tree Maximum Path Sum]]二叉树中的最大路径和                     | 计算二叉树中从任意节点到任意节点的路径的最大和。   | 输入:  <br>root = <br>[1,2,3]  <br><br>输出:  6                                                        | 使用递归计算每个节点的最大路径和，动态更新全局最大值。                     |
| 155<br><br>(e)            | [[Minimum Depth of Binary Tree]]二叉树的最小深度                       | 找到二叉树的最小深度。                | 输入:  <br>root = <br>[3,9,20,null,<br>null,15,7]  <br><br>输出:  2                                    | 使用哈希表记录节点的深度，动态更新最小深度。                          |
| 97<br>*<br>(e)            | [[Maximum Depth of Binary Tree]]二叉树的最大深度                       | 计算二叉树的最大深度。                | 输入:  <br>root = <br>[3,9,20,null,<br>null,15,7] <br> <br>输出:  3                                    | 使用递归计算每个节点的最大深度。                                |
| 175<br>*<br>(e)           | [[Invert Binary Tree]]翻转二叉树                                    | 翻转二叉树的左右子树。                | 输入:  <br>root = <br>[4,2,7,1,3,6,9]  <br><br>输出:  <br>[4,7,2,9,6,3,1]                              | 使用递归交换每个节点的左右子树。                                |
| 649<br><br>(m)            | [[Binary Tree Vertical Order Traversal]]<br>二叉树翻转              | 按垂直顺序遍历二叉树节点。              | 输入:<br>root = <br>[ 3,9,20,null,<br>null,15,7 ]<br><br>输出:<br>[ [9],[3,15],<br>[20],[7] ]]]        | 使用哈希表记录每列节点，按列编号排序输出。                           |
| 650<br><br>(m)            | [[Find Leaves of Binary Tree]]二叉树叶子顺序遍历                        | 找到二叉树中所有叶子节点并移除，返回结果。      | 输入:<br>root = <br>[ 1,2,3,4,5 ]<br><br>输出:<br>[ [4,5,3],<br>[2],[1] ]                              | 使用递归记录节点深度，将叶子节点按深度分组。                          |
| 651<br><br>(m)<br>        | [[Flatten 2D Vector II]]二叉树垂直遍历                                | 将二维数组展开为一个扁平化的迭代器（支持动态删除）。 | 输入:<br>vec2d = <br>[ [1,2],[3],<br>[4,5,6] ]<br><br>输出:<br>[ 1,2,3,4,5,6 ]                         | 使用索引和标记动态管理行列访问。                                |
| 614<br><br>(m)            | [[Binary Tree Longest Consecutive Sequence II]] 二叉树的最长连续子序列 II | 找到二叉树中的最长连续序列路径，可以从任意节点开始。 | 输入:  <br>root = <br>[1,2,3,4]  <br><br>输出:  3                                                      | 使用递归计算以当前节点为起点的最长递增和递减序列长度。                     |
| 632<br><br>(e)            | [[Binary Tree Maximum Node]]二叉树的最大节点                           | 找到二叉树中值最大的节点。              | 输入:  <br>root = [1,-5,3,1,2,null,4]  <br>输出:  <br>4                                                | 使用递归遍历树，动态更新最大值节点。                              |
| 7<br>*<br>(m)             | 二叉树的序列化和反序列化 [[Serialize and Deserialize Binary Tree]]         | 将二叉树转换为字符串并能够从字符串恢复二叉树。    | 输入:  <br>root = <br>[1,2,3,null,null,4,5]<br>  <br>输出: <br>"1,2,3,null,null,4,5"                   | 使用前序遍历序列化二叉树，空节点用标记符占位，反序列化时递归构建树。              |
| 864<br><br>(m)            | 相等树划分 [[Equal Tree Partition]]                                 | 判断是否能将二叉树分为两个和相等的部分。       | 输入:  <br>root = <br>[5,10,10,null,<br>null,2,3]  <br><br>输出: true                                  | 使用后序遍历计算子树和并记录所有子树和，判断是否存在一半总和的子树。              |
| 689<br>*<br>(m)           | [[Two Sum IV]] - Input is a BST两数之和 - BST版本                    | 在二叉搜索树中找到两个节点，使它们的和等于目标值。  | 输入:  <br>root = <br>[5,3,6,2,4,null,7]  <br>target = 9  <br><br>输出:  <br>true<br>O(n),O(n)         | 使用中序遍历获取节点值并查找目标值，或使用哈希表记录访问的节点值。               |
| 1240<br><br>(e)<br>!!<br> | [[Path Sum III]]路径总和III                                        | 找到二叉树中和为目标值的所有路径的数量。       | 输入: <br>root = <br>[10,5,-3,3,2,null,<br>11,3,-2,null,1]<br>sum = 8 <br><br>输出: 3<br><br>O(n),O(n) | 使用递归计算每个节点的路径和，利用前缀和的思想存储路径和的累计值，检查是否存在符合条件的路径。 |



# **<mark style="background: #BBFABBA6;">二叉搜索树（Binary Search Tree）</mark>的详细介绍**
###### 二叉搜索树

| 题目编号             | 题目名称（英文）                                                               | 题目简述（中文）                              | 最简单样例                                                                                                     | 解法                               |
| ---------------- | ---------------------------------------------------------------------- | ------------------------------------- | --------------------------------------------------------------------------------------------------------- | -------------------------------- |
| 87<br><br>(h)    | [[Remove Node in Binary Search Tree]]删除二叉查找树的节点                        | 删除二叉搜索树中的指定节点。                        | 输入:  <br>root = <br>[5,3,6,2,4,null,7]  <br>key = 3  <br><br>输出:  <br>[5,4,6,2,null,null,7]               | 找到目标节点，调整子树结构以保持二叉搜索树性质。         |
| 95<br>*<br>(m)   | [[Validate Binary Search Tree]]验证二叉查找树                                 | 验证一个二叉树是否为有效的二叉搜索树。                   | 输入:  <br>root = [2,1,3]  <br><br>输出:  <br>true                                                            | 使用递归检查节点值是否满足二叉搜索树的性质。           |
| 98<br><br>(m)    | [[Sort List]]链表排序                                                      | 将升序链表转换为高度平衡的二叉搜索树。                   | 输入:  <br>head = <br>[-10,-3,0,5,9]  <br><br>输出:  <br>[0,-3,9,-10,null,5]                                  | 使用快慢指针找到链表中点作为根节点，递归构造左右子树。      |
| 448<br><br>(m)   | [[Inorder Successor in BST]]二叉查找树的中序后继                                 | 找到二叉搜索树中指定节点的中序后继。                    | 输入:  <br>root = <br>[2,1,3]  <br>p = 1  <br><br>输出:  2                                                    | 使用递归或迭代寻找目标节点，并根据二叉搜索树性质找到后继节点。  |
| 900<br><br>(e)   | [[Closest Binary Search Tree Value]]二叉搜索树中最接近的值                        | 找到二叉搜索树中与目标值最接近的节点值。                  | 输入:  <br>root = <br>[4,2,5,1,3]  <br>target = <br>3.714286  <br><br>输出:  4                                | 使用递归或迭代遍历树节点，动态更新最接近的节点值。        |
| 901<br><br>(h)   | [[Closest Binary Search Tree Value II]]二叉搜索树中最接近的值 II                  | 找到二叉搜索树中与目标值最接近的 k 个节点值。              | 输入:  <br>root = [4,2,5,1,3]  <br>target = 3.714286  <br>k = 2  <br><br>输出:  <br>[4,3]                     | 使用中序遍历记录节点值，并用滑动窗口动态选择最近的 k 个值。  |
| 903<br><br>(m)   | [[Range Sum of BST]]范围加法                                               | 计算二叉搜索树中值在指定范围内的所有节点值的和。              | 输入:  <br>root = <br>[10,5,15,3,7,null,18]  <br>L = 7  <br>R = 15  <br><br>输出:  32                         | 使用递归只访问在范围内的子树节点，动态累加节点值。        |
| 701<br><br>(m)   | [[Trim a Binary Search Tree]]修剪二叉搜索树                                   | 修剪二叉搜索树，使得所有节点值在给定范围内。                | 输入:  <br>root = [1,0,2]  <br>L = 1  <br>R = 2  <br><br>输出:  <br>[1,null,2]                                | 使用递归修剪节点，不在范围内的子树替换为空。           |
| 661<br><br>(e)   | [[Binary Search Tree to Greater Sum Tree]]把二叉搜索树转化成更大的树                | 将二叉搜索树转换为一个新的树，每个节点值为原值加上所有大于它的节点值的和。 | 输入 : {5,2,13}<br><br>输出 : {18,20,13}<br><br>                                                              | 使用反向中序遍历动态更新节点值。                 |
| 1744<br>*<br>(e) | [[Increasing Order Search Tree]]递增顺序查找树                                | 将二叉搜索树转换为一个递增顺序的单链表。                  |                                                                                                           | 使用中序遍历重组树的结构，按递增顺序连接节点。          |
| 1359<br><br>(e)  | [[Convert Sorted Array to Binary Search Tree]]有序数组转换为二叉搜索树             | 将升序数组转换为高度平衡的二叉搜索树。                   | 输入:  <br>nums = [-10,-3,0,5,9]  <br><br>输出:  <br>[0,-3,9,-10,null,5]                                      | 使用递归分治将数组中间元素作为根节点，构造左右子树。       |
| 1746<br><br>(e)  | [[Minimum Distance Between BST Nodes]]二叉搜索树结点最小距离                      | 找到二叉搜索树中任意两个节点值之间的最小差值。               | 输入:  <br>root = <br>[4,2,6,1,3]  <br><br>输出:  1                                                           | 使用中序遍历动态记录上一个节点值和当前节点值的差值。       |
| 1593<br><br>(m)  | [[Construct Binary Search Tree from Preorder Traversal]]根据前序和后序遍历构造二叉树 | 从先序遍历的结果构造二叉搜索树。                      | 输入:  <br>preorder = <br>[8,5,1,7,10,12]  <br><br>输出:  <br>[8,5,10,1,7,null,12]                            | 使用递归或栈根据先序遍历构造二叉搜索树。             |
| 597<br>**<br>(e) | 具有最大平均数的子树 [[Subtree with Maximum Average]]                            | 找出二叉树中具有最大平均数的子树。                     | 输入:  <br>root = <br>[1,-5,11,1,2,4,-2]  <br><br>输出: [11,4,-2]                                             | 使用递归后序遍历计算子树的节点和和节点数，动态更新最大平均值。  |
| 596<br>*<br>(e)  | 最小子树 [[Minimum Subtree]]                                               | 找出二叉树中和最小的子树。                         | 输入:  <br>root = <br>[1,-5,2,1,2,3,-4]  <br><br>输出: [-5,1,2]                                               | 使用后序遍历计算子树的和，动态记录最小值及其根节点。       |
| 474<br>**<br>(e) | 最近公共祖先II [[Lowest Common AncestorII (LCA)]]                            | 找出二叉树中两个节点的最近公共祖先，节点可能不存在树中。          | 输入:  <br>root = <br>[3,5,1,6,2,0,8,<br>null,null,7,4]<br>p = 5<br>q = 4  <br><br>输出: 5                    | 递归检查左右子树是否包含目标节点，根节点是最近公共祖先。     |
| 88<br>**<br>(m)  | 最近公共祖先 [[Lowest Common Ancestor (LCA)]]                                | 找出二叉树中两个节点的最近公共祖先，节点一定存在树中。           | 输入:  <br>root = <br>[3,5,1,6,2,0,8,<br>null,null,7,4]<br>p = 5<br>q = 1  <br><br>输出: 3                    | 递归检查左右子树是否包含目标节点，结合二叉树特性优化查找。    |
| 578<br>*<br>(m)  | 最近公共祖先III [[Lowest Common Ancestor (LCAIII)]]                          | 找出二叉树中多个节点的最近公共祖先。                    | 输入:  <br>root = <br>[3,5,1,6,2,0,8,<br>null,null,7,4]<br>nodes = [5,4]  <br><br>输出: 5                     | 递归检查子树是否包含目标节点集合，根节点是最近公共祖先。     |
| 902<br>**<br>(m) | BST中第K小的元素 [[Kth Smallest Element in a BST]]                           | 找出二叉搜索树中第K小的元素。                       | 输入:  <br>root = <br>[3,1,4,null,2]<br>k = 1  <br><br>输出: 1                                                | 使用中序遍历计数到第K个节点返回结果，或记录子树节点数加速查找。 |
| 11<br>*<br>(m)   | 二叉查找树中搜索区间 [[Search Range in Binary Search Tree]]                      | 找出二叉搜索树中在指定区间内的所有节点值。                 | 输入:  <br>root = <br>[10,5,15,3,7,null,18]<br>range = [7,15]  <br><br>输出: [7,10,15]                        | 使用递归结合区间条件过滤节点，返回符合条件的值。         |
| 85<br>*<br>(e)   | 在二叉查找树中插入节点 [[Insert Node in a Binary Search Tree]]                    | 在二叉搜索树中插入一个新节点。                       | 输入:  <br>root = <br>[4,2,7,1,3]<br>val = 5  <br><br>输出: <br>[4,2,7,1,3,5]                                 | 递归定位插入位置，构造新节点插入树中。              |
| 1524<br><br>(e)  | 在二叉搜索树中查找 [[Search in a Binary Search Tree]]                           | 在二叉搜索树中查找一个值是否存在，并返回该节点。              | 输入:  <br>root = <br>[4,2,7,1,3]<br>val = 2  <br><br>输出: [2,1,3]                                           | 使用递归或迭代根据二叉搜索树特性快速定位目标节点。        |
| 33<br>*<br>(m)   | N皇后问题（一） [[N-Queens]]                                                  | 在N×N的棋盘上放置N个皇后，确保它们互相不攻击，返回所有可能的解法。   | 输入:  <br>n = 4  <br><br>输出: [<br>[".Q..","...<br>Q","Q...","..Q."],<br>["..Q.","Q...",<br>"...Q",".Q.."]] | 使用回溯算法逐行放置皇后，验证安全性并记录解法。         |
| 1181<br>*<br>(e) | 二叉树的直径 [[Diameter of Binary Tree]]                                     | 找出二叉树中两个节点之间的最长路径长度。                  | 输入:  <br>root = <br>[1,2,3,4,5]  <br><br>输出: 3                                                            | 使用后序遍历计算每个节点的左右子树深度，动态更新最长路径长度。  |


# **<mark style="background: #FF5582A6;">堆（Heap）</mark>的详细介绍**
###### 堆

| 题目编号                | 题目名称（英文）                                                | 题目简述（中文）                                                                                                        | 最简单样例                                                                                                                   | 解法                                         |
| ------------------- | ------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------- | ------------------------------------------ |
| 4<br>*<br>(m)       | [[Ugly Number II]] 丑数 II                                | 找到第 n 个丑数，丑数是仅由 2, 3 和 5 的质因子构成的正整数。                                                                            | 输入:  <br>n = 10  <br><br>输出:  <br>12                                                                                    | 使用最小堆生成丑数，动态记录已生成的数以避免重复计算。                |
| 130<br><br>(m)      | [[Heapify]] 堆化                                          | 给定一个未排序的数组，将其调整为堆（最小堆或最大堆）。                                                                                     | 输入:  <br>nums = <br>[3,2,1,4,5]  <br><br>输出:  <br>[1,2,3,4,5]                                                           | 使用下沉操作构建堆，从最后一个非叶节点向上调整堆。                  |
| 401<br><br>(m)      | [[Kth Smallest Number in Sorted Matrix]] 排序矩阵中的从小到大第k个数 | 找到排序矩阵中第 k 小的数。                                                                                                 | 输入:  <br>matrix = [<br>[1,5,9],<br>[10,11,13],<br>[12,13,15]]  <br>k = 8  <br><br>输出:  <br>13                           | 使用最小堆存储矩阵每行的首元素，动态更新并查找第 k 小值。             |
| 606<br><br>(m)      | [[Kth Largest Element II]]第K大的元素 II                     | 实现一个迭代器以动态计算数据流中的第 k 大元素。                                                                                       | 输入:  <br>nums = <br>[4,5,8,2]  <br>k = 3  <br><br>输出:  <br>[4]                                                          | 使用最小堆动态维护数据流中的第 k 大元素。                     |
| 486<br><br>(m)      | [[Merge K Sorted Arrays]]合并k个排序数组                       | 合并 k 个已排序的数组，返回一个排序后的列表。                                                                                        | 输入: <br>  [<br>    [1,2,3],<br>    [1,2]<br>  ]<br><br>输出: <br>[ 1,1,2,2,3 ]                                            | 使用最小堆存储每个数组当前最小值的迭代器。                      |
| 612<br>*<br>(m)     | [[K Closest Points]] K个最近的点                             | 找到离原点最近的 k 个点。                                                                                                  | 输入:  <br>points = [<br>[1,3],[-2,2],[2,-2]]  <br>k = 2  <br><br>输出:  <br>[ [-2,2],[2,-2] ]                              | 使用最大堆存储 k 个最近的点，动态比较并维护堆的大小。               |
| 839<br><br>(e)      | [[Merge Two Sorted Interval Lists]] 合并两个排序的间隔列表         | 合并两个排序的区间列表，返回一个合并后的列表。                                                                                         | 输入:  <br>list1 = [<br>[1,2],[3,4]]  <br>list2 = [<br>[2,3],[5,6]]  <br><br>输出:  <br>[ [1,4],[5,6] ]                     | 使用最小堆维护区间的起点，逐步合并重叠区间。                     |
| 857<br><br>(h)      | [[Minimum Window Subsequence]]最小的窗口子序列                  | 找到目标字符串中覆盖源字符串的最短子序列。                                                                                           | 输入:  <br>S = "abcdebdde"  <br>T = "bde" <br> <br>输出:  <br>"bcde"                                                        | 使用堆记录窗口的起始索引，动态更新最短窗口。                     |
| 1046<br><br>(e)     | [[Minimize Max Distance to Gas Station]] 二进制表示中质数个计算置位  | 在道路上新增加油站以最小化最大距离，返回最小的最大距离。                                                                                    | 输入:  <br>stations = <br>[1,2,3,4,5]  <br>k = 4  <br><br>输出:  <br>0.5                                                    | 使用最大堆模拟新增加油站的过程，逐步缩小最大距离。                  |
| 1057<br><br>(m)     | [[Network Delay Time]] 网络延迟时间                           | 有 N个网络节点，一个旅行时间和有向边列表 times[i] = (u, v, w)，其中u 是起始点， v是目标点， w是一个信号从起始到目标点花费的时间。 从一个特定节点 K发出信号，所有节点收到信号需要花费多长时间? | 输入: <br>times = [<br>[2,1,1],<br>[2,3,1],<br>[3,4,1]], <br>N = 4<br>K = 2<br><br>输出:  2                                 | Dijkstra 求最短路                              |
| 3661<br><br>(m)     | [[Missing Element in Sorted Array]] 有序数组中的缺失元素          | 找到排序数组中缺失的第 k 个数。                                                                                               | 输入:  <br>nums = <br>[4,7,9,10]  <br>k = 3  <br><br>输出:  <br>8                                                           | 使用堆存储缺失的元素数目，动态计算目标值。                      |
| 3666<br><br>(h)     | [[Campus Bikes II ]]校园自行车分配（二）                          | 将工人和自行车分配，返回分配的最小总距离。                                                                                           | 输入:  <br>workers = [<br>[0,0],[1,1],[2,0]]  <br>bikes = [<br>[1,0],[2,2],[2,1]]  <br><br>输出:  4                         | 使用最小堆枚举所有分配方案，按最小距离进行选择。                   |
| 1418<br><br>(m)     | [[Path With Maximum Minimum Value]]具有最大最小值的路径           | 找到二维网格中最大最小路径值，从左上角到右下角。                                                                                        | 输入:  <br>grid = [<br>[5,4,5],<br>[1,2,6],<br>[7,4,6]] <br> <br>输出:  4                                                   | 使用最大堆记录路径中的最小值，动态更新网格状态。                   |
| 3707<br><br>(m)     | [[Corporate Flight Bookings]] 统计航班预订信息                  | 给定航班预订记录，计算每个航班的预订总数。                                                                                           | 输入:  <br>bookings = [<br>[1,2,10],<br>[2,3,20],<br>[2,5,25]]  <br>n = 5  <br><br>输出:  <br>[10,55,45,25,25]              | 使用差分数组和堆动态更新每个航班的预订数目。                     |
| 1872<br><br>(m)     | [[Minimum Cost to Connect Sticks]] 连接棒材的最低费用            | 计算将所有木棍连接成一根木棍的最小成本。                                                                                            | 输入:  <br>sticks = <br>[2,4,3]  <br><br>输出:  <br>14                                                                      | 使用最小堆合并长度最小的木棍，动态计算总成本。                    |
| 81<br>**<br>(h)     | 寻找数据流的中位数 [[Find Median from Data Stream]]              | 实现一个数据结构，支持从数据流中高效找到中位数。                                                                                        | 输入:  <br>addNum(1), <br>addNum(2), <br>findMedian(), <br>addNum(3), <br>findMedian()  <br><br>输出: [1.5, 2]              | 使用两个堆（最大堆和最小堆）分别存储较小和较大的元素，中位数取决于堆的大小或堆顶值。 |
| 544<br>*<br>(m)<br> | 前K大数 [[Top k Largest Numbers]]                          | 给定一个数组和整数k，找出数组中前k大的数。                                                                                          | 输入:  <br>nums = [3,2,1,5,6,4], k = 2  <br>输出: [5,6]                                                                     | 使用最小堆存储前k个数，遍历数组动态维护堆中最大的k个数。              |
| 545<br>*<br>(m)     | 前K大数 II [[Top k Largest Numbers II]]                    | 实现一个数据结构支持动态插入数字并能高效返回前k大的数。                                                                                    | 输入:  <br>add(3), <br>add(10), <br>topk()  <br><br>输出: [10,3]                                                            | 使用最小堆维护前k大的数，每次插入新数字时更新堆中的值。               |
| 1512<br>*<br>(h)    | 雇佣K个人的最低费用 [[Minimum Cost to Hire K Workers]]           | 给定一组工人的工资和质量，找到雇佣k个工人的最低费用。                                                                                     | 输入:  <br>quality = <br>[10,20,5]<br>wage = <br>[70,50,30]<br>k = 2  <br><br>输出: 105                                     | 使用最小堆存储工人的质量比，动态维护前k个工人组合的最低工资。            |
| 577<br>*<br>(m)     | 合并K个排序间隔列表 [[Merge K Sorted Interval Lists]]            | 合并k个排序的区间列表，返回一个合并后的区间列表。                                                                                       | 输入:  <br>intervals = [<br>[ [1,3],[5,7] ],<br>[ [2,4],[6,8] ],<br>[ [9,10] ]<br>]  <br><br>输出: [<br>[1,4],[5,8],[9,10]] | 使用最小堆按区间起点排序，动态合并重叠的区间。                    |
| 919<br>*<br>(m)     | 会议室 II [[Meeting Rooms II]]                             | 给定一组会议时间，找出需要的最小会议室数量。                                                                                          | 输入:  <br>intervals = [<br>[0,30],<br>[5,10],<br>[15,20]]  <br><br>输出: 2                                                 | 使用最小堆存储当前会议的结束时间，动态分配会议室数量。                |



# **<mark style="background: #ADCCFFA6;">字典树（Trie）</mark>的详细介绍**
###### 字典树


| 题目编号             | 题目名称（英文）                                                 | 题目简述（中文）                           | 最简单样例                                                                                                                                                     | 解法                            |
| ---------------- | -------------------------------------------------------- | ---------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------- |
| 442<br>**<br>(m) | [[Implement Trie (Prefix Tree)]] 实现前缀树                   | 实现一个字典树（前缀树），支持插入、查找和判断前缀操作。       | 输入: <br>insert("lintcode")<br>search("lint")<br>startsWith("lint")<br><br>输出: <br>false<br>true                                                           | 使用嵌套字典构造前缀树，递归或迭代实现插入和查询操作。   |
| 473<br>**<br>(m) | [[Add and Search Word]] 单词的添加与查找                         | 实现一个单词搜索数据结构，支持通配符查询（“.”表示任意字符）。   | 输入:<br>addWord("a")<br>search(".")<br><br>输出: <br>true                                                                                                    | 使用字典树构建单词结构，递归处理通配符匹配。        |
| 634<br>*<br>(h)  | [[Word Squares]] 单词矩阵                                    | 找到所有可以构成单词方阵的单词集合。                 | 输入:<br>["abat","baba",<br>"atan","atal"]<br><br>输出:<br> [ ["baba","abat",<br>"baba","atan"],<br>["baba","abat",<br>"baba","atal"] ]]]                     | 使用字典树和回溯法生成所有可能的单词组合。         |
| 1090<br><br>(m)  | [[Map Sum Pairs]] 映射配对之和                                 | 实现一个键值映射数据结构，支持以任意前缀开头的键值和查询。      | 输入: <br>insert("apple", 3)<br><br>输出: <br>Null<br>                                                                                                        | 使用字典树记录每个节点的累积和，动态更新结果。       |
| 1110<br><br>(m)  | [[Replace Words]] 单词替换                                   | 使用词典中的单词替换输入句子中的单词，替换为最短前缀。        | 输入:  <br>dictionary = [<br>"cat","bat","rat"],  <br>sentence = <br>"the cattle was rattled by the battery" <br> <br>输出:  <br>"the cat was rat by the bat" | 使用字典树存储词典，逐词匹配替换句子中的单词。       |
| 1071<br><br>(e)  | [[Longest Word in Dictionary ]]词典中最长的单词                  | 找到字典中可以逐步构建的最长单词，多个答案时返回字典序最小的单词。  |                                                                                                                                                           | 使用字典树构建词典，按长度和字典序排序返回结果。      |
| 1248<br>*<br>(m) | [[Maximum XOR of Two Numbers in an Array]] 数组中两个数字的最大异或  | 在数组中找到两个数的最大异或值。                   | 输入:  <br>nums = <br>[3,10,5,25,2,8]  <br><br>输出:  28                                                                                                      | 使用字典树存储二进制位，逐位匹配最大异或结果。       |
| 1221<br>*<br>(h) | [[Concatenated Words ]]连接词                               | 找到所有由其他单词拼接而成的单词。                  | 输入: <br>words = <br>["a","b",<br>"ab","abc"]<br><br>输出: ["ab"]                                                                                            | 使用字典树存储单词，结合回溯判断是否能由其他单词拼接而成。 |
| 775<br>*<br>(h)  | [[Palindrome Pairs]] 回文对                                 | 找到数组中所有回文数对。                       | 输入:<br>["bat", "tab", "cat"]<br><br>输出:<br>[ [0, 1], [1, 0] ]                                                                                             | 使用字典树存储单词及其反转，检查是否能形成回文对。     |
| 333<br>*<br>(m)  | 识别字符串 [[Identifying Strings]]                            | 判断一个字符串是否存在于字典中，并支持动态添加字符串到字典中。    | 输入:  <br>add("apple"), <br>search("apple"), <br>search("app")  <br><br>输出: true, false                                                                    | 使用字典树存储所有字符串，遍历节点检查字符串是否存在。   |
| 1624<br>*<br>(h) | 最大距离 [[Max Distance]]                                    | 给定一个单词列表，找到两个单词之间的最大距离。            | 输入:  <br>words = <br>["practice", <br>"makes", "perfect", <br>"coding", "makes"]  <br><br>输出: 3                                                           | 使用字典树记录每个单词出现的索引，计算索引差的最大值。   |
| 623<br>*<br>(h)  | K步编辑 [[K Edit Distance]]                                 | 找出所有与给定单词距离不超过K的字典单词。              | 输入:  <br>words = <br>["abc", "abd", "abcd"]<br>target = "abc"<br>k = 1  <br><br>输出: ["abc", "abd"]                                                        | 使用字典树结合动态规划计算编辑距离，返回符合条件的单词。  |
| 635<br>*<br>(h)  | 拼字游戏 [[Boggle Game]]                                     | 给定一个字母矩阵和单词列表，找出矩阵中所有可以由相邻字母组成的单词。 | 输入:  <br>board = [<br>["b","o","g"],<br>["l","e","o"],<br>["g","o","d"]], <br>words = <br>["bog","dog"] <br> <br>输出: ["bog"]                              | 使用字典树存储单词，结合深度优先搜索查找矩阵中的有效路径。 |
| 270<br>*<br>(m)  | 电话号码的字母组合II [[Letter Combinations of a Phone Number II]] | 给定一个数字字符串，返回所有可能的字母组合。             | 输入:  <br>digits = "23"  <br><br>输出: <br>["ad","ae","af",<br>"bd","be","bf",<br>"cd","ce","cf"]                                                            | 使用字典树存储数字到字母的映射，结合回溯生成所有可能组合。 |
| 722<br>*<br>(h)  | 最大子数组VI [[Maximum Subarray VI]]                          | 找出数组中和最大的子数组，同时满足每个元素在某个字典的子集范围内。  | 输入:  <br>nums = [1,2,3]<br>dict = [1,2]  <br><br>输出: [1,2]                                                                                                | 使用字典树存储字典范围，动态查找符合条件的子数组。     |


# **<mark style="background: #ADCCFFA6;">线段树（Segment Tree）</mark>的详细介绍**
###### 线段树

| 题目编号            | 题目名称（英文）                                             | 题目简述（中文）                      | 最简单样例                                                                          | 解法                               |
| --------------- | ---------------------------------------------------- | ----------------------------- | ------------------------------------------------------------------------------ | -------------------------------- |
| 201<br><br>(m)  | [[Leetcode - 10.Advanced/Segment Tree Build]] 线段树的构造 | 构建一个线段树，支持范围查询和修改操作。          | 输入:  <br>nums = [3,2,1,4]<br>  <br>输出:  <br>线段树的根节点                            | 使用递归分治构建线段树，每个节点存储区间值。           |
| 202<br><br>(m)  | [[Segment Tree Query]] 线段树的查询                        | 实现线段树的查询操作，返回指定范围内的最小值。       | 输入:  <br>nums = [3,2,1,4]  <br>query(1,3)  <br><br>输出:  1                      | 使用线段树的递归方法，逐层访问区间并返回最小值。         |
| 203<br><br>(m)  | [[Segment Tree Modify]]线段树的修改                        | 修改线段树中一个元素的值，并动态更新相关节点。       | 输入:  <br>nums = [3,2,1,4]  <br>modify(2,5)  <br><br>输出:  <br>线段树更新后的状态         | 修改节点值后递归更新父节点的区间值。               |
| 247<br><br>(m)  | [[Segment Tree Query II]] 线段树查询 II                   | 查询线段树中指定范围内的最大值。              | 输入:  <br>nums = [1,3,5,7]  <br>query(1,3)  <br><br>输出:  7                      | 使用线段树的递归方法逐层检查并返回最大值。            |
| 206<br>*<br>(m) | [[Interval Sum]] 区间求和 I                              | 计算数组中多个区间的和。                  | 输入:  <br>nums = [1,2,3,4]  <br>queries = [<br>[1,2],[2,4]]  <br><br>输出: [3,9]  | 使用线段树构建区间和模型，支持高效查询。             |
| 205<br><br>(m)  | [[Interval Minimum Number]] 区间最小数                    | 找到数组中多个区间的最小值。                | 输入:  <br>nums = [4,3,2,1]  <br>queries = [<br>[1,2],[2,4]]  <br><br>输出:  [3,1] | 使用线段树构建区间最小值模型，支持高效查询。           |
| 212<br>*<br>(e) | [[Space Replacement ]]空格替换                           | 将字符串中的空格替换为 `%20`。            | 输入:  <br>s = "Mr John Smith"  <br><br>输出:  <br>"Mr%20John%20Smith"             | 使用双指针从后向前遍历字符串，替换空格。             |
| 439<br><br>(m)  | [[Segment Tree Build II ]]线段树的构造 II                  | 构建一个线段树，每个节点存储区间内的最小值和最大值。    | 输入:  <br>nums = [1,4,2,3] <br> <br>输出:  <br>线段树根节点                             | 使用递归构建节点，动态存储区间值。                |
| 217<br><br>(e)  | [[Remove Duplicates from Unsorted List]] 无序链表的重复项删除  | 删除未排序链表中的重复节点。                | 输入:  <br>head = [1,2,2,3]  <br><br>输出:  <br>[1,2,3]                            | 使用哈希表记录已访问节点值，过滤重复节点。            |
| 207<br>*<br>(h) | 区间求和II [[Interval Sum II]]                           | 在区间求和的基础上，增加更新操作，支持修改数组中的元素值。 | 输入:  <br>nums = [1,2,3], <br>update(1,5), <br>sum(0,2)  <br><br>输出: [9]        | 构建线段树存储区间和，更新时动态调整树结构，查询时递归分段求和。 |




# **<mark style="background: #ADCCFFA6;">平衡二叉树（Balanced Binary Tree）</mark>的详细介绍**
###### 平衡二叉树

| **题目编号**        | **题目名称 (英文/中文)**               | **题目简述 (中文)**                        | **样例**                                                                     | **解法**                                     |
| --------------- | ------------------------------ | ------------------------------------ | -------------------------------------------------------------------------- | ------------------------------------------ |
| 93<br>*<br>(e)  | 平衡二叉树 [[Balanced Binary Tree]] | 判断一棵二叉树是否为平衡二叉树（每个节点的左右子树高度差不超过 1）。  | 输入:  <br>root = <br>[3,9,20,null,null,15,7]  <br><br>输出: true              | 使用递归计算每个节点的高度，检查左右子树的高度差，若所有节点满足条件则为平衡二叉树。 |
| 1513<br><br>(m) | 考场就座 [[Exam Room]]             | 实现一个考场就座系统，支持学生尽可能坐到离他人最远的位置，支持离开座位。 | 输入:  <br>seat(), <br>seat(), <br>leave(0), <br>seat()  <br><br>输出: [0,9,4] | 使用平衡二叉树存储座位区间，动态更新座位状态，通过区间长度计算最优座位。       |



# **<mark style="background: #ADCCFFA6;">树状数组（Binary Indexed Tree）</mark>的详细介绍**
###### 树状数组

| **题目编号**             | **题目名称 (英文/中文)**                                       | **题目简述 (中文)**                   | **样例**                                                                                                                                                      | **解法**                                   |
| -------------------- | ------------------------------------------------------ | ------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------- |
| 249<br>*<br>(h)      | 统计前面比自己小的数的个数 [[Count of Smaller Numbers Before Self]] | 给定一个数组，统计每个数字前面比它小的数字个数，并返回结果。  | 输入:  <br>nums = [5,2,6,1]  <br><br>输出:  <br>[2,1,1,0]                                                                                                       | 使用树状数组维护前缀和，动态更新数字的出现次数，通过查询累计小于当前数字的计数。 |
| 817<br>*<br>(m)      | 范围矩阵元素和 - 可变的 [[Range Sum Query 2D - Mutable]]         | 给定一个二维矩阵，支持更新单个元素值和查询任意子矩阵的元素和。 | 输入:  <br>matrix = [<br>[3,0,1,4,2],<br>[5,6,3,2,1],<br>[1,2,0,1,5],<br>[4,1,0,1,7],<br>[1,0,3,0,5]]<br>update(3,2,2)<br>sumRegion(2,1,4,3)  <br><br>输出: [8] | 使用二维树状数组，动态更新矩阵元素，通过查询累加子矩阵的和。           |
| 840<br>*<br>(m)      | 可变范围求和 [[Range Sum Query - Mutable]]                   | 给定一个数组，支持更新单个元素值和查询任意子数组的元素和。   | 输入:  <br>nums = [1,3,5]  <br>update(1,2)  <br>sumRange(0,2) <br><br>输出:  8                                                                                  | 使用树状数组维护前缀和，动态更新元素值，通过查询累加子数组的和。         |
| 1645<br>*<br>(m)<br> | 最少子序列 [[Minimum Subsequence in Non-Increasing Order]]  | 给定一个数组，找到总和大于剩余数字总和的最小递减子序列。    | 输入:  <br>nums = [4,3,10,9,8]  <br>输出: [10,9]                                                                                                                | 先对数组排序，使用树状数组维护前缀和，动态查找满足条件的最小子序列。       |



# **<mark style="background: #ADCCFFA6;">圖（Graph）</mark>的詳細介紹**
###### 圖

| 题目编号            | 题目名称（英文和中文）                                           | 题目简述（中文）                       | 最简单样例                                                                                                    | 解法                             |
| --------------- | ----------------------------------------------------- | ------------------------------ | -------------------------------------------------------------------------------------------------------- | ------------------------------ |
| 176<br><br>(m)  | [[Route Between Two Nodes in Graph]] (两点间路径)          | 判断有向图中是否存在两个节点之间的路径。           | 输入:  <br>graph = [ <br>[1, 2], <br>[3], <br>[3], [] ]  <br>start = 0  <br>end = 3  <br><br>输出:  <br>true | 使用 BFS 或 DFS 遍历图，检查是否能到达目标节点。  |
| 431<br>*<br>(m) | [[Connected Component in Undirected Graph]] (无向图连通分量) | 找到无向图中的所有连通分量。                 | 输入:  <br>graph = [ <br>[1, 2], [], <br>[3], [] ] <br> <br>输出:  <br>[<br>[0, 1, 2, 3]]                    | 使用 BFS 或 DFS 遍历图，记录每个连通分量中的节点。 |
| 618<br><br>(m)  | [[Search Graph Nodes ]](搜索图节点)                        | 在图中查找与目标节点颜色相同的所有节点，返回距离最近的节点。 | 输入:  <br>graph = [ <br>[1, 2], [0, 3], <br>[0, 3], [1, 2]]  <br>target = 2 <br> <br>输出:  [2, 3]          | 使用 BFS 遍历图，同时检查节点颜色。           |
| 1078<br><br>(e) | [[Degree of an Array]] (数组的度)                         | 找到具有数组中相同度的最短连续子数组长度。          | 输入:  <br>nums = <br>[1, 2, 2, 3, 1]  <br><br>输出:  2                                                      | 使用哈希表记录元素的首次和最后出现位置以及频率，计算结果。  |
| 836<br><br>(h)  | [[Partition to K Equal Sum Subsets]] (分割为K个等和子集)      | 判断是否可以将数组分成 k 个子集，使每个子集的和相等。   | 输入:  <br>nums = <br>[4, 3, 2, 3, 5, 2, 1]  <br>k = 4  <br><br>输出:  true                                  | 使用回溯和动态规划检查可能的分区方案。            |


### 動態規劃的題目
###### 動態規劃

| **题目编号**            | **题目名称 (英文/中文)**                                      | **题目简述 (中文)**                         | **样例**                                                       | **解法**                              |
| ------------------- | ----------------------------------------------------- | ------------------------------------- | ------------------------------------------------------------ | ----------------------------------- |
| 77<br>**<br>(m)<br> | 最长公共子序列 [[Longest Common Subsequence]]                | 找到两个字符串的最长公共子序列长度。                    | 输入:  <br>text1 = "abcde"<br>text2 = "ace"  <br><br>输出: 3     | 使用二维动态规划表记录两个字符串的匹配情况，逐步更新最长子序列长度。  |
| 119<br>*<br>(h)     | 编辑距离 [[Edit Distance]]                                | 找到两个字符串之间的最小编辑距离，包括插入、删除和替换操作。        | 输入:  <br>word1 = "horse"<br>word2 = "ros" <br><br>输出: 3      | 使用二维动态规划表记录转换的最小操作次数，更新每步操作结果。      |
| 76<br>*<br>(m)      | 最长上升子序列 [[Longest Increasing Subsequence]]            | 找到数组中的最长严格递增子序列。                      | 输入:  <br>nums = <br>[10,9,2,5,3,<br>7,101,18]  <br><br>输出: 4 | 使用动态规划记录以每个元素为结尾的最长子序列长度，遍历数组更新最大值。 |
| 92<br><br>(m)       | 背包问题 [[Backpack]]                                     | 给定一个背包的最大容量和一组物品的体积，找到可以装下的最大体积。      | 输入:  <br>m = 10, <br>nums = [3,4,8,5]  <br><br>输出: 9         | 使用动态规划记录每个容量下的最大体积，逐步更新最优解。         |
| 149<br>*<br>(m)     | [[Best Time to Buy and Sell Stock]]买卖股票的最佳时机          | 找到最大利润，允许一次买入和一次卖出股票。                 | 输入:  <br>prices =<br>[7,1,5,3,6,4]  <br><br>输出:  5           | 使用哈希表记录最低价格和当前利润。                   |
| 150<br>*<br>(m)     | [[Best Time to Buy and Sell Stock II]]买卖股票的最佳时机II     | 找到最大利润，可以多次买入和卖出股票。                   | 输入:  <br>prices = <br>[7,1,5,3,6,4]  <br><br>输出:  7          | 使用哈希表动态记录买入和卖出操作。                   |
| 1164<br><br>(m)<br> | [[Wiggle Subsequence]]摆动序列                            | 给定一个数组，找到最长的摆动子序列，摆动子序列的相邻数字之差总是正负交替。 | 输入:  <br>nums = <br>[1,7,4,9,2,5]  <br><br>输出:  6            | 使用动态规划记录以当前值结尾的最长摆动子序列长度。           |
| 151<br>*<br>(m)     | 买卖股票的最佳时机 III [[Best Time to Buy and Sell Stock III]] | 找到最多完成两笔交易的情况下可以获得的最大利润。              | 输入:  <br>prices = <br>[3,3,5,0,0,3,1,4]  <br><br>输出: 6       | 使用动态规划结合双指针，分别计算每次交易的最大利润。          |

###### 數學

| **题目编号**       | **题目名称 (英文/中文)**        | **题目简述 (中文)**                                   | **样例**                     | **解法**                                                                     |
| -------------- | ----------------------- | ----------------------------------------------- | -------------------------- | -------------------------------------------------------------------------- |
| 513<br><br>(m) | [[Perfect Squares]]完美平方 | 给定一个正整数 n，找到至少需要多少个完全平方数（比如 1、4、9 等）使得它们的和等于 n。 | 输入: <br>n=12 <br><br>输出: 3 | 使用队列进行广度优先搜索（BFS）。从 n 开始，减去每个小于等于 n 的完全平方数，将结果作为下一层的节点，直到找到 0 为止，记录层数作为结果。 |