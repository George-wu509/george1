Lintcode 627
给出一个包含大小写字母的字符串。求出由这些字母构成的最长的回文串的长度是多少。

数据是大小写敏感的，也就是说，`"Aa"` 并不会被认为是一个回文串。

```python
"""
输入 : s = "abccccdd"
输出 : 7
说明 : 
一种可以构建出来的最长回文串方案是 "dccaccd"。
```


```python
    def longest_palindrome(self, s):
        # Write your code here
        hash = {}

        for c in s:
            if c in hash:
                del hash[c]
            else:
                hash[c] = True

        remove = len(hash)
        if remove > 0:
            remove -= 1
    
        return len(s) - remove
```
pass
解釋:
step1: 用collections.Counter計算每個字元出現的次數
step2: 將所有出現偶數次的字元全部用上, 所有出現奇數次的字元，取其偶數部分（`次數 - 1`）用上. 如果存在任何出現奇數次的字元. 我們可以從它們剩下的那一個字元中，選取任意一個放在回文串的最中間。



本題 **`longest_palindrome(self, s) -> int`** 的目標是找到 `s` 中**可以重新排列成的最長回文串的長度**。

### **核心觀察**

1. **回文的性質**
    
    - **中心對稱性**：回文的左右兩邊字符相同。
    - **偶數次數的字符可以完全使用**。
    - **若有奇數次數的字符，最多只能有一個字符出現在中心**。
2. **計算可構成回文的最大長度**
    
    - 若某個字母出現偶數次，**可以完整使用**。
    - 若某個字母出現奇數次，則 **可以使用 `count - 1`，但可以額外選擇一個作為中心**。

---

## **變數表**

|變數名稱|含義|
|---|---|
|`s`|輸入的字串|
|`hash`|紀錄**字符出現的奇偶性**（若出現偶數次則刪除）|
|`remove`|需要移除的字符數量，以確保最多只有一個奇數出現|
|`len(s) - remove`|可構成的最長回文長度|

---

## **具體步驟**

1. **遍歷 `s`，紀錄每個字母的奇偶性**
    
    - 若 `c` 已在 `hash`，表示該字符出現偶數次，則**刪除**（`del hash[c]`）。
    - 若 `c` **不在 `hash`**，表示目前該字符出現奇數次，則加入 `hash`。
2. **計算 `remove`（剩下 `hash` 中的奇數字符數量）**
    
    - `hash` 內的鍵代表出現**奇數次數**的字符個數。
    - 若有 `remove > 0`，則我們**最多只能移除 `remove - 1` 個奇數次字符**，保留一個作為回文的中心。
3. **計算最長回文長度**
    
    - `len(s) - remove` 為可構成的回文長度。

---

## **範例解析**

### **範例 1**

`s = "abccccdd"`

**步驟**

|`i`|`c`|`hash` 狀態|說明|
|---|---|---|---|
|0|`a`|`{a}`|`a` 第一次出現，加入 `hash`|
|1|`b`|`{a, b}`|`b` 第一次出現，加入 `hash`|
|2|`c`|`{a, b, c}`|`c` 第一次出現，加入 `hash`|
|3|`c`|`{a, b}`|`c` 第二次出現，刪除|
|4|`c`|`{a, b, c}`|`c` 第三次出現，加入|
|5|`c`|`{a, b}`|`c` 第四次出現，刪除|
|6|`d`|`{a, b, d}`|`d` 第一次出現，加入|
|7|`d`|`{a, b}`|`d` 第二次出現，刪除|

- **`hash = {a, b}`**（表示 `a` 和 `b` 出現奇數次）。
- **`remove = 2`**（代表 `a` 和 `b`）。
- **可保留一個奇數字符，則 `remove -= 1`，所以 `remove = 1`**。
- **最長回文長度 = `len(s) - remove = 8 - 1 = 7`**。

**結果**：`7`（可形成 `"dccaccd"` 或 `"dccbccd"`）

---

### **範例 2**

python

複製編輯

`s = "abc"`

**步驟**

|`i`|`c`|`hash` 狀態|說明|
|---|---|---|---|
|0|`a`|`{a}`|`a` 第一次出現，加入 `hash`|
|1|`b`|`{a, b}`|`b` 第一次出現，加入 `hash`|
|2|`c`|`{a, b, c}`|`c` 第一次出現，加入 `hash`|

- **`hash = {a, b, c}`**（全部出現奇數次）。
- **`remove = 3`**（所有字符都是奇數次）。
- **最多只能保留一個，則 `remove = 3 - 1 = 2`**。
- **最長回文長度 = `len(s) - remove = 3 - 2 = 1`**。

**結果**：`1`（可形成 `"a"`, `"b"` 或 `"c"`）

---

## **時間與空間複雜度分析**

- **時間複雜度**
    
    - **遍歷 `s`**：`O(n)`
    - **檢查 `hash` 字典**：`O(1)`（因為最多 26 個英文字母）
    - **總體時間複雜度：`O(n)`**
- **空間複雜度**
    
    - `hash` 最多存 26 個字母，視為常數空間 `O(1)`。
    - **總體空間複雜度：`O(1)`**

---

## **其他解法想法（不含代碼）**

4. **使用 `Counter` 計數字母頻率**
```python
    def longestPalindrome(self, s):
        # write your code here
        n = len(s)
        if not s:
            return 0
        count = Counter(s)
        ans = 0
        for k in count.values():
            if k % 2 == 0:
                ans += k
            else:
                ans += k - 1
        return ans if ans == n else ans + 1
```
    - 遍歷 `s` 建立 `Counter`
    - 遍歷 `Counter` 計算所有偶數部分與最多保留一個奇數部分
    - 時間 `O(n)`，空間 `O(1)`
5. **陣列計數 (`O(n)`)**
    
    - 用大小 `26` 的陣列存字母頻率
    - 和 `Counter` 方法類似，但更節省記憶體（因為不需要存字母鍵）
6. **暴力檢查所有排列 (`O(n!)`)**
    
    - 產生所有 `s` 的排列，檢查是否為回文
    - 明顯不可行，時間 `O(n!)`

---

## **結論**

- **最優解法**：使用 **`hash` 記錄奇偶性 (`O(n)`)**，省去完整字母計數，**空間 `O(1)`**。
- **可替代方法**：
    - **`Counter` 計數法 (`O(n)`)**：較直觀但需遍歷 `Counter`
    - **陣列計數法 (`O(n)`)**：類似 `Counter`，但空間更節省
    - **暴力檢查 (`O(n!)`)**：不適用

本題的 **字典奇偶法 (`O(n)`)** 是最佳方法，因為它 **只需一次遍歷，且不需要完整存儲字母頻率**，適用於大規模輸入。



**核心思路**

要構成一個回文串，字串中的大部分字元需要成對出現（一個在前半部分，一個在後半部分）。

- 如果一個字元出現了偶數次（例如 'a' 出現 4 次），那麼這 4 個 'a' 可以完全用在回文串中（兩個在左邊，兩個在右邊）。
- 如果一個字元出現了奇數次（例如 'b' 出現 3 次），那麼我們可以取其中的偶數部分（2 個 'b'）用在回文串中（一個在左，一個在右），剩下 1 個 'b'。
- 對於所有出現奇數次的字元，它們各自剩下 1 個無法配對。然而，一個回文串的**正中央**可以允許**最多一個**出現奇數次的字元。

因此，構成最長回文串的策略是：

1. 計算每個字元出現的次數。
2. 將所有出現偶數次的字元全部用上。
3. 將所有出現奇數次的字元，取其偶數部分（`次數 - 1`）用上。
4. 如果存在任何出現奇數次的字元，我們可以從它們剩下的那一個字元中，選取**任意一個**放在回文串的最中間。

**程式碼解法解釋**

這個解法巧妙地利用一個字典 (`hash`) 來找出哪些字元出現了奇數次。

1. **初始化:** `hash = {}` 建立一個空字典，用來追蹤字元的奇偶性。
    
2. **遍歷字串與更新 `hash`:**
    
    Python
    
    ```
    for c in s:
        if c in hash:
            del hash[c]  # 如果字元已在 hash 中，表示這次是第偶數次遇到它，將其移除
        else:
            hash[c] = True # 如果字元不在 hash 中，表示這次是第奇數次遇到它，將其加入
    ```
    
    這個迴圈非常聰明：
    
    - 當一個字元第一次遇到時，它被加入 `hash`。
    - 當它第二次遇到時，它從 `hash` 中被移除。
    - 第三次遇到時，又被加入... 以此類推。
    - 最終，**只有那些在字串 `s` 中出現了奇數次的字元，才會留在 `hash` 字典中。** 字典裡的值 (`True`) 並不重要，重要的是鍵 (key) 是否存在。
3. **計算需要移除的字元數:**
    
    Python
    
    ```
    remove = len(hash)
    ```
    
    `len(hash)` 計算了 `hash` 中有多少個鍵，也就是有多少種字元出現了奇數次。 假設有 `remove` 種字元出現了奇數次。
    
4. **處理中心字元:**
    
    Python
    
    ```
    if remove > 0:
        remove -= 1
    ```
    
    - 如果 `remove > 0`，表示至少有一種字元出現了奇數次。我們可以選擇其中**任意一種**字元的那一個「多餘的」字元放在最長回文串的中心。
    - 因此，真正**必須**從原始字串中捨棄掉、不能用於構成回文串的字元數量，是 `remove - 1` 個（即除了被選作中心的那一個奇數字元外，其他所有出現奇數次的字元都必須捨棄掉它們多出來的那一個）。
    - 如果 `remove == 0`，表示所有字元都出現了偶數次，我們不需要捨棄任何字元，`remove` 保持為 0。
5. **計算最終長度:**
    
    Python
    
    ```
    return len(s) - remove
    ```
    
    最長回文串的長度，就是原始字串的總長度 `len(s)` 減去我們**必須**捨棄的字元數 `remove`。
    

**複雜度分析**

- **時間複雜度:** O(n)，其中 n 是字串 `s` 的長度。需要遍歷一次字串。字典的插入、刪除、查找操作平均時間複雜度為 O(1)。
- **空間複雜度:** O(k)，其中 k 是字串 `s` 中不同字元的數量。在最壞情況下（例如，字串中每個字元都不同），空間複雜度可能接近 O(n)。但由於題目限制是大小寫字母，k 最多是 52，所以可以認為是 O(1) 或 O(k)（取決於如何定義常數）。

**優化方案**

這個解法在時間和空間效率上已經相當不錯了。但可以考慮使用 Python 的標準庫來讓代碼更直觀或在某些情況下可能更高效一點：

1. **使用 `collections.Counter`:** 這是更常見和 Pythonic 的計算字元頻率的方式。
    
    Python
    
    ```
    import collections
    
    def longest_palindrome_counter(self, s: str) -> int:
        counts = collections.Counter(s) # 直接計算每個字元的出現次數 O(n)
        length = 0
        odd_found = 0 # 用來標記是否找到了至少一個奇數字元
    
        for count in counts.values():
            # 將每個字元的偶數部分加到總長度
            length += (count // 2) * 2
            # 如果當前字元數量是奇數，標記一下
            if count % 2 == 1:
                odd_found = 1
    
        # 如果找到過奇數字元，可以將其中一個放在中間，總長度加 1
        return length + odd_found
    ```
    
    - **優點:** 代碼邏輯更直接地對應了我們之前的「核心思路」分析，可讀性可能更高。
    - **複雜度:** 時間 O(n)，空間 O(k)。與原解法相同。
2. **使用固定大小陣列 (如果字元集有限且已知):** 如果確定字元只在 ASCII 範圍內，可以用一個大小為 128 或 256 的陣列代替字典來計數，可能會有微小的常數級別的性能提升，但會犧牲一些通用性。對於只有大小寫字母的情況，可以用大小為 52 (或更方便地用 128) 的陣列。
    
    Python
    
    ```
    def longest_palindrome_array(self, s: str) -> int:
        counts = [0] * 128 # 假設 ASCII
        for char in s:
            counts[ord(char)] += 1 # ord() 獲取字符的 ASCII 值
    
        length = 0
        odd_found = 0
        for count in counts:
            if count > 0: # 只關心出現過的字符
                length += (count // 2) * 2
                if count % 2 == 1:
                    odd_found = 1
    
        return length + odd_found
    ```
    
    - **優點:** 理論上訪問陣列比計算雜湊更快。
    - **缺點:** 需要預知字元範圍，代碼不如 `Counter` 簡潔。
    - **複雜度:** 時間 O(n)，空間 O(C) (C是字元集大小，例如128，是常數)。

**結論**

提供的原始解法利用字典巧妙地找出了出現奇數次的字元個數，邏輯正確且高效 (O(n) 時間, O(k) 空間)。使用 `collections.Counter` 的替代方案在可讀性上可能更佳，複雜度相同，也是非常好的選擇。使用固定大小陣列是另一種可能的微優化，但通常 `Counter` 或原始解法的字典已經足夠好。