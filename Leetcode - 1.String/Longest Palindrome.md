Lintcode 627
给出一个包含大小写字母的字符串。求出由这些字母构成的最长的回文串的长度是多少。

数据是大小写敏感的，也就是说，`"Aa"` 并不会被认为是一个回文串。

```python
"""
输入 : s = "abccccdd"
输出 : 7
说明 : 
一种可以构建出来的最长回文串方案是 "dccaccd"。
```


```python
    def longest_palindrome(self, s):
        # Write your code here
        hash = {}

        for c in s:
            if c in hash:
                del hash[c]
            else:
                hash[c] = True

        remove = len(hash)
        if remove > 0:
            remove -= 1
    
        return len(s) - remove
```
pass


本題 **`longest_palindrome(self, s) -> int`** 的目標是找到 `s` 中**可以重新排列成的最長回文串的長度**。

### **核心觀察**

1. **回文的性質**
    
    - **中心對稱性**：回文的左右兩邊字符相同。
    - **偶數次數的字符可以完全使用**。
    - **若有奇數次數的字符，最多只能有一個字符出現在中心**。
2. **計算可構成回文的最大長度**
    
    - 若某個字母出現偶數次，**可以完整使用**。
    - 若某個字母出現奇數次，則 **可以使用 `count - 1`，但可以額外選擇一個作為中心**。

---

## **變數表**

|變數名稱|含義|
|---|---|
|`s`|輸入的字串|
|`hash`|紀錄**字符出現的奇偶性**（若出現偶數次則刪除）|
|`remove`|需要移除的字符數量，以確保最多只有一個奇數出現|
|`len(s) - remove`|可構成的最長回文長度|

---

## **具體步驟**

1. **遍歷 `s`，紀錄每個字母的奇偶性**
    
    - 若 `c` 已在 `hash`，表示該字符出現偶數次，則**刪除**（`del hash[c]`）。
    - 若 `c` **不在 `hash`**，表示目前該字符出現奇數次，則加入 `hash`。
2. **計算 `remove`（剩下 `hash` 中的奇數字符數量）**
    
    - `hash` 內的鍵代表出現**奇數次數**的字符個數。
    - 若有 `remove > 0`，則我們**最多只能移除 `remove - 1` 個奇數次字符**，保留一個作為回文的中心。
3. **計算最長回文長度**
    
    - `len(s) - remove` 為可構成的回文長度。

---

## **範例解析**

### **範例 1**

`s = "abccccdd"`

**步驟**

|`i`|`c`|`hash` 狀態|說明|
|---|---|---|---|
|0|`a`|`{a}`|`a` 第一次出現，加入 `hash`|
|1|`b`|`{a, b}`|`b` 第一次出現，加入 `hash`|
|2|`c`|`{a, b, c}`|`c` 第一次出現，加入 `hash`|
|3|`c`|`{a, b}`|`c` 第二次出現，刪除|
|4|`c`|`{a, b, c}`|`c` 第三次出現，加入|
|5|`c`|`{a, b}`|`c` 第四次出現，刪除|
|6|`d`|`{a, b, d}`|`d` 第一次出現，加入|
|7|`d`|`{a, b}`|`d` 第二次出現，刪除|

- **`hash = {a, b}`**（表示 `a` 和 `b` 出現奇數次）。
- **`remove = 2`**（代表 `a` 和 `b`）。
- **可保留一個奇數字符，則 `remove -= 1`，所以 `remove = 1`**。
- **最長回文長度 = `len(s) - remove = 8 - 1 = 7`**。

**結果**：`7`（可形成 `"dccaccd"` 或 `"dccbccd"`）

---

### **範例 2**

python

複製編輯

`s = "abc"`

**步驟**

|`i`|`c`|`hash` 狀態|說明|
|---|---|---|---|
|0|`a`|`{a}`|`a` 第一次出現，加入 `hash`|
|1|`b`|`{a, b}`|`b` 第一次出現，加入 `hash`|
|2|`c`|`{a, b, c}`|`c` 第一次出現，加入 `hash`|

- **`hash = {a, b, c}`**（全部出現奇數次）。
- **`remove = 3`**（所有字符都是奇數次）。
- **最多只能保留一個，則 `remove = 3 - 1 = 2`**。
- **最長回文長度 = `len(s) - remove = 3 - 2 = 1`**。

**結果**：`1`（可形成 `"a"`, `"b"` 或 `"c"`）

---

## **時間與空間複雜度分析**

- **時間複雜度**
    
    - **遍歷 `s`**：`O(n)`
    - **檢查 `hash` 字典**：`O(1)`（因為最多 26 個英文字母）
    - **總體時間複雜度：`O(n)`**
- **空間複雜度**
    
    - `hash` 最多存 26 個字母，視為常數空間 `O(1)`。
    - **總體空間複雜度：`O(1)`**

---

## **其他解法想法（不含代碼）**

4. **使用 `Counter` 計數字母頻率**
```python
    def longestPalindrome(self, s):
        # write your code here
        n = len(s)
        if not s:
            return 0
        count = Counter(s)
        ans = 0
        for k in count.values():
            if k % 2 == 0:
                ans += k
            else:
                ans += k - 1
        return ans if ans == n else ans + 1
```
    - 遍歷 `s` 建立 `Counter`
    - 遍歷 `Counter` 計算所有偶數部分與最多保留一個奇數部分
    - 時間 `O(n)`，空間 `O(1)`
5. **陣列計數 (`O(n)`)**
    
    - 用大小 `26` 的陣列存字母頻率
    - 和 `Counter` 方法類似，但更節省記憶體（因為不需要存字母鍵）
6. **暴力檢查所有排列 (`O(n!)`)**
    
    - 產生所有 `s` 的排列，檢查是否為回文
    - 明顯不可行，時間 `O(n!)`

---

## **結論**

- **最優解法**：使用 **`hash` 記錄奇偶性 (`O(n)`)**，省去完整字母計數，**空間 `O(1)`**。
- **可替代方法**：
    - **`Counter` 計數法 (`O(n)`)**：較直觀但需遍歷 `Counter`
    - **陣列計數法 (`O(n)`)**：類似 `Counter`，但空間更節省
    - **暴力檢查 (`O(n!)`)**：不適用

本題的 **字典奇偶法 (`O(n)`)** 是最佳方法，因為它 **只需一次遍歷，且不需要完整存儲字母頻率**，適用於大規模輸入。