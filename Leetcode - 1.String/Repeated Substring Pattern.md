Lintcode 1227
给你一个非空字符串，判断它能否通过重复它的某一个子串若干次（两次及以上）得到。字符串由小写字母组成，并且它的长度不会超过10000。

**样例1：**
```python
"""
输入："abab"

输出：True

说明：可以由它的子串"ab"重复两次得到。
```
**样例2：**
```python
"""
输入："aba"

输出：False
```
**样例3：**
```python
"""
输入："abcabcabcabc"

输出：True

说明：可以由它的子串"abc"重复四次得到（同时也可以是"abcabc"重复两次）。
```


```python
    def repeated_substring_pattern(self, s: str) -> bool:
        l = len(s)
        next = [-1 for i in range(l)]
        j = -1
        for i in range(1, l):
            while j >= 0 and s[i] != s[j + 1]:
                j = next[j]
            if s[i] == s[j + 1]:
                j += 1
            next[i] = j
        lenSub = l - 1 - next[l - 1]
        return lenSub != l and l % lenSub ==0
```
pass
s = "abab"
解釋:
step1: 先create 空的next list裡面是-1  [ -1, -1, -1, -1 ]




本題 **`repeated_substring_pattern(self, s: str) -> bool`** 的目標是判斷 `s` 是否可以由其某個子字串 **重複多次組成**。

例如：

- `"abab"` → `True`（由 `"ab"` 重複 2 次組成）
- `"abcabcabc"` → `True`（由 `"abc"` 重複 3 次組成）
- `"aba"` → `False`（無法由某個子串重複組成）

---

## **解法說明：KMP 前綴函數**

此解法基於 **KMP (Knuth-Morris-Pratt) 演算法**，主要運用了 **前綴函數 (`next` 陣列)** 來找出 `s` 最長的**相同前綴後綴**，進而判斷 `s` 是否是某個子字串的重複。

### **核心概念**

1. **KMP 前綴函數（`next` 陣列）**
    
    - `next[i]` 表示 `s[0:i+1]` 的最長相同**前綴後綴**的長度減 `1`。
    - **例：**
        - `s = "abcabc"` → `next = [-1, -1, -1, 0, 1, 2]`
        - `s = "abab"` → `next = [-1, -1, 0, 1]`
    - `next[l-1]` 的值告訴我們 `s` 可以匹配的最長 **前綴 == 後綴** 的長度。
2. **判斷重複子串的條件**
    
    - 計算**可能的最小重複子串長度**： lenSub=l−1−next[l−1]\text{lenSub} = l - 1 - \text{next}[l-1]lenSub=l−1−next[l−1]
    - 若 `lenSub` 能夠整除 `l`，則表示 `s` 是某個子串的重複組合： l%lenSub==0l \% \text{lenSub} == 0l%lenSub==0

---

## **變數表**

|變數名稱|含義|
|---|---|
|`l`|字符串 `s` 的長度|
|`next`|KMP 前綴函數陣列 (`next[i]` 表示 `s[0:i+1]` 的最長相同前綴後綴長度減 `1`)|
|`j`|當前匹配的前綴索引|
|`i`|當前遍歷的 `s` 字符索引|
|`lenSub`|可能的最小重複子串長度|

---

## **具體步驟**

### **Step 1: 計算 `next` 陣列**

- 使用 **KMP 前綴函數**：
    - 若 `s[i] == s[j+1]`，則 `j++`，並更新 `next[i] = j`
    - 否則使用 `j = next[j]` 回溯

### **Step 2: 計算 `lenSub`**

- `lenSub = l - 1 - next[l-1]`
- 若 `lenSub != l` 且 `l % lenSub == 0`，則返回 `True`，否則返回 `False`

---

## **範例解析**

### **範例 1**

`s = "abab"`

**步驟**

1. **計算 `next` 陣列**
    - `next = [-1, -1, 0, 1]`
2. **計算 `lenSub`**
    - `lenSub = 4 - 1 - 1 = 2`
    - `4 % 2 == 0` → `True`

**結果**：`True`（"abab" 由 "ab" 重複 2 次組成）

---

### **範例 2**

`s = "aba"`

**步驟**

1. **計算 `next` 陣列**
    - `next = [-1, -1, -1]`
2. **計算 `lenSub`**
    - `lenSub = 3 - 1 - (-1) = 3`
    - `3 % 3 == 0` 但 `lenSub == l` → `False`

**結果**：`False`（"aba" 不能由子串重複組成）

---

### **範例 3**

`s = "abcabcabc"`

**步驟**

1. **計算 `next` 陣列**
    - `next = [-1, -1, -1, 0, 1, 2, 3, 4, 5]`
2. **計算 `lenSub`**
    - `lenSub = 9 - 1 - 5 = 3`
    - `9 % 3 == 0` → `True`

**結果**：`True`（"abcabcabc" 由 "abc" 重複 3 次組成）

---

## **時間與空間複雜度分析**

- **時間複雜度**
    - **計算 `next` 陣列：`O(n)`**
    - **最終判斷 (`lenSub` 及 `l % lenSub`)：`O(1)`**
    - **總體時間複雜度：`O(n)`**
- **空間複雜度**
    - 只使用一個 `next` 陣列 **`O(n)`**，但如果允許修改 `s`，可以減少到 **`O(1)`**。

---

## **其他解法想法（不含代碼）**

1. **暴力法 (`O(n^2)`)**
    
    - 枚舉所有可能的 `lenSub`，檢查 `s` 是否可以由 `s[:lenSub]` 重複組成
    - **時間複雜度太高，不適用於大 `n`**
2. **雙倍字符串技巧 (`O(n)`)**
    
    - `s + s` 去掉首尾，若 `s` 在新字串中仍然出現，則 `s` 是重複子串
    - **簡潔但較難理解**
3. **Z-Algorithm (`O(n)`)**
    
    - 計算 `s` 的 **Z 函數**，找出最小的重複單元
    - 與 KMP 方法類似，但較少使用

---

## **結論**

- **最佳方法**：**KMP 前綴函數 (`O(n)`)**，利用 `next` 陣列找到 `s` 的最長前綴後綴，計算可能的 `lenSub`，並判斷 `l % lenSub == 0`。
- **可替代方法**：
    - **雙倍字符串技巧 (`O(n)`)**：更簡潔但不直觀。
    - **暴力法 (`O(n^2)`)**：不可行。
    - **Z-Algorithm (`O(n)`)**：較少使用。





好的，我們以 `s = "abab"` 這個具體的例子，來詳細說明 Lintcode 1227 問題程式碼中 KMP 前綴函數 `next` 陣列的計算過程及其涵義。

**1. KMP 前綴函數 (`next` 陣列) 的基本概念**

在 KMP 演算法中，`next` 陣列（也常被稱為 `pi` 陣列或 lps - Longest Proper Prefix which is also Suffix 陣列）是一個至關重要的輔助陣列。它的目的是預先計算模式字串（在這裡，我們將輸入字串 `s` 本身視為模式字串）的內部結構資訊。

`next[i]` 儲存的是：字串 `s` 從開頭到索引 `i` 的子字串 `s[0...i]` 中，它**最長**的、**相等**的「真前綴」和「真後綴」中的那個**前綴**的**最後一個字元的索引**。

- **真前綴 (Proper Prefix):** 指不等於字串本身的所有前綴。
- **真後綴 (Proper Suffix):** 指不等於字串本身的所有後綴。
- **公共 (Common):** 指前綴和後綴的內容必須相同。
- **最長 (Longest):** 在所有符合條件的公共真前後綴中，取長度最長的那一個。
- **儲存索引:** 這個特定程式碼的 `next[i]` 存的是這個最長前綴的**結束索引 `j`**。因此，這個最長公共真前後綴的**長度**實際上是 `j + 1` (因為索引從 0 開始)。如果沒有公共真前後綴，長度為 0，程式碼中用索引 `-1` 來表示。

**2. 以 `s = "abab"` 計算 `next` 陣列**

- **輸入:** `s = "abab"` (長度 `l = 4`)
- **初始化:** `next = [-1, -1, -1, -1]`, `j = -1`

**逐步計算:**

- **`i = 0`:**
    
    - 子字串 `s[0...0]` 是 `"a"`。
    - 真前綴：{} (空集合)
    - 真後綴：{} (空集合)
    - 最長公共真前後綴：空字串，長度 0。
    - 程式碼將 `next[0]` 設為 `-1` (表示空，長度為 0)。
    - `next` 陣列: `[-1, -1, -1, -1]`
- **`i = 1`:**
    
    - 子字串 `s[0...1]` 是 `"ab"`。
    - 真前綴：{"a"}
    - 真後綴：{"b"}
    - 兩者沒有交集。
    - 最長公共真前後綴：空字串，長度 0。
    - 程式碼計算後（'b' != 'a'），`j` 保持 -1，`next[1]` 設為 `-1`。
    - `next` 陣列: `[-1, -1, -1, -1]`
- **`i = 2`:**
    
    - 子字串 `s[0...2]` 是 `"aba"`。
    - 真前綴：{"a", "ab"}
    - 真後綴：{"a", "ba"}
    - 兩者的交集是 {"a"}。
    - 最長公共真前後綴：是 `"a"`，長度為 1。
    - 這個前綴 `"a"` 的結束索引是 0。
    - 程式碼計算後（'a' == 'a'），`j` 變為 0，`next[2]` 設為 `0`。
    - `next` 陣列: `[-1, -1, 0, -1]`
- **`i = 3`:**
    
    - 子字串 `s[0...3]` 是 `"abab"`。
    - 真前綴：{"a", "ab", "aba"}
    - 真後綴：{"b", "ab", "bab"}
    - 兩者的交集是 {"ab"}。
    - 最長公共真前後綴：是 `"ab"`，長度為 2。
    - 這個前綴 `"ab"` 的結束索引是 1。
    - 程式碼計算後（'b' == 'b'），`j` 變為 1，`next[3]` 設為 `1`。
    - `next` 陣列: `[-1, -1, 0, 1]`

**3. 計算完成的 `next` 陣列及其涵義**

對於 `s = "abab"`，最終計算得到的 `next` 陣列是 `[-1, -1, 0, 1]`。

- `next[0] = -1`: 對於子字串 "a"，最長公共真前後綴長度為 0。
- `next[1] = -1`: 對於子字串 "ab"，最長公共真前後綴長度為 0。
- `next[2] = 0`: 對於子字串 "aba"，最長公共真前後綴是 "a"，長度為 `0 + 1 = 1`。前綴結束索引為 0。
- `next[3] = 1`: 對於子字串 "abab"，最長公共真前後綴是 "ab"，長度為 `1 + 1 = 2`。前綴結束索引為 1。

**4. `next` 陣列與重複子串問題的關係**

`next` 陣列記錄了字串內部前綴和後綴的重複/對稱信息。特別是 `next[l-1]`，它告訴我們整個字串 `s` 的開頭和結尾有多大程度上的重疊（即最長公共真前後綴）。

在判斷重複子串問題時，這個 `next[l-1]` 的值至關重要：

- 最長公共真前後綴的長度是 `LPS_len = next[l-1] + 1`。
- 如果字串 `s` 是由某個子串 `sub` 重複構成的，那麼這個 `sub` 的長度很可能就是 `lenSub = l - LPS_len`。
- 在 "abab" 的例子中，`l=4`，`next[3]=1`，所以 `LPS_len = 1 + 1 = 2`。那麼潛在的重複子串長度 `lenSub = 4 - 2 = 2`。
- 接下來程式碼會驗證 `lenSub` 是否小於 `l` (2 < 4) 並且 `l` 是否能被 `lenSub` 整除 (4 % 2 == 0)。如果都滿足，就說明 "abab" 確實是由長度為 2 的子串 ("ab") 重複構成的。

總之，`next` 陣列通過記錄字串每個前綴子串的自我匹配信息，為高效判斷整個字串是否由重複子串構成提供了關鍵依據。