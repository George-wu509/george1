Lintcode 1227
给你一个非空字符串，判断它能否通过重复它的某一个子串若干次（两次及以上）得到。字符串由小写字母组成，并且它的长度不会超过10000。

**样例1：**
```python
"""
输入："abab"

输出：True

说明：可以由它的子串"ab"重复两次得到。
```
**样例2：**
```python
"""
输入："aba"

输出：False
```
**样例3：**
```python
"""
输入："abcabcabcabc"

输出：True

说明：可以由它的子串"abc"重复四次得到（同时也可以是"abcabc"重复两次）。
```


```python
    def repeated_substring_pattern(self, s: str) -> bool:
        l = len(s)
        next = [-1 for i in range(l)]
        j = -1
        for i in range(1, l):
            while j >= 0 and s[i] != s[j + 1]:
                j = next[j]
            if s[i] == s[j + 1]:
                j += 1
            next[i] = j
        lenSub = l - 1 - next[l - 1]
        return lenSub != l and l % lenSub ==0
```
pass


本題 **`repeated_substring_pattern(self, s: str) -> bool`** 的目標是判斷 `s` 是否可以由其某個子字串 **重複多次組成**。

例如：

- `"abab"` → `True`（由 `"ab"` 重複 2 次組成）
- `"abcabcabc"` → `True`（由 `"abc"` 重複 3 次組成）
- `"aba"` → `False`（無法由某個子串重複組成）

---

## **解法說明：KMP 前綴函數**

此解法基於 **KMP (Knuth-Morris-Pratt) 演算法**，主要運用了 **前綴函數 (`next` 陣列)** 來找出 `s` 最長的**相同前綴後綴**，進而判斷 `s` 是否是某個子字串的重複。

### **核心概念**

1. **KMP 前綴函數（`next` 陣列）**
    
    - `next[i]` 表示 `s[0:i+1]` 的最長相同**前綴後綴**的長度減 `1`。
    - **例：**
        - `s = "abcabc"` → `next = [-1, -1, -1, 0, 1, 2]`
        - `s = "abab"` → `next = [-1, -1, 0, 1]`
    - `next[l-1]` 的值告訴我們 `s` 可以匹配的最長 **前綴 == 後綴** 的長度。
2. **判斷重複子串的條件**
    
    - 計算**可能的最小重複子串長度**： lenSub=l−1−next[l−1]\text{lenSub} = l - 1 - \text{next}[l-1]lenSub=l−1−next[l−1]
    - 若 `lenSub` 能夠整除 `l`，則表示 `s` 是某個子串的重複組合： l%lenSub==0l \% \text{lenSub} == 0l%lenSub==0

---

## **變數表**

|變數名稱|含義|
|---|---|
|`l`|字符串 `s` 的長度|
|`next`|KMP 前綴函數陣列 (`next[i]` 表示 `s[0:i+1]` 的最長相同前綴後綴長度減 `1`)|
|`j`|當前匹配的前綴索引|
|`i`|當前遍歷的 `s` 字符索引|
|`lenSub`|可能的最小重複子串長度|

---

## **具體步驟**

### **Step 1: 計算 `next` 陣列**

- 使用 **KMP 前綴函數**：
    - 若 `s[i] == s[j+1]`，則 `j++`，並更新 `next[i] = j`
    - 否則使用 `j = next[j]` 回溯

### **Step 2: 計算 `lenSub`**

- `lenSub = l - 1 - next[l-1]`
- 若 `lenSub != l` 且 `l % lenSub == 0`，則返回 `True`，否則返回 `False`

---

## **範例解析**

### **範例 1**

`s = "abab"`

**步驟**

1. **計算 `next` 陣列**
    - `next = [-1, -1, 0, 1]`
2. **計算 `lenSub`**
    - `lenSub = 4 - 1 - 1 = 2`
    - `4 % 2 == 0` → `True`

**結果**：`True`（"abab" 由 "ab" 重複 2 次組成）

---

### **範例 2**

`s = "aba"`

**步驟**

1. **計算 `next` 陣列**
    - `next = [-1, -1, -1]`
2. **計算 `lenSub`**
    - `lenSub = 3 - 1 - (-1) = 3`
    - `3 % 3 == 0` 但 `lenSub == l` → `False`

**結果**：`False`（"aba" 不能由子串重複組成）

---

### **範例 3**

`s = "abcabcabc"`

**步驟**

1. **計算 `next` 陣列**
    - `next = [-1, -1, -1, 0, 1, 2, 3, 4, 5]`
2. **計算 `lenSub`**
    - `lenSub = 9 - 1 - 5 = 3`
    - `9 % 3 == 0` → `True`

**結果**：`True`（"abcabcabc" 由 "abc" 重複 3 次組成）

---

## **時間與空間複雜度分析**

- **時間複雜度**
    - **計算 `next` 陣列：`O(n)`**
    - **最終判斷 (`lenSub` 及 `l % lenSub`)：`O(1)`**
    - **總體時間複雜度：`O(n)`**
- **空間複雜度**
    - 只使用一個 `next` 陣列 **`O(n)`**，但如果允許修改 `s`，可以減少到 **`O(1)`**。

---

## **其他解法想法（不含代碼）**

1. **暴力法 (`O(n^2)`)**
    
    - 枚舉所有可能的 `lenSub`，檢查 `s` 是否可以由 `s[:lenSub]` 重複組成
    - **時間複雜度太高，不適用於大 `n`**
2. **雙倍字符串技巧 (`O(n)`)**
    
    - `s + s` 去掉首尾，若 `s` 在新字串中仍然出現，則 `s` 是重複子串
    - **簡潔但較難理解**
3. **Z-Algorithm (`O(n)`)**
    
    - 計算 `s` 的 **Z 函數**，找出最小的重複單元
    - 與 KMP 方法類似，但較少使用

---

## **結論**

- **最佳方法**：**KMP 前綴函數 (`O(n)`)**，利用 `next` 陣列找到 `s` 的最長前綴後綴，計算可能的 `lenSub`，並判斷 `l % lenSub == 0`。
- **可替代方法**：
    - **雙倍字符串技巧 (`O(n)`)**：更簡潔但不直觀。
    - **暴力法 (`O(n^2)`)**：不可行。
    - **Z-Algorithm (`O(n)`)**：較少使用。