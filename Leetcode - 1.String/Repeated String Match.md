Lintcode 1086
给定两个字符串A和B，找到A必须重复的最小次数，以使得B是它的子字符串。 如果没有这样的解决方案，返回-1。

**样例1:**
```python
输入 : A = "a"     B = "b".
输出 : -1
```
**样例 2:**
```python
输入 : A = "abcd"     B = "cdabcdab".
输出 :3
解释：因为将A重复3次以后 (“abcdabcdabcd”), B将成为其的一个子串 ; 而如果A只重复两次 ("abcdabcd")，B并非其的一个子串.
```


```python
class Solution:
    def strstr(self, haystack: str, needle: str) -> int:
        n, m = len(haystack), len(needle)
        if m == 0:
            return 0

        k1 = 10 ** 9 + 7
        k2 = 1337
        mod1 = random.randrange(k1) + k1
        mod2 = random.randrange(k2) + k2

        hash_needle = 0
        for c in needle:
            hash_needle = (hash_needle * mod2 + ord(c)) % mod1
        hash_haystack = 0
        for i in range(m - 1):
            hash_haystack = (hash_haystack * mod2 + ord(haystack[i % n])) % mod1
        extra = pow(mod2, m - 1, mod1)
        for i in range(m - 1, n + m - 1):
            hash_haystack = (hash_haystack * mod2 + ord(haystack[i % n])) % mod1
            if hash_haystack == hash_needle:
                return i - m + 1
            hash_haystack = (hash_haystack - extra * ord(haystack[(i - m + 1) % n])) % mod1
            hash_haystack = (hash_haystack + mod1) % mod1
        return -1

    def repeated_string_match(self, a: str, b: str) -> int:
        # write your code here
        n, m = len(a), len(b)
        index = self.strstr(a, b)
        if index == -1:
            return -1
        if n - index >= m:
            return 1
        return (m + index - n - 1) // n + 2
```
pass
解釋:
step1: 檢查原始a是否符合b是a的子串, 用strstr() function檢查(也可以用find())
step2: 如果不是則重複a 然後再檢查一次, 直到符合


|                                     |     |
| ----------------------------------- | --- |
| [[###解題思路簡述如下]]                     |     |
| [[###比較基於雜湊的 `strstr` 函數跟內建find()]] |     |


本題 **`repeated_string_match(self, a: str, b: str) -> int`** 的目標是找出，最少要將 `a` 重複幾次，才能讓 `b` 成為 `a` 的子字串。

### **核心觀察**

1. **最小重複次數界限**
    
    - `a` 最少需要重複 ⌈`len(b) / len(a)`⌉ 次，才能完全覆蓋 `b` 的長度。
    - 但因為 `b` 可能跨越 `a` 的尾部和頭部，因此最多要重複 **1 次額外的 `a`** 才能確認。
2. **子字串搜尋**
    
    - 需要檢查 `b` 是否是 `a` 重複若干次後的**子字串** (`substring`)。
3. **使用 Rabin-Karp 字符串哈希加速匹配**
    
    - 計算 `b` 的哈希值，並在 `a` 重複後的字串中 **使用滾動哈希進行搜索**。

---

## **變數表**

|變數名稱|含義|
|---|---|
|`a, b`|兩個輸入字符串|
|`n, m`|`a` 和 `b` 的長度|
|`index`|`b` 在 `a` 重複後的索引位置（使用 `strstr` 搜索）|
|`mod1, mod2`|Rabin-Karp 滾動哈希的兩個大質數|
|`hash_needle`|`b` (needle) 的哈希值|
|`hash_haystack`|`a` (haystack) 當前滑動窗口的哈希值|
|`extra`|`mod2^(m-1) % mod1`，用於移除最左側字符的影響|

---

## **具體步驟**

### **Step 1: 用 Rabin-Karp 計算 `b` 的哈希值**

- 逐個字符計算 `b` (`needle`) 的哈希值 `hash_needle`。

### **Step 2: 使用滾動哈希在 `a` 重複後的字串中搜尋 `b`**

- 計算 `a` 的前 `m-1` 個字符的哈希值 `hash_haystack`。
- 透過 **滑動窗口** 移動 `hash_haystack`，檢查是否匹配 `hash_needle`。
- 若匹配成功，則返回索引 `index`。

### **Step 3: 計算 `a` 需要重複的次數**

- **如果 `index == -1`**，則 `b` 無法出現在 `a` 重複後的字串中，返回 `-1`。
- 否則，根據 `index` 計算 `a` 需要重複的次數：
    - 若 `n - index >= m`，說明 `b` 已經完全包含在 `a` 本身中，只需 `1` 次。
    - 否則計算 `(m + index - n - 1) // n + 2`，確保 `b` 可以被完全覆蓋。

---

## **範例解析**

### **範例 1**

python

複製編輯

`a = "abcd" b = "cdabcdab"`

#### **Step 1: 滾動哈希搜尋 `b`**

- `b = "cdabcdab"` 的哈希值：計算 `hash_needle`
- `a + a + a = "abcdabcdabcd"`，檢查 `b` 是否存在

|`i`|`hash_haystack`|是否匹配 `hash_needle`|
|---|---|---|
|0|不匹配|❌|
|1|不匹配|❌|
|2|匹配 `"cdabcdab"`|✅|

- `index = 2`

#### **Step 2: 計算 `a` 需要重複的次數**

- `len(b) = 7`，`len(a) = 4`
- `n - index = 4 - 2 = 2 < 7`（`b` 超出 `a`）
- 需要至少 `2` 次 `a`，再額外加 `1` 次以完全覆蓋。

**結果**：`3`

---

### **範例 2**

python

複製編輯

`a = "abc" b = "cabcabca"`

#### **Step 1: 滾動哈希搜尋 `b`**

- `b = "cabcabca"` 的哈希值：計算 `hash_needle`
- `a + a + a = "abcabcabc"`，檢查 `b` 是否存在

|`i`|`hash_haystack`|是否匹配 `hash_needle`|
|---|---|---|
|0|不匹配|❌|
|1|不匹配|❌|
|2|匹配 `"cabcabca"`|✅|

- `index = 2`

#### **Step 2: 計算 `a` 需要重複的次數**

- `len(b) = 8`，`len(a) = 3`
- `n - index = 3 - 2 = 1 < 8`
- 至少 `3` 次 `a` 覆蓋 `b`。

**結果**：`3`

---

## **時間與空間複雜度分析**

- **`strstr()` 使用 Rabin-Karp 滾動哈希**
    
    - **計算 `hash_needle` 和 `hash_haystack`：`O(m)`**
    - **滑動哈希搜索：`O(n + m)`**
    - **總體 `O(n + m)`**
- **`repeated_string_match()`**
    
    - `strstr(a, b)` 的時間複雜度為 `O(n + m)`
    - 計算重複次數為 `O(1)`
    - **總體 `O(n + m)`**
- **空間複雜度**
    
    - `O(1)`，只使用了常數變數來計算哈希

---

## **其他解法想法（不含代碼）**

4. **暴力法 (`O(n * m)`)**
    
    - 直接在 `a` 重複多次後的字串中搜尋 `b`
    - 時間複雜度高，對大 `n, m` 不適用
5. **KMP (`O(n + m)`)**
    
    - 計算 `b` 的 KMP 前綴函數，然後用 KMP 在 `a` 重複後的字串中搜尋 `b`
    - 與 Rabin-Karp 方法類似，但在某些情況下更快
6. **使用 `b in (a * k)` 判斷 (`O(n + m)`)**
    
    - 直接構造 `a * k`，然後用 `"b in (a * k)"` 判斷 `b` 是否存在
    - 簡單但記憶體消耗較大

---

## **結論**

- **最佳解法**：Rabin-Karp (`O(n + m)`)
    - **利用滾動哈希高效匹配 `b`**
    - **只需遍歷 `a` 和 `b` 一次**
- **其他方法**
    - **KMP (`O(n + m)`)**：可行但較複雜
    - **暴力搜尋 (`O(n * m)`)**：不可行
    - **直接構造 `(a * k)` 再判斷 (`O(n + m)`)**：簡單但占用較多記憶體

本解法 **能夠高效找到 `b` 在 `a` 重複後的最小次數，並且避免暴力搜尋的效能問題**。



### 解題思路簡述如下

1. **判斷 `b` 是否為 `a` 的子字串：** 先使用 `strstr` 函數判斷字串 `b` 是否已經是字串 `a` 的子字串。如果 `b` 是 `a` 的子字串，那麼 `a` 只需要重複一次（或零次，如果 `b` 為空），所以直接回傳 `1`（或 `0`，根據 `strstr` 的實作）。
    
2. **處理 `b` 比 `a` 長的情況：** 如果 `b` 不是 `a` 的子字串，我們需要考慮重複 `a`。為了讓 `b` 成為重複後的 `a` 的子字串，重複後的 `a` 的長度至少要大於或等於 `b` 的長度。
    
3. **重複 `a` 並檢查：** 我們可以逐步重複 `a`，並在每次重複後檢查 `b` 是否為其子字串。然而，更有效率的做法是考慮 `b` 在重複後的 `a` 中可能出現的位置。
    
4. **計算最小重複次數：**
    
    - 如果 `b` 在第一次重複的 `a` 中出現（`index != -1` 且 `n - index >= m`），則答案是 `1`。
    - 如果 `b` 的一部分在第一次的 `a` 的尾部，一部分在第二次的 `a` 的頭部，那麼重複次數至少是 `2`。
    - 更一般地，如果 `b` 的起始位置 `index` 使得剩餘的 `a` 的長度 (`n - index`) 小於 `b` 的長度 `m`，那麼我們需要額外的重複。我們可以計算出需要的額外重複次數，使得總長度足夠包含 `b`。公式 `(m + index - n - 1) // n + 2` 可以計算出這個最小重複次數。這裡 `+2` 是因為第一次的 `a` 已經存在，而我們需要至少一次額外的完整重複來覆蓋 `b` 的剩餘部分，並且可能需要再多一次來處理跨越兩個完整 `a` 的情況。
5. **`strstr` 函數的說明：** 提供的 `strstr` 函數使用基於雜湊的演算法（Rabin-Karp 的變體）來尋找子字串。它計算 `needle` 的雜湊值，然後在 `haystack` 的滑動視窗中計算雜湊值並進行比較。這種方法在平均情況下有較好的效率，但需要注意雜湊碰撞的可能性。在這個特定的問題中，`strstr` 用於判斷 `b` 是否為 `a` 的子字串，並找出其起始索引。
    

總而言之，解題思路是先判斷 `b` 是否已是 `a` 的子字串，如果不是，則通過計算和考量 `b` 可能跨越重複 `a` 的情況，找出使得 `b` 成為子字串的最小重複次數。`strstr` 函數在這裡作為一個輔助工具，用於判斷子字串關係和尋找起始位置。



### 比較基於雜湊的 `strstr` 函數跟內建find()

比較一下您提供的基於雜湊的 `strstr` 函數（Rabin-Karp 的變體）和 Python 內建的字串 `find()` 方法在尋找子字串方面的差異：

**基於雜湊的 `strstr` 函數 (Rabin-Karp 變體):**

- **原理:**
    
    - 計算目標子字串 (`needle`) 的雜湊值。
    - 在主字串 (`haystack`) 中滑動一個與 `needle` 長度相同的視窗，並計算每個視窗的雜湊值。
    - 如果視窗的雜湊值與 `needle` 的雜湊值相等，則可能找到了匹配的子字串。為了避免雜湊碰撞（不同的字串可能具有相同的雜湊值），通常需要進行額外的字元比對來驗證是否真正匹配。
    - 您提供的程式碼中使用了兩個模數 (`mod1`, `mod2`) 來降低雜湊碰撞的機率。
- **時間複雜度:**
    
    - **平均情況:** O(n + m)，其中 n 是 `haystack` 的長度，m 是 `needle` 的長度。計算雜湊值和滑動視窗是 O(n)，計算 `needle` 的雜湊值是 O(m)。
    - **最壞情況:** O(n * m)。當雜湊碰撞頻繁發生時，每次雜湊值匹配後都需要 O(m) 的字元比較。
- **空間複雜度:** O(1)，只需要常數的額外空間來儲存雜湊值和其他變數。
    
- **優點:**
    
    - 在平均情況下效率較高，特別是當 `needle` 較短時。
    - 可以擴展到處理更複雜的模式匹配問題。
- **缺點:**
    
    - 存在雜湊碰撞的風險，最壞情況下效能會退化。
    - 實作相對複雜，需要仔細選擇雜湊函數和模數以減少碰撞。

**Python `string.find()` 方法:**

- **原理:**
    
    - Python 的 `find()` 方法通常使用更直接的字串匹配演算法，例如滑動視窗並逐個字元比較。
    - 具體的底層實現是 C 語言，並且可能經過高度優化，不同的 Python 版本或底層庫可能採用不同的演算法（例如，Boyer-Moore 的變體）。
- **時間複雜度:**
    
    - **平均情況:** 通常接近 O(n * m) 或在某些優化實現下更好。
    - **最壞情況:** O(n * m)。例如，在 `haystack` 是 "aaaaaaaaab" 且 `needle` 是 "aaab" 的情況下。然而，Python 的實作通常會包含一些啟發式方法來優化常見情況。
- **空間複雜度:** O(1)，只需要常數的額外空間。
    
- **優點:**
    
    - 實作簡單易懂，直接使用 Python 內建功能。
    - 通常經過高度優化，在實際應用中表現良好。
    - 沒有雜湊碰撞的風險，結果總是準確的。
- **缺點:**
    
    - 在某些特定情況下，理論上的時間複雜度可能比 Rabin-Karp 的平均情況差一些。

**總結比較:**

|特性|基於雜湊的 `strstr` (Rabin-Karp)|Python `string.find()`|
|---|---|---|
|**原理**|雜湊值比較 + 字元驗證|直接字串比較|
|**平均時間複雜度**|O(n + m)|通常接近 O(n * m) 或更好|
|**最壞時間複雜度**|O(n * m)|O(n * m)|
|**空間複雜度**|O(1)|O(1)|
|**雜湊碰撞風險**|有|無|
|**實作複雜度**|較高|極低|
|**準確性**|需要額外驗證以避免碰撞|總是準確|
|**易用性**|較低|極高|

**何時使用哪種方法:**

- **Python `string.find()`:** 在絕大多數情況下，這是更推薦的方法。它簡單易用，且 Python 的內建實作通常已經足夠高效。由於沒有雜湊碰撞的風險，結果也更可靠。
    
- **基於雜湊的 `strstr` (Rabin-Karp):**
    
    - 當需要處理大量的模式匹配查詢時，預先計算模式的雜湊值可能會有優勢。
    - 在某些特定的演算法或資料結構中，雜湊技術是核心部分。
    - 在學術研究或需要深入理解字串匹配演算法的場景下。

**關於您提供的 `strstr` 函數:**

您提供的 `strstr` 函數實作了 Rabin-Karp 的基本思想，使用了兩個模數來降低碰撞機率。它在計算雜湊值的過程中使用了滑動視窗的技巧，避免了重複計算。然而，它仍然需要仔細的設計和測試以確保在各種情況下都能正確高效地工作，並且處理潛在的雜湊碰撞。

總之，對於一般的子字串查找任務，Python 內建的 `find()` 方法通常是更簡潔、更可靠且通常也足夠高效的選擇。基於雜湊的方法在特定場景下可能具有理論上的優勢，但需要更謹慎的實作。



