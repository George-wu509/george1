Lintcode 1425
给定 `S` 和 `T` 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 `#` 代表退格字符。

**样例 1：**
```python
"""
输入：S = "ab#c", T = "ad#c"
输出：true
解释：S 和 T 都会变成 “ac”。
```
**样例 2：**
```python
"""
输入：S = "ab##", T = "c#d#"
输出：true
解释：S 和 T 都会变成 “”。
```
**样例 3：**
```python
"""
输入：S = "a##c", T = "#a#c"
输出：true
解释：S 和 T 都会变成 “c”。
```
**示例 4：**
```python
"""
输入：S = "a#c", T = "b"
输出：false
解释：S 会变成 “c”，但 T 仍然是 “b”。
```


```python
def backspace_compare(self, s: str, t: str) -> bool:
	i, j = len(s) - 1, len(t) - 1
	skipS = skipT = 0

	while i >= 0 or j >= 0:
		while i >= 0:
			if s[i] == "#":
				skipS += 1
				i -= 1
			elif skipS > 0:
				skipS -= 1
				i -= 1
			else:
				break
		while j >= 0:
			if t[j] == "#":
				skipT += 1
				j -= 1
			elif skipT > 0:
				skipT -= 1
				j -= 1
			else:
				break
		if i >= 0 and j >= 0:
			if s[i] != t[j]:
				return False
		elif i >= 0 or j >= 0:
			return False
		i -= 1
		j -= 1

	return True
```
pass

本題 **`backspace_compare(self, s: str, t: str) -> bool`** 目標是：

- **判斷兩個包含 `#` (退格符) 的字串 `s` 和 `t`，最終的實際內容是否相等**。

---

## **解法分析**

### **核心想法**

1. **從後往前遍歷 `s` 和 `t`**
    
    - `#` 代表刪除前一個字符，因此可以 **從後往前** 處理 `#`，這樣我們可以直接跳過被刪除的字母，而不用真正構造新字串。
2. **使用 `skipS` 和 `skipT` 來記錄 `#` 的數量**
    
    - 當 `s[i] == '#'` 時，`skipS` 增加 1，並繼續向前移動 `i`。
    - 若 `skipS > 0`，則跳過當前字母（刪除效果），並將 `skipS -= 1`。
    - `t` 同樣使用 `skipT` 來跳過被 `#` 刪除的字符。
3. **同步比對 `s` 和 `t` 的當前有效字符**
    
    - 當 `s[i] != t[j]` 時，說明它們最終的內容不同，返回 `False`。
    - 若 `s` 或 `t` 有剩餘字符而另一個沒有，則也返回 `False`。

---

## **變數表**

|變數名稱|含義|
|---|---|
|`s, t`|兩個輸入的字串|
|`i, j`|`s` 和 `t` 的當前索引（從右往左遍歷）|
|`skipS, skipT`|記錄 `s` 和 `t` 當前未處理的 `#` 數量|
|`s[i]`|`s` 的當前有效字符（若存在）|
|`t[j]`|`t` 的當前有效字符（若存在）|

---

## **具體步驟**

### **Step 1: 初始化**

- 設定 `i = len(s) - 1, j = len(t) - 1`，從 `s` 和 `t` **最右側開始遍歷**。
- 設定 `skipS = 0, skipT = 0`，用於計算當前的 `#` 應刪除的字符數。

### **Step 2: 處理 `#` 並跳過刪除的字符**

- **遍歷 `s`**：
    
    - 當 `s[i] == '#'`，則 `skipS += 1`，繼續向前移動 `i`。
    - 若 `skipS > 0`（表示前面有 `#` 要刪除字母），則 `skipS -= 1`，並繼續向前移動 `i`。
    - 否則，`s[i]` 為當前的有效字符。
- **遍歷 `t`**（與 `s` 的處理方式相同）。
    

### **Step 3: 比對當前有效字符**

- 當 `i >= 0` 且 `j >= 0` 時：
    - 若 `s[i] != t[j]`，則返回 `False`。
- 若 `s` 和 `t` 一個遍歷完但另一個還有剩餘字符，則返回 `False`。

### **Step 4: 遍歷完畢，返回 `True`**

- 若 `s` 和 `t` 皆完全遍歷完，則它們的有效內容相等，返回 `True`。

---

## **範例解析**

### **範例 1**

python

複製編輯

`s = "ab#c" t = "ad#c"`

**Step 1: 解析 `s`**

|`i`|`s[i]`|`skipS`|有效字符?|處理後索引|
|---|---|---|---|---|
|3|`c`|0|✅ `c`|3|
|2|`#`|1|❌ 刪除 `b`|1|
|1|`b`|1|❌ 被 `#` 刪除|0|
|0|`a`|0|✅ `a`|0|

**最終 `s` 變為 `"ac"`**

**Step 2: 解析 `t`**

|`j`|`t[j]`|`skipT`|有效字符?|處理後索引|
|---|---|---|---|---|
|3|`c`|0|✅ `c`|3|
|2|`#`|1|❌ 刪除 `d`|1|
|1|`d`|1|❌ 被 `#` 刪除|0|
|0|`a`|0|✅ `a`|0|

**最終 `t` 變為 `"ac"`**

- **`s == t` → `True`**

---

### **範例 2**

python

複製編輯

`s = "ab##" t = "c#d#"`

**最終 `s` 變為 `""`，`t` 變為 `""`**

- **返回 `True`**

---

### **範例 3**

python

複製編輯

`s = "a#c" t = "b"`

**最終 `s` 變為 `"c"`，`t` 變為 `"b"`**

- **`s != t`，返回 `False`**

---

## **時間與空間複雜度分析**

- **時間複雜度**
    
    - `O(N + M)`，其中 `N = len(s)`，`M = len(t)`。
    - **為何是 `O(N + M)`？**
        - 每個字符最多訪問一次 (`O(N)`)。
        - `skipS` 和 `skipT` 控制 `#`，讓 `s` 和 `t` 的遍歷效率最大化 (`O(M)`)。
- **空間複雜度**
    
    - `O(1)`，只使用了 `i, j, skipS, skipT` 等常數變數，**沒有額外的空間開銷**。

---

## **其他解法想法（不含代碼）**

4. **使用 Stack (`O(N + M)`)**
    
    - 用 `stack` 模擬 `#` 刪除操作。
    - 先遍歷 `s` 和 `t`，用 `stack` 依次壓入非 `#` 字符，遇到 `#` 就 `pop()`。
    - 最後比較 `stack_s` 和 `stack_t` 是否相等。
    - **缺點：需要 `O(N + M)` 額外空間**。
5. **倒序模擬 (`O(N + M)`)**
    
    - **與本解法類似**，但使用 `reverse()` 來從右往左遍歷 `s` 和 `t`。
    - **時間 `O(N + M)`，但需要額外 `O(N + M)` 空間來儲存翻轉後的 `s` 和 `t`**。
6. **暴力重新構造字串 (`O(N + M)`)**
    
    - 直接重建 `s` 和 `t`（刪除 `#`）。
    - 然後比對 `s` 和 `t` 是否相等。
    - **缺點：需要 `O(N + M)` 空間**。

---

## **結論**

- **最佳方法**：`雙指針從後向前遍歷` (`O(N + M)`)
- **可替代方法**
    - **Stack (`O(N + M)`)**：直覺但空間 `O(N + M)`
    - **倒序模擬 (`O(N + M)`)**：需要翻轉 `s, t`，多 `O(N + M)` 空間
    - **暴力重建 (`O(N + M)`)**：空間 `O(N + M)`

**此解法最優，僅用 `O(1)` 額外空間，在 `O(N + M)` 時間內完成比對**