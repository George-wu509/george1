Lintcode 408
给定两个二进制字符串，返回他们的和（用二进制表示）。
**样例 1：**
```python
"""
输入：
a = "0", b = "0"
输出：
"0"
```
**样例 2：**
```python
"""
输入：
a = "11", b = "1"
输出：
"100"
```


```python
    def add_binary(self, a, b):
        indexa = len(a) - 1
        indexb = len(b) - 1
        carry = 0
        sum = ""
        while indexa >= 0 or indexb >= 0:
            x = int(a[indexa]) if indexa >= 0 else 0
            y = int(b[indexb]) if indexb >= 0 else 0
            if (x + y + carry) % 2 == 0:
                sum = '0' + sum
            else:
                sum = '1' + sum
            carry = (x + y + carry) // 2
            indexa, indexb = indexa - 1, indexb - 1
        if carry == 1:
            sum = '1' + sum
        return sum
```
pass



本題 **`add_binary(self, a, b) -> str`** 的目標是計算兩個 **二進制字符串 `a` 和 `b`** 的和，並以二進制字符串形式返回。

此題的核心是**模擬二進制加法**，與十進制加法相似，主要步驟為：

1. **從最低位（右側）開始相加**
2. **記錄 `carry`（進位）**
3. **處理 `carry`，如果加到最高位仍有進位，則補 `1`**

---

## **變數表**

|變數名稱|含義|
|---|---|
|`a, b`|需要相加的二進制字符串|
|`indexa, indexb`|`a` 和 `b` 當前處理的索引（從後往前）|
|`carry`|進位值（0 或 1）|
|`sum`|存放結果的二進制字符串（最終需要反轉）|
|`x, y`|當前 `a[indexa]` 和 `b[indexb]` 對應的數值（如果索引超界則取 0）|

---

## **具體步驟**

4. **初始化變數**
    
    - `indexa = len(a) - 1`，`indexb = len(b) - 1`（從最後一位開始）
    - `carry = 0`（進位值）
    - `sum = ""`（存放二進制結果）
5. **逐位相加**
    
    - 當 `indexa >= 0` 或 `indexb >= 0` 時進行迴圈：
        - **取得對應數值 `x` 和 `y`**（若超出範圍則設為 `0`）
        - **計算該位的總和 `x + y + carry`**
        - **更新 `sum`**
            - `(x + y + carry) % 2 == 0` → 追加 `'0'`
            - `(x + y + carry) % 2 == 1` → 追加 `'1'`
        - **更新 `carry`**
            - `carry = (x + y + carry) // 2`
        - **索引前移**：`indexa -= 1`，`indexb -= 1`
6. **處理最高位的 `carry`**
    
    - 如果 `carry == 1`，則在 `sum` 前加 `'1'`
7. **返回最終結果**
    
    - 由於 `sum` 是從 **最低位開始存儲**，最終結果已經是正確的。

---

## **範例說明**

### **範例 1**

python

複製編輯

`a = "11" b = "1"`

**步驟**

|indexa|indexb|x|y|carry|(x + y + carry)|sum|new carry|
|---|---|---|---|---|---|---|---|
|1|0|1|1|0|2 (10)|"0"|1|
|0|-1|1|0|1|2 (10)|"00"|1|
|-1|-2|0|0|1|1 (01)|"100"|0|

**結果**：`"100"`

---

### **範例 2**

python

複製編輯

`a = "1010" b = "1011"`

**步驟**

|indexa|indexb|x|y|carry|(x + y + carry)|sum|new carry|
|---|---|---|---|---|---|---|---|
|3|3|0|1|0|1 (01)|"1"|0|
|2|2|1|1|0|2 (10)|"01"|1|
|1|1|0|0|1|1 (01)|"101"|0|
|0|0|1|1|0|2 (10)|"0101"|1|
|-1|-1|0|0|1|1 (01)|"10101"|0|

**結果**：`"10101"`

---

## **時間與空間複雜度分析**

- **時間複雜度**
    
    - 我們遍歷 `a` 和 `b` 中較長的那一個，記為 `max(n, m)`
    - 每一步運算都是常數時間 `O(1)`
    - **總體時間複雜度為 `O(max(n, m))`**
- **空間複雜度**
    
    - `sum` 需要額外 `O(max(n, m))` 的空間存儲結果
    - **總體空間複雜度為 `O(max(n, m))`**

---

## **其他解法想法（不含代碼）**

8. **Python 內建函數 (`O(n + m)`)**
    
    - 直接使用 `int(a, 2) + int(b, 2)` 轉換為十進制相加，再用 `bin(sum)[2:]` 轉回二進制字符串
    - 缺點：依賴內建函數，對於大數精度可能有影響
9. **位運算 (`O(max(n, m))`)**
    
    - 轉換 `a` 和 `b` 為整數後，使用位運算模擬二進制加法
    - 可用 `carry = (x & y) << 1` 計算進位，`sum = x ^ y` 計算當前位結果
    - 需要處理無限循環，因此可能需要轉換為字串處理
10. **遞歸解法 (`O(max(n, m))`)**
    
    - 用遞歸方式模擬加法，將 `carry` 當作額外參數，每次處理最後一位
    - 缺點：遞歸深度可能過深，影響效能

---

## **結論**

- **最優解法** 是 **模擬二進制加法（滑動指標 + 進位）**，時間複雜度 `O(max(n, m))`，空間 `O(max(n, m))`
- **內建函數法** 簡單但依賴 Python 內部實作，可能有精度問題
- **位運算法** 可行但需要轉換為整數，處理進位較複雜
- **遞歸法** 直觀但可能造成遞歸過深的問題

這樣的解法能夠高效處理 **不同長度的二進制數相加**，並且不需要額外的數值轉換，是最直覺且高效的方法。