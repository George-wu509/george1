Lintcode 837
给定一个字符串，你的任务是数出有多少个回文子串在这个字符串内。  
一个子串不同于其他的子串，当且仅当开始和结束位置不同。
**样例1**
```python
"""
输入: "abc"
输出: 3
解释:
3个回文字符串: "a", "b", "c".
```
**样例2**
```python
"""
输入: "aba"
输出: 4
解释:
4个回文字符串: "a", "b", "a", "aba".
```


```python
def count_palindromic_substrings(self, str: str) -> int:
	n = len(str)
	ans = 0
	for i in range(2 * n - 1):
		left = i // 2
		right = i // 2 + i % 2
		while left >= 0 and right < n and str[left] == str[right]:
			left -= 1
			right += 1
			ans += 1

	return ans
```
pass
解釋:  s = "aba"
step1: for loop(i=0,1,2,3,4)包含字元本身("a","b","a")還包括字元中間("ab","ba")為中心擴展法的中心點. 
step2: 在每個中心點white loop往左右擴展, 如果左=右則+1


**程式碼解法解釋 (中心擴展法 - Expand Around Center)**

這個解法採用了「中心擴展法」。其核心思想是：任何一個回文子字串，都有一個「中心」。這個中心可能是一個單一字元（例如 "aba" 的中心是 'b'），也可能在兩個字元之間（例如 "abba" 的中心在兩個 'b' 之間）。

1. **遍歷所有可能的中心點:**
    
    - 一個長度為 `n` 的字串，有 `n` 個單一字元可以作為中心 (索引 0 到 n-1)。
    - 同時，有 `n-1` 個字元間隙可以作為中心 (索引 0 和 1 之間，1 和 2 之間，... , n-2 和 n-1 之間)。
    - 總共有 `n + (n-1) = 2n - 1` 個可能的中心點。
    - 迴圈 `for i in range(2 * n - 1):` 就是在遍歷這 `2n - 1` 個可能的中心。
2. **確定中心左右指針:**
    
    - `left = i // 2`: 使用整數除法 `//` 計算左指針的初始位置。
    - `right = i // 2 + i % 2`: 使用整數除法和取模運算 `%` 計算右指針的初始位置。
    - 讓我們看看 `i` 的奇偶性如何影響 `left` 和 `right`：
        - 當 `i` 是偶數時 (例如 `i=0, 2, 4, ...`)：`i % 2` 為 0。`left = i // 2`，`right = i // 2`。`left` 和 `right` 指向同一個字元，代表以單一字元為中心的奇數長度回文串（例如 "aba"）。
        - 當 `i` 是奇數時 (例如 `i=1, 3, 5, ...`)：`i % 2` 為 1。`left = i // 2`，`right = i // 2 + 1`。`left` 和 `right` 指向相鄰的兩個字元，代表以兩個字元之間為中心的偶數長度回文串（例如 "abba"）。
    - 這種計算方式巧妙地涵蓋了所有單字元中心和字元間隙中心。
3. **從中心向外擴展:**
    
    - `while left >= 0 and right < n and str[left] == str[right]:` 這個 `while` 迴圈是核心的擴展邏輯。它檢查：
        - `left >= 0`: 左指針沒有越過字串的開頭。
        - `right < n`: 右指針沒有越過字串的結尾。
        - `str[left] == str[right]`: 左右指針指向的字元必須相等，這是回文串的必要條件。
    - 只要這三個條件都滿足，就表示 `str[left...right]` (包含 `left` 和 `right`) 是一個回文子字串。
4. **計數與移動指針:**
    
    - `ans += 1`: 每當 `while` 條件滿足時，就找到了一個新的回文子字串，計數器 `ans` 加 1。
    - `left -= 1`: 左指針向左移動一步。
    - `right += 1`: 右指針向右移動一步。
    - 然後繼續下一輪 `while` 檢查，嘗試擴展更長的回文串。
5. **返回結果:**
    
    - 當 `while` 迴圈因為邊界條件或字元不匹配而終止時，就完成了以當前 `i` 對應的中心點的所有回文串查找。
    - 外層 `for` 迴圈繼續處理下一個中心點。
    - 所有中心點都處理完畢後，`ans` 就包含了所有回文子字串的總數，將其返回。

**複雜度分析**

- **時間複雜度:** O(n2)。外層迴圈執行 2n−1 次（即 O(n) 次）。內層 `while` 迴圈在最壞情況下（例如字串是 "aaaaa"）可能需要擴展 O(n) 次。因此總時間複雜度是 O(n×n)=O(n2)。
- **空間複雜度:** O(1)。除了儲存輸入字串本身，該算法只使用了固定數量的額外變數 (`n`, `ans`, `i`, `left`, `right`)，與輸入字串大小無關。

**優化方案**

目前的中心擴展法在時間複雜度上已經是 O(n2)，空間複雜度是 O(1)，對於許多情況來說是相當不錯且容易理解的解法。但理論上存在更優的算法：

1. **動態規劃 (Dynamic Programming):**
    
    - **思路:** 可以使用一個二維陣列 `dp[i][j]` 來表示子字串 `str[i...j]` 是否為回文串。
    - **狀態轉移:**
        - `dp[i][i] = True` (單個字元是回文串)。
        - `dp[i][i+1] = (str[i] == str[i+1])`。
        - `dp[i][j] = (str[i] == str[j]) and dp[i+1][j-1]` (當 `j > i + 1`)。
    - **計數:** 在填充 `dp` 表的過程中，每當 `dp[i][j]` 為 `True` 時，計數器加 1。
    - **複雜度:** 時間複雜度 O(n2)（需要填充 O(n2) 個狀態），空間複雜度 O(n2)（需要儲存 `dp` 表）。
    - **比較:** 與中心擴展法相比，時間複雜度相同，但空間複雜度更高 (O(n2) vs O(1))，所以中心擴展法通常更優。
2. **Manacher's Algorithm:**
    
    - **思路:** 這是專門設計用來在線性時間內查找最長回文子串的算法，但也可以稍作修改來計算所有回文子字串的數量。它通過利用回文串的對稱性以及之前計算過的結果來避免重複比較，從而達到線性時間。
    - **複雜度:** 時間複雜度 O(n)，空間複雜度 O(n) (需要一個輔助陣列來儲存以每個位置為中心的回文半徑)。
    - **比較:** Manacher's Algorithm 提供了理論上最優的時間複雜度。然而，它的實現相對複雜，需要處理奇偶長度的回文串（通常通過在字串中插入特殊字元來統一處理）以及邊界情況，理解和編寫難度較大。對於一般的程式設計競賽或面試，除非明確要求 O(n) 的解法，否則 O(n2) 的中心擴展法通常是更實用、更容易實現且足夠高效的選擇。

**總結**

您提供的程式碼使用了「中心擴展法」，是一個非常經典且直觀的解法，具有 O(n2) 的時間複雜度和 O(1) 的空間複雜度。雖然存在時間複雜度更優的 Manacher's Algorithm (O(n))，但其實現更為複雜。對於大多數情況，中心擴展法是一個很好的平衡了效率和實現複雜度的方案。