Lintcode 1079
给定字符串`s`，计算有相同数量的0和1的非空连续子串的数量，并且子串中所有的0和所有的1都是连续的。相同的子串出现多次则计数多次。

**样例 1:**
```python
输入: "00110011"
输出: 6
解释: 有6个符合题目的连续子串："0011", "01", "1100", "10", "0011", and "01".

注意重复的子串会记录多次。

而且, "00110011" 是不合理的子串，因为所有的0和1没有连在一起(不是連續子串)。
```
**样例 2:**
```python
输入: "10101"
输出: 4
解释: 有4个合题的连续子串: "10", "01", "10", "01"。
```


```python
def count_binary_substrings(self, s: str) -> int:
	counts = list()
	ptr, n = 0, len(s)
	while ptr < n:
		c = s[ptr]
		count = 0
		while ptr < n and s[ptr] == c:
			ptr += 1
			count += 1
		counts.append(count)
	ans = 0
	for i in range(1, len(counts)):
		ans += min(counts[i], counts[i - 1])
	return ans
```
pass
解釋:
step1: counts紀錄每個區域(0 or 1)的長度, 譬如 
"00110011" -> counts = [2,2,2,2]
step2:從i=1開始遍歷counts, 然後計算min(counts[i],counts[i-1]). 譬如i=1 = min(2,2)=2
就代表相鄰"0011"可能有"0011"跟"01"兩種 

## **解法思路**

本題 **`count_binary_substrings(self, s: str) -> int`** 的目標是：

- **計算字串 `s` 中相鄰的 `0` 和 `1` 形成的「平衡子字串」數量**。
- **平衡子字串的定義**：
    - 必須包含相同數量的 `0` 和 `1`。
    - `0` 和 `1` 必須是**連續的區塊**，例如 `"0011"`, `"1100"`, `"01"`, `"10"`。

---

## **解法分析**

### **核心想法**

1. **遍歷 `s`，記錄連續 `0` 或 `1` 的數量 (`counts` 陣列)**
    
    - `counts[i]` 表示 **第 `i` 個連續區塊 (`0` 或 `1`) 的長度**。
2. **計算「平衡子字串」的數量**
    
    - **平衡子字串的數量等於 `min(counts[i], counts[i-1])`**
    - 這是因為 `counts[i]` 與 `counts[i-1]` 代表相鄰的 `0` 和 `1` **形成的最小可平衡長度**。

---

## **變數表**

|變數名稱|含義|
|---|---|
|`s`|輸入的二進位字串|
|`counts`|儲存 `0` 和 `1` 各自的連續區塊大小|
|`ptr`|指向當前處理 `s` 的索引|
|`c`|`ptr` 當前指向的字符 (`'0'` 或 `'1'`)|
|`count`|當前連續的 `0` 或 `1` 的數量|
|`ans`|計算總共的平衡子字串數量|

---

## **具體步驟**

### **Step 1: 記錄 `counts` 陣列**

- **遍歷 `s`，統計連續 `0` 或 `1` 的區塊大小**，並存入 `counts` 陣列。
- **例如 `"001110011"`**

    `counts = [2, 3, 2, 2]`
    

### **Step 2: 計算平衡子字串數量**

- **計算 `counts[i]` 與 `counts[i-1]` 之間能形成的平衡子字串數量**

    `ans = min(counts[0], counts[1]) + min(counts[1], counts[2]) + min(counts[2], counts[3])`
    

---

## **範例解析**

### **範例 1**

`s = "00110"`

**Step 1: 建立 `counts`**

|`s` 區塊|`counts`|
|---|---|
|`"00"`|`2`|
|`"11"`|`2`|
|`"0"`|`1`|

`counts = [2, 2, 1]`

**Step 2: 計算平衡子字串數量**

`ans = min(2, 2) + min(2, 1) = 2 + 1 = 3`

**結果：`3`**

平衡子字串：

1. `"01"`
2. `"10"`
3. `"0011"`

---

### **範例 2**

python

複製編輯

`s = "10101"`

**Step 1: 建立 `counts`**

|`s` 區塊|`counts`|
|---|---|
|`"1"`|`1`|
|`"0"`|`1`|
|`"1"`|`1`|
|`"0"`|`1`|
|`"1"`|`1`|

`counts = [1, 1, 1, 1, 1]`

**Step 2: 計算平衡子字串數量**

python

複製編輯

`ans = min(1, 1) + min(1, 1) + min(1, 1) + min(1, 1) = 1 + 1 + 1 + 1 = 4`

**結果：`4`**

平衡子字串：

4. `"10"`
5. `"01"`
6. `"10"`
7. `"01"`

---

### **範例 3**

python

複製編輯

`s = "00110011"`

**Step 1: 建立 `counts`**

|`s` 區塊|`counts`|
|---|---|
|`"00"`|`2`|
|`"11"`|`2`|
|`"00"`|`2`|
|`"11"`|`2`|

`counts = [2, 2, 2, 2]`

**Step 2: 計算平衡子字串數量**

python

複製編輯

`ans = min(2, 2) + min(2, 2) + min(2, 2) = 2 + 2 + 2 = 6`

**結果：`6`**

平衡子字串：

8. `"0011"`
9. `"01"`
10. `"1100"`
11. `"10"`
12. `"0011"`
13. `"01"`

---

## **時間與空間複雜度分析**

- **時間複雜度**
    
    1. **遍歷 `s` 記錄 `counts`：`O(N)`**
    2. **計算平衡子字串數量：`O(N)`**
    3. **總體時間複雜度：`O(N)`**
- **空間複雜度**
    
    - `counts` 陣列最多 `O(N)`。
    - **總體空間複雜度：`O(N)`**

---

## **其他解法想法（不含代碼）**

14. **直接計算相鄰 `0` 和 `1` 的區塊 (`O(N)`)**
    
    - 在遍歷 `s` 時，不存 `counts`，而是直接比較當前區塊與前一區塊的大小。
    - **優點：空間 `O(1)`，比 `counts` 陣列更省空間**。
15. **雙指針 (`O(N)`)**
    
    - 使用 `prev_count` 和 `cur_count` 來記錄當前和前一個數字的連續長度。
    - 當 `s[i]` 與 `s[i-1]` 不同時，`ans += min(prev_count, cur_count)`。
16. **暴力枚舉 (`O(N^2)`)**
    
    - 遍歷 `s` 的所有子字串，判斷是否為「平衡子字串」。
    - **時間過長，完全不可行**。

---

## **結論**

- **最佳方法**：**統計 `counts` + 計算最小區塊 (`O(N)`)**
    - **時間 `O(N)`，空間 `O(N)`**
    - **簡單且易於理解**
- **可替代方法**
    - **雙指針 (`O(N)`, `O(1)`)**：省空間，效率最佳
    - **暴力枚舉 (`O(N^2)`)**：不可行

🚀 **此方法能有效計算 `s` 中的「平衡子字串」，適合大數據場景！** 🚀