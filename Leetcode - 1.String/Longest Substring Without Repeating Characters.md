Lintcode 384
给定一个字符串，请找出其中无重复字符的最长子字符串。

**样例 1:**
```python
"""
输入: "abcabcbb"
输出: 3
解释: 最长子串是 "abc".
```
**样例 2:**
```python
"""
输入: "bbbbb"
输出: 1
解释: 最长子串是 "b".
```

```python
    def length_of_longest_substrin(self, s):
        unique_chars = set([])
        j = 0
        n = len(s)
        longest = 0
        for i in range(n):
            while j < n and s[j] not in unique_chars:
                unique_chars.add(s[j])
                j += 1
            longest = max(longest, j - i)
            unique_chars.remove(s[i])
            
        return longest
```
pass
解釋:
step1: create一個set儲存窗口. 有兩個指標 i（左邊界）和 j（右邊界）來定義滑動視窗 s[i:j]
step2: 外層迴圈 for i in range(n) 迭代左邊界 i。內層 while 迴圈負責擴展右邊界 j
step3: while j往右擴展直到某個字元在set裡面, 這時換成i往右




這個演算法使用**滑動視窗**的方法來尋找最長無重複字元的子字串。

1. **初始化：**
    
    - `unique_chars`: 一個集合（`set`），用於儲存目前滑動視窗中的不重複字元。
    - `j`: 滑動視窗的右邊界（擴展）。
    - `n`: 輸入字串 `s` 的長度。
    - `longest`: 目前找到的最長無重複子字串的長度，初始化為 0。
2. **滑動視窗：** 使用兩個指標 `i`（左邊界）和 `j`（右邊界）來定義滑動視窗 `s[i:j]`。
    
3. **擴展視窗：** 外層迴圈 `for i in range(n)` 迭代左邊界 `i`。內層 `while` 迴圈負責擴展右邊界 `j`。只要 `j` 還在字串範圍內，並且 `s[j]` 這個字元不在 `unique_chars` 集合中，就將 `s[j]` 加入集合，並將 `j` 向右移動一位，擴大視窗。這表示我們在目前以 `s[i]` 開頭的子字串中找到了一個新的不重複字元，可以將其包含進來。
    
4. **更新最長長度：** 當內層 `while` 迴圈停止（遇到重複字元或 `j` 超出邊界），目前的滑動視窗 `s[i:j]` 就是一個以 `s[i]` 開頭的最長無重複子字串。我們計算其長度 `j - i`，並用 `max(longest, j - i)` 更新 `longest`，以追蹤目前找到的最長長度。
    
5. **收縮視窗：** 在外層迴圈的每次迭代結束時，我們將 `s[i]` 從 `unique_chars` 集合中移除。這是因為當左邊界 `i` 向右移動一位後，`s[i]` 這個字元就不再屬於新的滑動視窗的起始部分了，所以需要將其從記錄的不重複字元集合中移除，以便後續的滑動視窗可以再次包含這個字元。
    
6. **返回結果：** 當外層迴圈結束時，`longest` 變數中儲存的就是整個字串 `s` 中最長無重複字串的長度。
    

總而言之，這個演算法通過不斷擴展和收縮滑動視窗，並使用一個集合來追蹤視窗中的不重複字元，有效地找到了最長無重複子字串的長度。時間複雜度是 O(n)，因為每個字元最多被 `i` 和 `j` 指標訪問兩次。空間複雜度是 O(min(m, n))，其中 m 是字元集的大小（因為集合最多儲存 m 個不同的字元）。