Lintcode 415
给定一个字符串，判断其是否为一个回文串。只考虑字母和数字，并忽略大小写。
**样例 1:**
```python
"""
输入: "A man, a plan, a canal: Panama"
输出: true
解释: "amanaplanacanalpanama"
```
**样例 2:**
```python
"""
输入: "race a car"
输出: false
解释: "raceacar"
```
**样例 3:**
```python
"""
输入: "1b , 1"
输出: true
解释: "1b1"
```


```python
    def isPalindrome(self, s):
        start, end = 0, len(s) - 1
        while start < end:
            while start < end and not s[start].isalpha() and not s[start].isdigit():
                start += 1
            while start < end and not s[end].isalpha() and not s[end].isdigit():
                end -= 1
            if start < end and s[start].lower() != s[end].lower():
                return False
            start += 1
            end -= 1
        return True
```
pass


本題 **`count_palindromic_substrings(self, str: str) -> int`** 的目標是計算給定字符串 `str` 中的**所有回文子串數量**。

**回文子串 (Palindrome Substring)** 指的是**從 `left` 到 `right` 的子串，其正向和反向讀取結果相同**，例如：

- `"aba"` 是回文
- `"racecar"` 是回文
- `"ab"` 不是回文

此解法採用了 **中心擴展法 (Expand Around Center)**，**對每個可能的中心向兩側擴展**，判斷是否為回文子串。

---

## **變數表**

|變數名稱|含義|
|---|---|
|`n`|`str` 的長度|
|`ans`|記錄回文子串的總數|
|`i`|當前擴展的中心索引（可能是字符或字符間隙）|
|`left`|當前擴展的左邊界|
|`right`|當前擴展的右邊界|

---

## **具體步驟**

### **1. 遍歷所有可能的中心點**

- **對於奇數長度的回文子串**，中心為單個字符，如 `"aba"` 的 `"b"`
- **對於偶數長度的回文子串**，中心為兩字符之間的間隙，如 `"abba"` 的 `"bb"`

**公式：**

- `left = i // 2`
- `right = i // 2 + (i % 2)`

這樣，我們在 **2𝑛−1 個中心** 上執行擴展。

---

### **2. 擴展並計數回文子串**

- **當 `str[left] == str[right]` 時擴展**
- 每擴展一步，計數 `ans += 1`
- 當擴展超出邊界或 `str[left] != str[right]` 時停止

---

## **範例說明**

### **範例 1**

python

複製編輯

`str = "abc"`

**步驟**

|中心 `i`|`left`|`right`|擴展過程|`ans` 增加的數量|
|---|---|---|---|---|
|0|0|0|"a"|1|
|1|0|1|停止|0|
|2|1|1|"b"|1|
|3|1|2|停止|0|
|4|2|2|"c"|1|

**結果**：`3` (子串為 `"a"`, `"b"`, `"c"`)

---

### **範例 2**

python

複製編輯

`str = "aaa"`

**步驟**

|中心 `i`|`left`|`right`|擴展過程|`ans` 增加的數量|
|---|---|---|---|---|
|0|0|0|"a"|1|
|1|0|1|"aa"|1|
|2|1|1|"a" → "aaa"|2|
|3|1|2|"aa"|1|
|4|2|2|"a"|1|

**結果**：`6` (子串為 `"a"`, `"a"`, `"a"`, `"aa"`, `"aa"`, `"aaa"`)

---

## **時間與空間複雜度分析**

- **時間複雜度**
    
    - **中心擴展法** 需要 **`O(n)`** 個中心，每個中心最壞情況下擴展 `O(n)`。
    - 總體時間複雜度為 **`O(n^2)`**。
- **空間複雜度**
    
    - 只使用了常數額外變數 **`O(1)`**。

相較於 `O(n^3)` 的暴力解法，此方法對 **長度較長的 `str`** 效率更好。

---

## **其他解法想法（不含代碼）**

1. **暴力解法 (`O(n^3)`)**
    
    - 檢查所有可能的子串 `(i, j)` 是否為回文
    - 時間複雜度高 (`O(n^3)`)，不適用長 `n`
2. **動態規劃 (`O(n^2)`)**
    
    - 建立 `dp[i][j]` 紀錄 `str[i:j]` 是否為回文
    - `dp[i][j] = (str[i] == str[j]) and dp[i+1][j-1]`
    - 空間需求 `O(n^2)`
3. **Manacher’s Algorithm (`O(n)`)**
    
    - 轉換字符串 (`"#a#b#c#"`) 使所有回文長度變奇數
    - 運用**對稱性**加速擴展
    - 最優解但實作較複雜

---

## **結論**

- **最優選擇**：**中心擴展法 (`O(n^2)`)**，適用於中等長度的字符串 (`n <= 1000`)
- **暴力解法 (`O(n^3)`)** 適合小 `n`
- **動態規劃 (`O(n^2)`)** 適用於查詢是否為回文
- **Manacher (`O(n)`)** 適用於極大 `n`，但實作較複雜



在 **回文子串的中心擴展法 (Expand Around Center)** 中，中心點的數量並不是 `n`，而是 `2*n - 1`，這是因為 **回文的中心可以是字母本身，也可以是兩個字母之間的空隙**。

### **回文子串的兩種情況**

1. **奇數長度的回文**（中心點為單個字符）
    
    - 如 `"aba"`，中心是 `"b"`
    - 可擴展為 `"a" → "aba"`
2. **偶數長度的回文**（中心點為兩個字符之間）
    
    - 如 `"abba"`，中心是 `"bb"`（`a(bb)a`）
    - 可擴展為 `"bb" → "abba"`

### **為什麼 `i` 需要遍歷 `2*n - 1`？**

- 若只遍歷 `range(n)`，則僅考慮單個字符為中心，**忽略了偶數長度的回文子串**。
- **總共有 `n` 個字符，但有 `n-1` 個空隙，因此中心點總共有 `n + (n-1) = 2n-1` 個**。

### **如何對應中心 `i` 到 `left` 和 `right`？**

透過公式：

- `left = i // 2`
- `right = i // 2 + (i % 2)`

可以確保：

1. **當 `i` 為偶數時，`left = right`，對應單字符中心（奇數長度的回文）**
2. **當 `i` 為奇數時，`right = left + 1`，對應雙字符中心（偶數長度的回文）**

---

### **範例解釋**

#### **情境 1：奇數長度回文**

python

複製編輯

`s = "aba"`

|`i`|`left`|`right`|中心|結果|
|---|---|---|---|---|
|0|0|0|`"a"`|`"a"`|
|1|0|1|`"ab"`|停止|
|2|1|1|`"b"`|`"b"` → `"aba"`|
|3|1|2|`"ba"`|停止|
|4|2|2|`"a"`|`"a"`|

最後找到的回文子串：`"a", "b", "a", "aba"`（共 `4` 個）

---

#### **情境 2：偶數長度回文**

python

複製編輯

`s = "abba"`

|`i`|`left`|`right`|中心|結果|
|---|---|---|---|---|
|0|0|0|`"a"`|`"a"`|
|1|0|1|`"ab"`|停止|
|2|1|1|`"b"`|`"b"`|
|3|1|2|`"bb"`|`"bb"` → `"abba"`|
|4|2|2|`"b"`|`"b"`|
|5|2|3|`"ba"`|停止|
|6|3|3|`"a"`|`"a"`|

最後找到的回文子串：`"a", "b", "b", "a", "bb", "abba"`（共 `6` 個）

---

### **結論**

若只遍歷 `range(n)`，則無法考慮偶數長度的回文（如 `"abba"`）。  
透過 `range(2*n-1)`，可確保每個字符及其間隙都能當作回文的中心，使得**所有可能的回文子串都能被正確計算**。



- **Python 的回文字串是否字元個數一定要是偶數?**
    
    **不是的。** 回文字串 (Palindrome) 指的是一個從前面讀和從後面讀都一樣的字串。它的字元個數可以是**奇數**也可以是**偶數**。
    
    - **偶數長度範例:**
        - `"level"` (5個字元) -> 錯誤，這是奇數。更正：`"noon"` (4個字元)
        - `"abba"` (4個字元)
        - `"上海自來水來自海上"` (9個字元) -> 錯誤，這是奇數。更正： `"ABBA"` (4個字元), `""` (空字串，0個字元，通常也視為回文)
    - **奇數長度範例:**
        - `"level"` (5個字元)
        - `"racecar"` (7個字元)
        - `"madam"` (5個字元)
        - `"a"` (1個字元)
        - `"上海自來水來自海上"` (9個字元)
    
    所以，回文字串的長度沒有奇偶限制。
    
- **最快的判斷回文字串的方法是?**
    
    在 Python 中，判斷一個字串 `s` 是否為回文串，最常用且通常被認為_既快又簡潔_的方法有兩種，它們的時間複雜度都是 O(n)，其中 n 是字串的長度。在實際表現上，哪一個「最快」可能會因 Python 的版本、底層實現以及字串的具體內容和長度而有微小差異，但兩者都非常高效。
    
    - **方法一：使用字串切片 (Slicing)**

        ```python
        def is_palindrome_slicing(s: str) -> bool:
          """
          使用字串切片反轉字串並比較。
          """
          # s[::-1] 會創建一個反轉後的 s 的副本
          return s == s[::-1]
        
        # 範例
        print(is_palindrome_slicing("level"))  # Output: True
        print(is_palindrome_slicing("hello"))  # Output: False
        ```
        
        - **優點:** 程式碼極其簡潔、易讀、非常 Pythonic。在 CPython 的實現中，字串切片操作通常經過高度優化，實際執行速度非常快。
        - **缺點:** 它需要額外 O(n) 的空間來創建反轉後的字串副本。
    - **方法二：使用雙指針 (Two Pointers)**

        ```python
        def is_palindrome_two_pointers(s: str) -> bool:
          """
          使用雙指針從兩端向中間比較字元。
          """
          left, right = 0, len(s) - 1
          while left < right:
            if s[left] != s[right]:
              return False
            left += 1
            right -= 1
          return True
        
        # 範例
        print(is_palindrome_two_pointers("racecar")) # Output: True
        print(is_palindrome_two_pointers("python")) # Output: False
        ```
        
        - **優點:** 空間複雜度為 O(1)，因為它只使用了固定的額外空間（兩個指針變數），沒有創建新的字串副本。對於非常長的字串，可以節省記憶體。
        - **缺點:** 程式碼比切片方法稍微長一點。
    
    **哪個「最快」？**
    
    - **理論與實踐:** 雖然兩者時間複雜度都是 O(n)，但切片方法 (`s == s[::-1]`) 在很多情況下的**實際執行時間**可能因為 CPython 底層的優化而非常接近甚至略快於雙指針方法，尤其是對於中短長度的字串。
    - **空間效率:** 雙指針方法在**空間使用**上無疑更優 (O(1) vs O(n))。
    - **可讀性:** 切片方法通常被認為可讀性更高。
    
    **結論:**
    
    - 對於**絕大多數情況**和追求**簡潔**，使用**字串切片 `s == s[::-1]`** 是非常好的選擇，既快速又易懂。
    - 如果**極度關注記憶體使用**（例如處理極其巨大的字串），或者在某些特定環境下實測發現雙指針更快，那麼**雙指針方法**是更優的選擇。