Lintcode 415
给定一个字符串，判断其是否为一个回文串。只考虑字母和数字，并忽略大小写。
**样例 1:**
```python
"""
输入: "A man, a plan, a canal: Panama"
输出: true
解释: "amanaplanacanalpanama"
```
**样例 2:**
```python
"""
输入: "race a car"
输出: false
解释: "raceacar"
```
**样例 3:**
```python
"""
输入: "1b , 1"
输出: true
解释: "1b1"
```


```python
    def isPalindrome(self, s):
        start, end = 0, len(s) - 1
        while start < end:
            while start < end and not s[start].isalpha() and not s[start].isdigit():
                start += 1
            while start < end and not s[end].isalpha() and not s[end].isdigit():
                end -= 1
            if start < end and s[start].lower() != s[end].lower():
                return False
            start += 1
            end -= 1
        return True
```
pass


本題 **`count_palindromic_substrings(self, str: str) -> int`** 的目標是計算給定字符串 `str` 中的**所有回文子串數量**。

**回文子串 (Palindrome Substring)** 指的是**從 `left` 到 `right` 的子串，其正向和反向讀取結果相同**，例如：

- `"aba"` 是回文
- `"racecar"` 是回文
- `"ab"` 不是回文

此解法採用了 **中心擴展法 (Expand Around Center)**，**對每個可能的中心向兩側擴展**，判斷是否為回文子串。

---

## **變數表**

|變數名稱|含義|
|---|---|
|`n`|`str` 的長度|
|`ans`|記錄回文子串的總數|
|`i`|當前擴展的中心索引（可能是字符或字符間隙）|
|`left`|當前擴展的左邊界|
|`right`|當前擴展的右邊界|

---

## **具體步驟**

### **1. 遍歷所有可能的中心點**

- **對於奇數長度的回文子串**，中心為單個字符，如 `"aba"` 的 `"b"`
- **對於偶數長度的回文子串**，中心為兩字符之間的間隙，如 `"abba"` 的 `"bb"`

**公式：**

- `left = i // 2`
- `right = i // 2 + (i % 2)`

這樣，我們在 **2𝑛−1 個中心** 上執行擴展。

---

### **2. 擴展並計數回文子串**

- **當 `str[left] == str[right]` 時擴展**
- 每擴展一步，計數 `ans += 1`
- 當擴展超出邊界或 `str[left] != str[right]` 時停止

---

## **範例說明**

### **範例 1**

python

複製編輯

`str = "abc"`

**步驟**

|中心 `i`|`left`|`right`|擴展過程|`ans` 增加的數量|
|---|---|---|---|---|
|0|0|0|"a"|1|
|1|0|1|停止|0|
|2|1|1|"b"|1|
|3|1|2|停止|0|
|4|2|2|"c"|1|

**結果**：`3` (子串為 `"a"`, `"b"`, `"c"`)

---

### **範例 2**

python

複製編輯

`str = "aaa"`

**步驟**

|中心 `i`|`left`|`right`|擴展過程|`ans` 增加的數量|
|---|---|---|---|---|
|0|0|0|"a"|1|
|1|0|1|"aa"|1|
|2|1|1|"a" → "aaa"|2|
|3|1|2|"aa"|1|
|4|2|2|"a"|1|

**結果**：`6` (子串為 `"a"`, `"a"`, `"a"`, `"aa"`, `"aa"`, `"aaa"`)

---

## **時間與空間複雜度分析**

- **時間複雜度**
    
    - **中心擴展法** 需要 **`O(n)`** 個中心，每個中心最壞情況下擴展 `O(n)`。
    - 總體時間複雜度為 **`O(n^2)`**。
- **空間複雜度**
    
    - 只使用了常數額外變數 **`O(1)`**。

相較於 `O(n^3)` 的暴力解法，此方法對 **長度較長的 `str`** 效率更好。

---

## **其他解法想法（不含代碼）**

1. **暴力解法 (`O(n^3)`)**
    
    - 檢查所有可能的子串 `(i, j)` 是否為回文
    - 時間複雜度高 (`O(n^3)`)，不適用長 `n`
2. **動態規劃 (`O(n^2)`)**
    
    - 建立 `dp[i][j]` 紀錄 `str[i:j]` 是否為回文
    - `dp[i][j] = (str[i] == str[j]) and dp[i+1][j-1]`
    - 空間需求 `O(n^2)`
3. **Manacher’s Algorithm (`O(n)`)**
    
    - 轉換字符串 (`"#a#b#c#"`) 使所有回文長度變奇數
    - 運用**對稱性**加速擴展
    - 最優解但實作較複雜

---

## **結論**

- **最優選擇**：**中心擴展法 (`O(n^2)`)**，適用於中等長度的字符串 (`n <= 1000`)
- **暴力解法 (`O(n^3)`)** 適合小 `n`
- **動態規劃 (`O(n^2)`)** 適用於查詢是否為回文
- **Manacher (`O(n)`)** 適用於極大 `n`，但實作較複雜



在 **回文子串的中心擴展法 (Expand Around Center)** 中，中心點的數量並不是 `n`，而是 `2*n - 1`，這是因為 **回文的中心可以是字母本身，也可以是兩個字母之間的空隙**。

### **回文子串的兩種情況**

1. **奇數長度的回文**（中心點為單個字符）
    
    - 如 `"aba"`，中心是 `"b"`
    - 可擴展為 `"a" → "aba"`
2. **偶數長度的回文**（中心點為兩個字符之間）
    
    - 如 `"abba"`，中心是 `"bb"`（`a(bb)a`）
    - 可擴展為 `"bb" → "abba"`

### **為什麼 `i` 需要遍歷 `2*n - 1`？**

- 若只遍歷 `range(n)`，則僅考慮單個字符為中心，**忽略了偶數長度的回文子串**。
- **總共有 `n` 個字符，但有 `n-1` 個空隙，因此中心點總共有 `n + (n-1) = 2n-1` 個**。

### **如何對應中心 `i` 到 `left` 和 `right`？**

透過公式：

- `left = i // 2`
- `right = i // 2 + (i % 2)`

可以確保：

1. **當 `i` 為偶數時，`left = right`，對應單字符中心（奇數長度的回文）**
2. **當 `i` 為奇數時，`right = left + 1`，對應雙字符中心（偶數長度的回文）**

---

### **範例解釋**

#### **情境 1：奇數長度回文**

python

複製編輯

`s = "aba"`

|`i`|`left`|`right`|中心|結果|
|---|---|---|---|---|
|0|0|0|`"a"`|`"a"`|
|1|0|1|`"ab"`|停止|
|2|1|1|`"b"`|`"b"` → `"aba"`|
|3|1|2|`"ba"`|停止|
|4|2|2|`"a"`|`"a"`|

最後找到的回文子串：`"a", "b", "a", "aba"`（共 `4` 個）

---

#### **情境 2：偶數長度回文**

python

複製編輯

`s = "abba"`

|`i`|`left`|`right`|中心|結果|
|---|---|---|---|---|
|0|0|0|`"a"`|`"a"`|
|1|0|1|`"ab"`|停止|
|2|1|1|`"b"`|`"b"`|
|3|1|2|`"bb"`|`"bb"` → `"abba"`|
|4|2|2|`"b"`|`"b"`|
|5|2|3|`"ba"`|停止|
|6|3|3|`"a"`|`"a"`|

最後找到的回文子串：`"a", "b", "b", "a", "bb", "abba"`（共 `6` 個）

---

### **結論**

若只遍歷 `range(n)`，則無法考慮偶數長度的回文（如 `"abba"`）。  
透過 `range(2*n-1)`，可確保每個字符及其間隙都能當作回文的中心，使得**所有可能的回文子串都能被正確計算**。