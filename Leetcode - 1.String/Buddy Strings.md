Lintcode 1510
给定两个由小写字母构成的字符串 `A` 和 `B`，如果能通过恰好交换一次 `A` 中的两个下标不同的字母后得到 `B`，就返回 `true`；否则返回 `false`。

**示例 1:**
```python
"""```
输入: A = "ab", B = "ba"
输出: true
```
**示例 2:**
```python
"""
输入: A = "ab", B = "ab"
输出: false
```
**示例 3:**
```python
"""
输入: A = "aa", B = "aa"
输出: true
```
**示例 4:**
```python
"""
输入: A = "aaaaaaabc", B = "aaaaaaacb"
输出: true
```
**示例 5:**
```python
"""
输入: A = "", B = "aa"
输出: false
```


```python
def buddyStrings(self, a: str, b: str) -> bool:
	if a == b:
		return []
	if len(a) != len(b):
		return False
	if a == b:
		if len(set(a)) < len(b): 
			return True
		else:
			return False
	diff = [(aa, bb) for aa, bb in zip(a, b) if aa != bb]
	return len(diff) == 2 and diff[0][0] == diff[1][1] and diff[0][1] == diff[1][0]
```
pass
a = "aaaaaaabc"
b = "aaaaaaacb"
解釋:
step1: 先檢查a,b長度. 如果長度不同則False
step2:  再檢查set
step3:<mark style="background: #BBFABBA6;"> for aa, bb in zip(str1, str2)</mark> 是一個iterator. 
會輸出('a', 'a'), ..., ('b', 'c'), ('c', 'b') 的序列
[(aa,bb) for aa, bb in zip(a,b) if aa != bb] 則會輸出[('b','c'), ('c','d')] 
所以
p.s zip() is built-in function that allows you to iterate over multiple iterables in parallel



本題 **`buddyStrings(self, a: str, b: str) -> bool`** 目標是：

- 判斷 **是否能通過交換 `a` 中的兩個字符** 使其與 `b` 相等。

---

## **解法分析**

有 **兩種可能讓 `a` 變成 `b`**：

1. **當 `a == b`，且 `a` 內部有至少一個重複字母時，可交換這兩個字母來保持 `a` 不變**，即 `a` 本身已經等於 `b`，但需要至少一對相同字母來交換。
2. **當 `a != b`，且 `a, b` 之間只有 2 個不同字符，並且它們可互換**，這樣 `a` 經過一次交換後可變成 `b`。

---

## **變數表**

|變數名稱|含義|
|---|---|
|`a, b`|兩個輸入的字串|
|`diff`|`a, b` 中所有不同的字符對|
|`set(a)`|用於檢查 `a` 是否有重複字母|

---

## **具體步驟**

### **Step 1: 檢查長度**

- 若 `len(a) != len(b)`，則無法通過交換變成 `b`，直接返回 `False`。

### **Step 2: 當 `a == b`**

- 如果 `a` 本身已經等於 `b`，但 `a` 裡面有 **至少一個重複字母**，則可交換這些字母來保持 `a` 不變，返回 `True`。
- **若 `a` 沒有重複字母**，則無法交換任何字符來改變 `a`，返回 `False`。

### **Step 3: 當 `a != b`**

- **收集所有 `a` 和 `b` 之間不同的字符對 (`diff`)**
- **若 `diff` 的長度不等於 2，則返回 `False`**
- **檢查 `diff` 內的兩個字符對是否可互換**：
    - **`diff[0][0] == diff[1][1]` 且 `diff[0][1] == diff[1][0]`，則返回 `True`**
    - 否則返回 `False`

---

## **範例解析**

### **範例 1**

python

複製編輯

`a = "ab" b = "ba"`

**Step 1: 長度檢查**

- `len(a) == len(b) = 2`，通過

**Step 2: `a != b`**

- **找出不同字符**
    
    python
    
    複製編輯
    
    `diff = [('a', 'b'), ('b', 'a')]`
    
- **檢查是否可互換**
    - `diff[0][0] == diff[1][1]` (`'a' == 'a'`)
    - `diff[0][1] == diff[1][0]` (`'b' == 'b'`)
- **結果**：`True`

---

### **範例 2**

python

複製編輯

`a = "aa" b = "aa"`

**Step 1: 長度檢查**

- `len(a) == len(b) = 2`，通過

**Step 2: `a == b`**

- **檢查是否有重複字母**
    
    python
    
    複製編輯
    
    `set(a) = {'a'}，len(set(a)) < len(b)`
    
- `a` 裡有重複字母 `"aa"`，可交換 `"a"` 來保持 `a` 不變。
- **結果**：`True`

---

### **範例 3**

python

複製編輯

`a = "ab" b = "ab"`

**Step 1: 長度檢查**

- `len(a) == len(b) = 2`，通過

**Step 2: `a == b`**

- **檢查是否有重複字母**
    
    python
    
    複製編輯
    
    `set(a) = {'a', 'b'}，len(set(a)) == len(b)`
    
- `a` **沒有重複字母**，因此無法通過交換讓 `a` 變成 `b`。
- **結果**：`False`

---

### **範例 4**

python

複製編輯

`a = "abc" b = "bca"`

**Step 1: 長度檢查**

- `len(a) == len(b) = 3`，通過

**Step 2: `a != b`**

- **找出不同字符**
    
    python
    
    複製編輯
    
    `diff = [('a', 'b'), ('b', 'c'), ('c', 'a')]`
    
- `diff` **超過 2 個**，無法通過**單次交換**讓 `a` 變成 `b`。
- **結果**：`False`

---

## **時間與空間複雜度分析**

- **時間複雜度**
    
    - **`len(a) != len(b)` 檢查**：`O(1)`
    - **建立 `set(a)` (檢查重複字母)**：`O(N)`
    - **找 `diff` (遍歷 `a, b`)**：`O(N)`
    - **總體時間複雜度**： O(N)O(N)O(N)
- **空間複雜度**
    
    - **使用 `set(a)`**：`O(N)`
    - **存儲 `diff` (最多 `O(2)`)**：`O(1)`
    - **總體空間複雜度**： O(N)O(N)O(N)

---

## **其他解法想法（不含代碼）**

1. **使用 `Counter` 計數法 (`O(N)`)**
    
    - 若 `a == b`，則用 `Counter(a)` 來判斷是否有重複字母。
    - 若 `a != b`，則統計不同字符並判斷是否能互換。
2. **暴力嘗試交換 (`O(N^2)`)**
    
    - 嘗試對 `a` 中的 **每對字母進行交換**，看是否能得到 `b`。
    - **時間複雜度過高，不可行。**
3. **Boyer-Moore 字符串匹配 (`O(N)`)**
    
    - 適用於 `a, b` 很長時，先快速檢查是否存在 2 個不同字符，然後進行交換檢查。

---

## **結論**

- **最佳方法**：**遍歷 `a, b` 找不同字符 (`O(N)`)**，並檢查 `set(a)` 是否有重複字母。
- **可替代方法**
    - **`Counter` (`O(N)`)**：適用於 Python `collections` 操作較快時。
    - **暴力交換 (`O(N^2)`)**：不可行。
    - **Boyer-Moore (`O(N)`)**：適用於超長字串的情況。

**此方法能夠高效判斷是否可透過交換讓 `a` 變成 `b`，並在 `O(N)` 時間內完成**



詳細解釋 Lintcode 1510 這題的 Python 程式碼解法，並說明為何需要特別檢查 `a == b` 以及 `len(set(a)) < len(b)`。

**問題概述**

題目要求判斷字串 `B` 是否可以通過**恰好交換一次**字串 `A` 中兩個**不同下標**的字母得到。

**程式碼逐行解釋**

Python

```
def buddyStrings(self, a: str, b: str) -> bool:
    # 1. 長度檢查
    if len(a) != len(b):
        return False
```

- **解釋：** 如果兩個字串 `a` 和 `b` 的長度不同，那麼不可能通過交換 `a` 中的字元（交換不改變長度）來得到 `b`。因此，如果長度不等，它們肯定不是 Buddy Strings，直接返回 `False`。這是最基本的必要條件。

Python

```
    # 2. 處理 a 和 b 完全相同的情況
    if a == b:
        # 檢查 a 中是否有重複字元
        if len(set(a)) < len(b): 
            # 或者寫成 len(set(a)) < len(a)，因為此時 a == b, len(a) == len(b)
            return True # 如果有重複字元，可以交換兩個相同的字元得到自身
        else:
            return False # 如果沒有重複字元，任何交換都會改變 a，無法得到 b
```

- **為何要檢查 `a == b`？**
    - 這個檢查處理的是一個**特殊情況**。如果 `a` 和 `b` 本來就完全相同，後面的 `diff` 列表（計算差異的部分）會是空的 (`len(diff)` 為 0）。如果沒有這個特殊處理，程式碼會執行到最後一步 `return len(diff) == 2 and ...`，因為 `len(diff)` 不等於 2 而直接返回 `False`，這會漏掉一種可能情況。
    - 情況就是：如果 `a` 和 `b` 相同，我們是否能通過在 `a` 中交換**一次**字符得到 `b`（也就是得到 `a` 本身）？答案是可以的，**前提是 `a` 中必須有至少兩個相同的字元**，這樣我們交換這兩個相同的字元，字串看起來沒有變化，結果仍然是 `a` (等於 `b`)，並且滿足了「恰好交換一次」的條件。例如 `a = "aab"`，交換前兩個 'a'，結果還是 "aab"。但如果 `a = "abc"`，任何一次交換都會得到不同的字串（如 "bac", "acb", "cba"），無法得到原來的 "abc"。
- **為何要檢查 `len(set(a)) < len(b)`？**
    - `set(a)` 會得到字串 `a` 中所有**不重複**的字元集合。
    - `len(set(a))` 是 `a` 中不重複字元的數量。
    - `len(b)` 在這個 `if a == b:` 的區塊內，其實就等於 `len(a)`。
    - 所以 `len(set(a)) < len(b)` 這個條件等價於 `len(set(a)) < len(a)`。
    - 這個條件的涵義是：**判斷字串 `a` 中是否存在重複的字元**。
        - 如果 `a` 中有重複字元（例如 "aab"），那麼 `set(a)` 會是 `{'a', 'b'}`，`len(set(a))` (為 2) 會小於 `len(a)` (為 3)。
        - 如果 `a` 中所有字元都是唯一的（例如 "abc"），那麼 `set(a)` 會是 `{'a', 'b', 'c'}`，`len(set(a))` (為 3) 會等於 `len(a)` (為 3)。
    - **判斷邏輯：** 因此，當 `a == b` 時，如果 `len(set(a)) < len(b)` 為 `True`，表示 `a` 中有重複字元，我們可以通過交換這兩個重複的字元來滿足題目條件，返回 `True`。如果為 `False`，表示 `a` 中沒有重複字元，任何交換都會改變 `a`，無法得到 `b`，返回 `False`。

Python

```
    # 3. 計算差異點
    diff = [(aa, bb) for aa, bb in zip(a, b) if aa != bb]
```

- **解釋：** 這行程式碼在 `a != b` 的情況下執行。
    - 它使用列表推導式和 `zip` 函數來比較 `a` 和 `b` 在相同索引位置上的字元。
    - `zip(a, b)` 將 `a` 和 `b` 的對應字元配對成元組 `(aa, bb)`。
    - `if aa != bb` 過濾出那些在相同位置上字元不同的配對。
    - `(aa, bb)` 將這些不同的配對（`a` 中的字元在前，`b` 中的字元在後）組成元組。
    - 最終，`diff` 是一個列表，包含了所有 `a` 和 `b` 之間不同的字元配對。例如，如果 `a = "ab"`，`b = "ba"`，那麼 `diff` 會是 `[('a', 'b'), ('b', 'a')]`。如果 `a = "abc"`，`b = "axc"`，`diff` 會是 `[('b', 'x')]`。

Python

```
    # 4. 根據差異點判斷是否為 Buddy Strings
    return len(diff) == 2 and diff[0][0] == diff[1][1] and diff[0][1] == diff[1][0]
```

- **解釋：** 這部分是在 `a != b` 的情況下，根據 `diff` 列表的內容來做最後的判斷。要滿足「恰好交換一次 `A` 中的兩個字母得到 `B`」的條件，必須同時滿足以下三點：
    - **`len(diff) == 2`:** `A` 和 `B` 之間必須**恰好只有兩個位置**的字元不同。如果差異點是 0 個（即 `a == b`，已處理）、1 個（不可能通過一次交換得到）、或者超過 2 個，都不符合條件。
    - **`diff[0][0] == diff[1][1]`:** `diff[0]` 是第一個差異點的元組 `(a中字元1, b中字元1)`，`diff[1]` 是第二個差異點的元組 `(a中字元2, b中字元2)`。`diff[0][0]` 是 `a` 中第一個不同點的字元 (`a[i]`)，`diff[1][1]` 是 `b` 中第二個不同點的字元 (`b[j]`)。這個條件檢查的是 `a[i]` 是否等於 `b[j]`。
    - **`diff[0][1] == diff[1][0]`:** `diff[0][1]` 是 `b` 中第一個不同點的字元 (`b[i]`)，`diff[1][0]` 是 `a` 中第二個不同點的字元 (`a[j]`)。這個條件檢查的是 `b[i]` 是否等於 `a[j]`。
- **綜合判斷：** 後兩個條件 `diff[0][0] == diff[1][1]` 和 `diff[0][1] == diff[1][0]` 合在一起，實質上是在檢查：`a` 在第一個差異點的字元是否等於 `b` 在第二個差異點的字元，**並且** `b` 在第一個差異點的字元是否等於 `a` 在第二個差異點的字元。這**恰好**描述了交換 `a` 中這兩個位置的字元就能得到 `b` 的情況。例如，`a = "ab"`, `b = "ba"`，`diff = [('a', 'b'), ('b', 'a')]`。`len(diff)` 為 2。`diff[0][0]` ('a') == `diff[1][1]` ('a') 且 `diff[0][1]` ('b') == `diff[1][0]` ('b')。條件滿足。
- **返回：** 只有當所有三個條件都滿足時，才返回 `True`，表示它們是 Buddy Strings；否則返回 `False`。

**總結**

程式碼通過以下步驟判斷 Buddy Strings：

1. 檢查長度是否相等。
2. 特殊處理兩個字串完全相同的情況：只有當字串中存在重複字元時，才能通過交換相同的字元來滿足條件。
3. 如果字串不同，找出所有不相同字元的位置及其對應的字元配對。
4. 檢查不同的位置是否恰好有兩個，並且這兩個位置的字元是否正好是交換關係。