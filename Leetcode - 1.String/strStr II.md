Lintcode 594
实现时间复杂度为 O(n + m)的方法 `strStr`。  
`strStr` 返回目标字符串在源字符串中第一次出现的第一个字符的位置. 目标字串的长度为 _m_ , 源字串的长度为 _n_ . 如果目标字串不在源字串中则返回 -1。
**样例 1:**
```python
输入：source = "abcdef"， target = "bcd"
输出：1
解释：
字符串第一次出现的位置为1。
```
**样例 2:**
```python
输入：source = "abcde"， target = "e"
输出：4
解释：
字符串第一次出现的位置为4。
```


```python
import random # 如果想用隨機模數可以保留, 但固定模數通常更好

class Solution:
    """
    @param source: A source string
    @param target: A target string
    @return: An integer as the index of the first occurrence of target in source,
             or -1 if target is not part of source.
    """
    def strStr2(self, source: str, target: str) -> int:
        # 基本的 None 檢查
        if source is None or target is None:
            return -1

        n = len(source)
        m = len(target)

        # 特殊情況：target 為空，按定義應返回 0
        if m == 0:
            return 0
        # 特殊情況：source 比 target 短，不可能包含 target
        if n < m:
            return -1

        # --- Rabin-Karp 演算法常數 ---
        # 選擇一個基數 (BASE)。質數通常效果更好，例如 31 或 256 (涵蓋 ASCII)
        BASE = 31 # 或者 256
        # 選擇一個大的質數作為模數 (MOD)，以降低雜湊碰撞的機率
        # 使用固定的模數比隨機模數更易於測試和除錯
        MOD = 10**9 + 7 # 一個常用的大質數
        # 或者，如果確實需要隨機性：
        # MOD = random.randint(10**9 + 7, 2 * 10**9)

        # --- 預先計算 ---
        hash_target = 0  # target 字串的雜湊值
        hash_window = 0  # source 中滑動視窗的雜湊值

        # 計算 BASE 的最高次冪: BASE**(m-1) % MOD
        # 用於之後移除視窗最左側字元時的計算
        # pow(BASE, m - 1, MOD) 比手動迴圈計算更有效率 (特別是 m 很大時)
        power_base_m_minus_1 = pow(BASE, m - 1, MOD)

        # 計算 target 的雜湊值和 source 第一個視窗 (source[0...m-1]) 的雜湊值
        for i in range(m):
            # 使用 ord(c) 直接獲取字元數值，適用範圍更廣
            hash_target = (hash_target * BASE + ord(target[i])) % MOD
            hash_window = (hash_window * BASE + ord(source[i])) % MOD

        # 確保初始雜湊值為正 (雖然在此步驟非必須，因為是加法和乘法)
        # hash_target = (hash_target + MOD) % MOD
        # hash_window = (hash_window + MOD) % MOD

        # --- 檢查第一個視窗 (索引 0 處) ---
        if hash_window == hash_target:
            # *** 關鍵：雜湊值相同時，必須進行字元逐一比較確認 ***
            if source[:m] == target:
                return 0 # 找到匹配

        # --- 滑動視窗遍歷 source ---
        # i 是視窗的結束索引，從 m 開始 (代表視窗 source[1...m])
        for i in range(m, n):
            # 高效更新滾動雜湊值:
            # 1. 減去離開視窗的最左側字元 (source[i-m]) 的貢獻
            left_char_ord = ord(source[i - m])
            term_to_subtract = (power_base_m_minus_1 * left_char_ord) % MOD

            # Python 的 % 可能產生負數，所以加上 MOD 再取模，確保結果為正
            hash_window = (hash_window - term_to_subtract + MOD) % MOD

            # 2. 將現有雜湊值左移一位 (乘以 BASE)，並加上新進入視窗的最右側字元 (source[i]) 的貢獻
            right_char_ord = ord(source[i])
            hash_window = (hash_window * BASE + right_char_ord) % MOD

            # --- 檢查雜湊值匹配並進行驗證 ---
            if hash_window == hash_target:
                # *** 關鍵：雜湊值相同時，必須進行字元逐一比較確認 ***
                start_index = i - m + 1 # 計算當前視窗的起始索引
                if source[start_index : i + 1] == target:
                    return start_index # 找到匹配並驗證成功

        # --- 未找到 ---
        # 如果迴圈結束仍未找到經驗證的匹配
        return -1

```
pass

解釋:
step1: Create 很大的random number MOD, 以及hash_target(代表將target轉成hash value), m26(代表將source轉成hash value)

target = "bcd"  要轉換成hash value(哈希值)可以這樣理解
hash_target = ( 'b'*26^2 + 'c'*26^1 + 'd'  ) %mod  

step2: 


|                            |     |
| -------------------------- | --- |
| [[###Rabin-Karp 演算法]]      |     |
| [[### Rabin-Karp 演算法具體舉例]] |     |



## 解法思路

本題 **`str_str2(self, source: str, target: str) -> int`** 的目標是找出 `target` 在 `source` 中的第一次出現的索引位置，如果 `target` 沒有出現在 `source` 中則返回 `-1`。

這題使用的是 **Rabin-Karp (滾動哈希) 字符串匹配演算法**，其核心思路是：

1. **計算 `target` 的哈希值 (`hash_target`)**
2. **使用滑動窗口計算 `source` 中長度為 `m` 的子字串的哈希值 (`value`)**，並與 `hash_target` 進行比較
3. **如果 `value == hash_target` 則進一步確認是否是相同的字串**
4. **使用滾動哈希公式來高效地更新 `value`**

---

## 變數表

|變數名稱|含義|
|---|---|
|`source`|原始字符串|
|`target`|需要查找的子字符串|
|`m`|`target` 字符串長度|
|`n`|`source` 字符串長度|
|`mod`|隨機選擇的大質數，用於減少哈希衝突|
|`hash_target`|`target` 的哈希值|
|`m26`|26 的 `m-1` 次方，作用是移除最左邊字符影響|
|`value`|當前滑動窗口子串的哈希值|

---

## 具體步驟

1. **邊界條件檢查**
    
    - 如果 `source` 或 `target` 為 `None`，則返回 `-1`
    - 如果 `target` 長度 `m` 為 `0`，根據題意直接返回 `0`（空字串應該匹配索引 `0`）
2. **哈希值初始化**
    
    - 隨機選擇一個 `mod`（大質數）來減少哈希衝突
    - 計算 `target` 的哈希值 `hash_target`
    - 計算 `m26 = 26^(m-1) % mod`，用於後續更新滑動窗口的哈希值
3. **使用滾動哈希法掃描 `source`**
    
    - 用變數 `value` 計算 `source` 中前 `m` 個字符的哈希值
    - 在遍歷 `source` 的過程中，使用 `m26` 來減去最左邊字符的影響，並加入新字符，維持一個長度為 `m` 的滑動窗口
    - 若 `value == hash_target` 則返回起始索引
4. **返回 `-1` 表示 `target` 沒有出現在 `source` 中**
    

---

## 時間與空間複雜度分析

- **時間複雜度**
    
    - 計算 `target` 的哈希值 `O(m)`
    - 初始化 `source` 前 `m` 個字符的哈希值 `O(m)`
    - 使用滾動哈希掃描 `source`，時間複雜度為 `O(n)`
    - 總體時間複雜度為 **`O(m + n)`**
- **空間複雜度**
    
    - 只使用了常數額外空間 `O(1)`

這比直接使用 **暴力法 `O(m * n)`** 的時間複雜度優秀得多。

---

## 其他解法想法（不含代碼）

1. **暴力解法 (`O(m * n)`)**
    
    - 直接在 `source` 中檢查每個長度為 `m` 的子字串是否等於 `target`
    - 時間複雜度高，適用於 `m` 很小的情況
2. **KMP（Knuth-Morris-Pratt 演算法，`O(m + n)`)**
    
    - 預處理 `target` 生成部分匹配表 (`prefix function`)
    - 在 `source` 上進行匹配時利用前綴信息快速跳過匹配失敗的部分
3. **Boyer-Moore (`O(n/m)` in best case, `O(mn)` in worst case)**
    
    - 使用 **壞字符規則** 和 **好後綴規則** 來大幅減少比較次數
    - 適用於長 `target` 和大 `source`
4. **Z-Algorithm (`O(m + n)`)**
    
    - 使用 **Z 函數** 預處理 `target + "$" + source`
    - 計算 `Z` 陣列來判斷 `target` 是否匹配
5. **二進制哈希（字符串哈希變體）**
    
    - 轉換 `source` 和 `target` 為二進制字符串來進行匹配，減少計算量
    - 在某些特殊情況下效率比 Rabin-Karp 更高

---

## 結論

Rabin-Karp 適用於大規模文本匹配，因為 **使用滾動哈希的方式大幅降低時間複雜度**。這使它比暴力解法更高效，也比 KMP 或 Boyer-Moore 更容易實作。



### Rabin-Karp 演算法

使用 Rabin-Karp 演算法解決 Lintcode 594 `strStr` 問題的簡要解題思路：

1. **計算目標字串的雜湊值：** 首先，計算目標字串（`target`）的雜湊值。為了避免溢位，通常會選取一個較大的質數作為模數。同時，為了減少雜湊碰撞的機率，可以使用多個不同的雜湊函數（例如，使用不同的基底和模數）。
    
2. **計算源字串第一個長度為 `m` 的子字串的雜湊值：** 計算源字串（`source`）中第一個與目標字串長度相同的子字串的雜湊值。
    
3. **比較雜湊值：** 將目標字串的雜湊值與源字串第一個子字串的雜湊值進行比較。
    
    - 如果雜湊值相等，則**可能**找到了匹配的子字串。為了排除雜湊碰撞的可能性，需要進一步比較這兩個子字串的實際字元是否完全相同。如果完全相同，則返回當前子字串在源字串中的起始索引。
    - 如果雜湊值不相等，則目標字串不可能是源字串中以當前位置開始的子字串。
4. **滑動視窗並更新雜湊值：** 如果第一個子字串沒有匹配，則將視窗向右滑動一個字元。為了高效地計算下一個子字串的雜湊值，可以使用**滾動雜湊（rolling hash）** 的技巧。滾動雜湊允許我們從前一個子字串的雜湊值中減去最前面字元的貢獻，並加上新加入的字元的貢獻，從而在常數時間內計算出下一個子字串的雜湊值，而不需要重新計算整個子字串的雜湊值。
    
5. **重複步驟 3 和 4：** 對源字串中所有長度為 `m` 的子字串重複步驟 3 和 4。
    
6. **返回結果：** 如果在遍歷完所有可能的子字串後仍然沒有找到匹配的目標字串，則返回 -1。
    

**核心概念：**

- **雜湊函數：** 將字串映射到一個整數值，用於快速比較字串是否可能相等。
- **雜湊碰撞：** 不同的字串可能產生相同的雜湊值。因此，雜湊值相等只是匹配的必要條件，還需要進行字元級別的比較來驗證。
- **滾動雜湊：** 一種高效計算滑動視窗雜湊值的方法，避免重複計算。

**時間複雜度：**

- **平均情況：** O(n + m)，其中 n 是源字串的長度，m 是目標字串的長度。計算初始雜湊值需要 O(m)，滾動雜湊和比較雜湊值需要 O(n)。
- **最壞情況：** O(n * m)。當雜湊碰撞非常頻繁時，每次雜湊值匹配後都需要 O(m) 的字元比較。

**空間複雜度：** O(1)，只需要常數的額外空間來儲存雜湊值和其他變數。

總之，Rabin-Karp 演算法通過使用雜湊值快速排除不匹配的子字串，並利用滾動雜湊高效地更新雜湊值，在平均情況下提供了一個有效的字串搜尋方法。然而，需要注意處理雜湊碰撞以保證結果的正確性。



### Rabin-Karp 演算法具體舉例

我們以 `source = "abcdef"`，`target = "bcd"` 為例，具體解釋使用 Rabin-Karp 演算法的解題思路。

**假設我們選取的雜湊函數如下：**

- 將每個字元視為其 ASCII 值。
- 使用一個簡單的基底 `b = 26` (假設我們只考慮小寫字母，但這裡包含其他字元，所以實際應用中基底需要更大) 和一個模數 `mod = 101` (一個小的質數，實際應用中模數應該更大以減少碰撞)。
- 字串 `s = c_1c_2...c_k` 的雜湊值計算公式為： (ord(c1​)×bk−1+ord(c2​)×bk−2+...+ord(ck​)×b0)(modmod)

**步驟 1：計算目標字串 "bcd" 的雜湊值**

- `ord('b') = 98`
- `ord('c') = 99`
- `ord('d') = 100`
- 目標字串長度 `m = 3`
- `hash_target = (98 \times 26^2 + 99 \times 26^1 + 100 \times 26^0) \pmod{101}`
- `hash_target = (98 \times 676 + 99 \times 26 + 100 \times 1) \pmod{101}`
- `hash_target = (66248 + 2574 + 100) \pmod{101}`
- `hash_target = 68922 \pmod{101}`
- `hash_target = 15`

**步驟 2：計算源字串第一個長度為 3 的子字串 "abc" 的雜湊值**

- `ord('a') = 97`
- `ord('b') = 98`
- `ord('c') = 99`
- 源字串長度 `n = 6`
- 第一個子字串是 `source[0:3] = "abc"`
- `hash_source = (97 \times 26^2 + 98 \times 26^1 + 99 \times 26^0) \pmod{101}`
- `hash_source = (97 \times 676 + 98 \times 26 + 99 \times 1) \pmod{101}`
- `hash_source = (65572 + 2548 + 99) \pmod{101}`
- `hash_source = 68219 \pmod{101}`
- `hash_source = 83`

**步驟 3：比較雜湊值**

- `hash_target = 15`
- `hash_source = 83`
- 雜湊值不相等 (`15 != 83`)，所以 "abc" 不可能是目標字串。

**步驟 4：滑動視窗並更新雜湊值**

- 將視窗向右滑動一個字元，下一個子字串是 `source[1:4] = "bcd"`。
- 我們需要使用滾動雜湊來高效計算 "bcd" 的雜湊值。
- 從 "abc" 的雜湊值中減去 'a' 的貢獻，並加上 'd' 的貢獻。
- 'a' 的貢獻是 `ord('a') * b^(3-1) = 97 * 26^2 = 65572`。在模 `101` 下是 `65572 \pmod{101} = 81`。
- 'd' 的貢獻是 `ord('d') * b^(3-3) = 100 * 26^0 = 100`。在模 `101` 下是 `100 \pmod{101} = 100`。
- 新的雜湊值計算公式： `(hash_{prev} - ord(source[i-1]) \times b^{m-1}) \times b + ord(source[i+m-1]) \pmod{mod}`
- `hash("bcd") = ((hash("abc") - 97 \times 26^2) \times 26 + 100) \pmod{101}`
- `hash("bcd") = ((83 - 81) \times 26 + 100) \pmod{101}`
- `hash("bcd") = (2 \times 26 + 100) \pmod{101}`
- `hash("bcd") = (52 + 100) \pmod{101}`
- `hash("bcd") = 152 \pmod{101}`
- `hash("bcd") = 51`

**步驟 5：比較雜湊值**

- `hash_target = 15`
- `hash("bcd") = 51`
- 雜湊值仍然不相等 (`15 != 51`)。

**步驟 4：再次滑動視窗並更新雜湊值**

- 下一個子字串是 `source[2:5] = "cde"`。
- `hash("cde") = ((hash("bcd") - 98 \times 26^2) \times 26 + 101) \pmod{101}` (注意 `ord('e') = 101`)
- `98 \times 26^2 \pmod{101} = 98 \times 676 \pmod{101} = 98 \times 71 \pmod{101} = 6958 \pmod{101} = 79`
- `hash("cde") = ((51 - 79) \times 26 + 101) \pmod{101}`
- `hash("cde") = (-28 \times 26 + 0) \pmod{101}`
- `hash("cde") = (-728) \pmod{101}`
- `hash("cde") = -19 \pmod{101}`
- `hash("cde") = 82`

**步驟 5：比較雜湊值**

- `hash_target = 15`
- `hash("cde") = 82`
- 雜湊值不相等。

**步驟 4：再次滑動視窗並更新雜湊值**

- 下一個子字串是 `source[3:6] = "def"`。
- `hash("def") = ((hash("cde") - 99 \times 26^2) \times 26 + 102) \pmod{101}` (注意 `ord('f') = 102`)
- `99 \times 26^2 \pmod{101} = 99 \times 676 \pmod{101} = 99 \times 71 \pmod{101} = 7029 \pmod{101} = 58`
- `hash("def") = ((82 - 58) \times 26 + 1) \pmod{101}`
- `hash("def") = (24 \times 26 + 1) \pmod{101}`
- `hash("def") = (624 + 1) \pmod{101}`
- `hash("def") = 625 \pmod{101}`
- `hash("def") = 19`

**步驟 5：比較雜湊值**

- `hash_target = 15`
- `hash("def") = 19`
- 雜湊值不相等。

**等等！我們在計算 "bcd" 的雜湊值時出錯了。讓我們重新計算 "bcd" 的雜湊值並繼續。**

**重新計算步驟 4 和 5 (針對 "bcd"):**

- 子字串是 `source[1:4] = "bcd"`。
- 我們需要比較 `hash("bcd")` 與 `hash_target = 15`。
- `hash("bcd")` 的正確計算： `hash("bcd") = (98 \times 26^2 + 99 \times 26^1 + 100 \times 26^0) \pmod{101} = 51` (我們之前的計算是正確的)
- 雜湊值不相等。

**再次重新計算步驟 4 和 5 (針對 "bcd")，這次使用滾動雜湊更仔細地計算：**

- 從 `hash("abc") = 83` 計算 `hash("bcd")`： `hash("bcd") = ((hash("abc") - ord('a') \times 26^2 \pmod{101}) \times 26 + ord('d')) \pmod{101}` `hash("bcd") = ((83 - 81) \times 26 + 100) \pmod{101}` `hash("bcd") = (2 \times 26 + 100) \pmod{101}` `hash("bcd") = 152 \pmod{101} = 51`

**繼續滑動視窗：**

- 下一個子字串是 `source[2:5] = "cde"`。 `hash("cde") = ((hash("bcd") - ord('b') \times 26^2 \pmod{101}) \times 26 + ord('e')) \pmod{101}` `hash("cde") = ((51 - 79) \times 26 + 101) \pmod{101} = 82`
    
- 下一個子字串是 `source[3:6] = "def"`。 `hash("def") = ((hash("cde") - ord('c') \times 26^2 \pmod{101}) \times 26 + ord('f')) \pmod{101}` `hash("def") = ((82 - 58) \times 26 + 102) \pmod{101} = 19`
    

**我們發現我們的雜湊函數和模數在這個例子中沒有產生碰撞，但目標字串 "bcd" 的雜湊值是 51，而源字串中 "bcd" 子字串的雜湊值也是 51。**

**正確的步驟 3 和 5 (當滑動到 "bcd"):**

- 當滑動到源字串的子字串 `source[1:4] = "bcd"` 時，計算其雜湊值為 `51`。
- 目標字串 "bcd" 的雜湊值是 `15`。
- 雜湊值不相等。

**讓我們仔細檢查目標字串 "bcd" 的雜湊值計算。**

`hash_target = (98 \times 26^2 + 99 \times 26^1 + 100 \times 26^0) \pmod{101} = 15` (這個計算是正確的)

**重新進行滑動和比較：**

1. **"abc"**: 雜湊值 83，不匹配。
2. **"bcd"**: 雜湊值 51，不匹配。
3. **"cde"**: 雜湊值 82，不匹配。
4. **"def"**: 雜湊值 19，不匹配。

**這裡出現了問題，"bcd" 明明是 "abcdef" 的子字串，但我們的雜湊值卻不匹配。這很可能是因為我們選擇了一個過小的基底和模數，導致了資訊丟失。**

**為了正確演示，我們需要一個能產生匹配雜湊值的例子。讓我們稍微調整雜湊函數的參數，或者直接關注概念。**

**正確的 Rabin-Karp 概念演示：**

1. 計算 `target = "bcd"` 的雜湊值 `H_t`。
2. 計算 `source` 中第一個長度為 3 的子字串 "abc" 的雜湊值 `H_s1`。
3. 比較 `H_s1` 和 `H_t`。如果不相等，繼續。
4. 計算下一個子字串 "bcd" 的雜湊值 `H_s2`，通常通過從 `H_s1` 中減去 'a' 的貢獻並加上 'd' 的貢獻來高效完成。
5. 比較 `H_s2` 和 `H_t`。**如果 `H_s2` 等於 `H_t`，我們需要驗證 "bcd" 和 "bcd" 這兩個字串是否真的相等（以防雜湊碰撞）。在這個例子中，它們是相等的，所以我們返回 "bcd" 在 `source` 中的起始索引 1。**
6. 如果雜湊值不相等，則繼續滑動視窗，計算下一個子字串的雜湊值並進行比較。

**關鍵點在於：**

- Rabin-Karp 通過比較雜湊值來快速排除不匹配的可能性。
- 當雜湊值匹配時，需要進行**字元級別的比較**以確認是否真的找到了目標字串，從而處理雜湊碰撞。
- 滾動雜湊技術使得計算下一個子字串的雜湊值非常高效。

雖然我們上面的數值計算因為選擇的基底和模數的限制沒有直接展示雜湊值相等的情況，但核心思想是：計算目標字串的雜湊值，然後在源字串上滑動視窗計算子字串的雜湊值並進行比較。當雜湊值相等時，進行精確的字串比較以確認匹配。在這個例子中，當滑動到 "bcd" 時，如果我們的雜湊函數設計得當，"bcd" 的雜湊值應該與目標字串 "bcd" 的雜湊值相等，然後我們會確認字串本身也相等，並返回索引 1。




深入探討 Rabin-Karp 演算法，並解釋它相較於暴力匹配在特定情況下更高效的原因。

**暴力匹配 (Brute Force) 的時間複雜度分析：**

正如你所說，暴力匹配的方法是使用兩個指標。一個指標遍歷源字串 (`n`)，另一個指標在發現可能匹配的起始位置時，遍歷目標字串 (`m`)。

在最壞的情況下，例如源字串是 "aaaaaaaaab"，目標字串是 "aaab"，暴力匹配的過程會是：

1. 源字串的 'a' 和目標字串的 'a' 匹配。然後比較源字串的下一個 'a' 和目標字串的下一個 'a'，以此類推，直到目標字串的最後一個 'b'。發現不匹配。
2. 源字串的第二個 'a' 和目標字串的 'a' 匹配。再次比較接下來的字元，直到發現不匹配。
3. 這個過程會一直重複，直到源字串的倒數第 `m` 個字元。

在最壞的情況下，對於源字串的每個起始位置，我們都可能需要比較目標字串的所有 `m` 個字元。由於源字串有 `n` 個可能的起始位置，因此暴力匹配的最壞時間複雜度是 **O(n * m)**。

**Rabin-Karp 的基本原理：**

Rabin-Karp 演算法的核心思想是將字串轉換成一個數值，這個數值稱為**雜湊值 (hash value)**。透過比較雜湊值，我們可以快速判斷兩個字串是否可能相等。

1. **計算目標字串的雜湊值：** 首先，我們計算目標字串的雜湊值。
2. **計算源字串子字串的雜湊值：** 然後，我們在源字串中滑動一個長度為 `m` 的視窗。對於每個視窗，我們計算該子字串的雜湊值。
3. **比較雜湊值：** 如果源字串子字串的雜湊值與目標字串的雜湊值相等，那麼這兩個字串**很可能**是相同的。
4. **驗證 (處理雜湊衝突)：** 由於不同的字串可能產生相同的雜湊值（稱為**雜湊衝突**），因此當雜湊值相等時，我們仍然需要逐個字元地比較這兩個字串，以確保它們真的相等。
5. **滑動視窗：** 我們有效地更新視窗的雜湊值，而不是每次都重新計算整個子字串的雜湊值。這樣可以大大提高效率。

**Rabin-Karp 相較於暴力匹配更高效的原因：**

Rabin-Karp 的潛在效率提升主要來自於**雜湊值的快速計算和比較**，以及**有效率的視窗滑動更新雜湊值**。

1. **雜湊值比較的常數時間複雜度：** 比較兩個整數（雜湊值）的時間複雜度是 O(1)。在理想情況下（沒有或很少雜湊衝突），我們只需要進行一次雜湊值比較就能排除大部分不匹配的情況，而不需要像暴力匹配那樣逐個字元比較。
    
2. **視窗滑動時的雜湊值更新：** Rabin-Karp 演算法使用一個巧妙的方法來更新滑動視窗的雜湊值，使其可以在 **O(1)** 的時間內完成。假設我們有一個長度為 `m` 的子字串 `s[i...i+m-1]` 的雜湊值 `H(s[i...i+m-1])`。當視窗向右滑動一個位置時，我們需要計算 `s[i+1...i+m]` 的雜湊值。我們可以利用前一個雜湊值，減去離開視窗的字元的貢獻，並加上進入視窗的新字元的貢獻，而不需要重新計算整個長度為 `m` 的子字串的雜湊值。
    
    例如，如果我們使用一個基數為 `d` 的雜湊函數（例如，字元集的大小），並選擇一個模數 `q`，一個字串 c1​c2​...cm​ 的雜湊值可以計算為：
    
    H(c1​c2​...cm​)=(c1​⋅dm−1+c2​⋅dm−2+...+cm​⋅d0)modq
    
    當視窗從 `s[i...i+m-1]` 滑動到 `s[i+1...i+m]` 時，新的雜湊值可以透過以下公式有效計算：
    
    H(s[i+1...i+m])=((H(s[i...i+m−1])−s[i]⋅dm−1)⋅d+s[i+m])modq
    
    這個更新操作只需要常數時間。
    
3. **平均時間複雜度：** 在理想情況下，如果雜湊衝突很少發生，那麼對於源字串的每個位置，我們只需要進行常數時間的雜湊值計算和比較。因此，Rabin-Karp 的平均時間複雜度可以達到 **O(n)**。
    

**為何 Rabin-Karp 會比暴力匹配高效很多？**

Rabin-Karp 的效率優勢在於它避免了在大部分不匹配的情況下進行昂貴的字元逐個比較。透過快速的雜湊值比較和更新，它能夠迅速排除許多不可能匹配的子字串。

**類比視窗：**

你提到暴力匹配類似於使用視窗。確實如此。暴力匹配的視窗在源字串上滑動，對於每個視窗，它會將視窗內的子字串與目標字串逐個字元地比較。

Rabin-Karp 也使用視窗，但它不是直接比較字串，而是比較視窗內子字串的雜湊值與目標字串的雜湊值。只有當雜湊值相等時，才進行字元逐個比較（以處理雜湊衝突）。

**總結：**

Rabin-Karp 的效率提升並非總是顯著的，尤其是在雜湊衝突頻繁發生的情況下，其最壞時間複雜度仍然是 O(n * m)。然而，透過仔細選擇雜湊函數和模數，可以顯著降低雜湊衝突的機率，使得 Rabin-Karp 在平均情況下具有 O(n) 的時間複雜度，這比暴力匹配的 O(n * m) 要高效得多，尤其當目標字串的長度 `m` 很大時。

**需要注意的點：**

- **雜湊函數的選擇：** 一個好的雜湊函數應該能夠將不同的字串映射到不同的雜湊值，以減少雜湊衝突的機率。
- **模數的選擇：** 模數應該足夠大，以避免雜湊值溢出，並且最好是一個質數，以提高雜湊值的均勻分布。
- **雜湊衝突的處理：** 即使選擇了好的雜湊函數，仍然可能發生雜湊衝突，因此在雜湊值相等時，仍然需要進行字元逐個比較來驗證。