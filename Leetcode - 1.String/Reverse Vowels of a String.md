Lintcode 1282
写一个方法，接受给定字符串作为输入，并且只翻转字符串中的元音字母。

**样例 1:**
```python
"""
输入 : s = "hello"
输出 : "holle"
```
**样例 2:**
```python
"""
输入 : s = "lintcode"
输出 : "lentcodi".
```



```python
    def reverse_vowels(self, s: str) -> str:
        def isVowel(ch: str) -> bool:
            return ch in "aeiouAEIOU"
        
        n = len(s)
        s = list(s)
        i, j = 0, n - 1
        while i < j:
            while i < n and not isVowel(s[i]):
                i += 1
            while j > 0 and not isVowel(s[j]):
                j -= 1
            if i < j:
                s[i], s[j] = s[j], s[i]
                i += 1
                j -= 1
        
        return "".join(s)
```
pass


## **解法思路**

本題 **`reverse_vowels(self, s: str) -> str`** 的目標是將輸入字符串 `s` **中的元音字母反轉**，但其他字符保持原順序。

例如：

- `"hello"` → `"holle"`
- `"leetcode"` → `"leotcede"`

### **核心思想**

此解法使用 **雙指針 (Two Pointers)** 方法，從 **字符串的頭 (`i`) 和尾 (`j`) 同時遍歷**，並互換元音字母的位置，直到兩指針相遇。這樣可以達到 **O(n) 線性時間複雜度** 的解法。

---

## **變數表**

|變數名稱|含義|
|---|---|
|`s`|輸入的字符串（轉換成列表以支援修改）|
|`isVowel(ch)`|判斷 `ch` 是否為元音（'a', 'e', 'i', 'o', 'u'，大小寫皆適用）|
|`n`|字符串 `s` 的長度|
|`i`|指向左側的指針，負責找 **元音**|
|`j`|指向右側的指針，負責找 **元音**|

---

## **具體步驟**

1. **將字符串轉為列表 (`list(s)`)**
    
    - 因為 Python 的字符串是 **不可變的 (immutable)**，我們需要將其轉換為 **列表** 才能進行原地修改。
2. **初始化雙指針**
    
    - `i = 0`，從頭開始
    - `j = n - 1`，從尾巴開始
3. **使用雙指針找到元音**
    
    - **左指針 (`i`)** 向右移動，直到遇到 **元音**
    - **右指針 (`j`)** 向左移動，直到遇到 **元音**
    - 當 `i < j` 時，**交換 `s[i]` 和 `s[j]`，然後繼續前進**
4. **停止條件**
    
    - 當 `i >= j` 時，說明所有元音都已交換，結束迴圈。
5. **將列表轉回字符串 (`"".join(s)`)**，返回結果。
    

---

## **範例解析**

### **範例 1**

python

複製編輯

`s = "hello"`

**步驟**

|`i`|`j`|`s[i]`|`s[j]`|操作|變化|
|---|---|---|---|---|---|
|0|4|`h`|`o`|跳過 `h`|`"hello"`|
|1|4|`e`|`o`|交換 `e` 和 `o`|`"holle"`|
|2|3|`l`|`l`|跳過|`"holle"`|
|3|2|**指針相遇，停止**||||

**結果**：`"holle"`

---

### **範例 2**

python

複製編輯

`s = "leetcode"`

**步驟**

|`i`|`j`|`s[i]`|`s[j]`|操作|變化|
|---|---|---|---|---|---|
|0|7|`l`|`e`|跳過 `l`|`"leetcode"`|
|1|7|`e`|`e`|交換 `e` 和 `e`|`"leetcode"`|
|2|6|`o`|`d`|跳過 `d`|`"leetcode"`|
|2|5|`o`|`o`|交換 `o` 和 `o`|`"leotcede"`|
|3|4|`t`|`c`|跳過|`"leotcede"`|
|**指針相遇，停止**||||||

**結果**：`"leotcede"`

---

## **時間與空間複雜度分析**

- **時間複雜度**
    
    - 雙指針最多只會遍歷 `s` **一次**，每個字符最多訪問兩次，因此時間複雜度為 **`O(n)`**。
    - 相較於暴力法（遍歷所有可能的元音對應組合）`O(n^2)`，此方法更高效。
- **空間複雜度**
    
    - 只使用了 **固定額外變數 (`O(1)`)**，在 **原地 (in-place) 修改** `s`，不佔用額外空間。
    - 若字符串 `s` 是不可變的，則轉換 `list(s)` 需要 **`O(n)`** 額外空間。

---

## **其他解法想法（不含代碼）**

6. **使用 `stack` 存放元音 (`O(n)`)**
    
    - 先遍歷 `s`，將所有元音存入 `stack`
    - 再次遍歷 `s`，遇到元音則從 `stack` 取出 **最後一個元音**（即逆序插入）
    - 時間複雜度 `O(n)`，但使用額外 `O(k)` 空間（`k` 為元音個數）
7. **使用 `deque` 雙端隊列 (`O(n)`)**
    
    - 與 `stack` 類似，但可以用 `collections.deque()` **雙端操作**
    - 先存元音，再逆序取出替換
8. **建立元音索引陣列，最後進行交換 (`O(n)`)**
    
    - 先遍歷 `s`，記錄所有元音的位置
    - 使用 `two pointers` 進行交換
    - 需要額外 `O(k)` 空間來存元音位置

---

## **結論**

- **最佳方法**：**雙指針 (Two Pointers)**，時間 `O(n)`，空間 `O(1)`
- **可替代方法**：
    - **Stack / Deque (`O(n)`)**：適合若 `s` **不可變** 的情況
    - **記錄元音索引 (`O(n)`)**：適合大規模數據時優化

本題的 **雙指針解法** 是最優解，因為它是 **線性時間 `O(n)`** 且 **原地修改，不需要額外空間**，適用於大部分情境。