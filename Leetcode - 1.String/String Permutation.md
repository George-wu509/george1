Lintcode 1169
给定两个字符串`s1`和`s2`，如果`s2`包含`s1`的排列，则写一个函数返回true。 换句话说，第一个字符串的排列之一是第二个字符串的`substring`。

**样例1:**
```python
"""
输入: s1 = "ab" s2 = "eidbaooo"
输出: true
解释: s2包含s1的一个排列("ba").
```
**样例2:**
```python
"""
输入: s1= "ab" s2 = "eidboaoo"
输出: false
```




```python
def check_inclusion(self, s1: str, s2: str) -> bool:
	n,m = len(s1), len(s2)
	if n > m: return False
	cnt1, cnt2 = [0]*26, [0]*26
	for i in range(n):
		cnt1[ord(s1[i])-ord('a')] += 1
		cnt2[ord(s2[i])-ord('a')] += 1
	if cnt1 == cnt2:
		return True
	for i in range(n,m):
		cnt2[ord(s2[i])-ord('a')] += 1
		cnt2[ord(s2[i-n])-ord('a')] -= 1
		if cnt1 == cnt2:
			return True
	return False
```
pass


本題 **`check_inclusion(self, s1: str, s2: str) -> bool`** 的目標是判斷 `s1` 是否為 `s2` 的某個**子字串的排列**。

**核心概念**：

- **若 `s1` 是 `s2` 的某個子串的排列，則該子串內的字母組成和 `s1` 一致**，但順序可變。
- **使用滑動窗口 (Sliding Window) + 字母頻率計數** 來高效判斷。

---

## **變數表**

|變數名稱|含義|
|---|---|
|`s1`|需要檢查的排列子串|
|`s2`|搜尋 `s1` 排列的來源字符串|
|`n`|`s1` 的長度|
|`m`|`s2` 的長度|
|`cnt1`|`s1` 的字符頻率統計，`cnt1[i]` 表示字母 `i` (從 `'a'` 開始計數) 的出現次數|
|`cnt2`|`s2` 當前滑動窗口的字符頻率統計，`cnt2[i]` 表示字母 `i` 在當前窗口的出現次數|

---

## **具體步驟**

1. **邊界條件檢查**
    
    - 若 `n > m`，則 `s1` **長度大於** `s2`，不可能是其子串，直接返回 `False`。
2. **統計 `s1` 的字符頻率 (`cnt1`)**
    
    - 用大小為 `26` 的陣列 `cnt1`，記錄 `s1` 中每個字母的出現次數。
3. **初始化 `s2` 的前 `n` 個字符頻率 (`cnt2`)**
    
    - 建立 `cnt2` 陣列，計算 `s2` **前 `n` 個字符** 的頻率，代表第一個滑動窗口。
4. **檢查第一個窗口 (`cnt1 == cnt2`)**
    
    - 若 `cnt1 == cnt2`，則表示 `s1` **是 `s2` 開頭 `n` 個字符的排列**，返回 `True`。
5. **使用滑動窗口遍歷 `s2`**
    
    - **加入右側新字符 `s2[i]`，刪除左側舊字符 `s2[i-n]`**
    - 每次滑動後，檢查 `cnt1 == cnt2`，若相等則返回 `True`。
6. **若遍歷完成後仍未找到對應排列，則返回 `False`**
    

---

## **範例解析**

### **範例 1**

python

複製編輯

`s1 = "ab" s2 = "eidbaooo"`

**步驟**

|i|當前窗口|`cnt2` (頻率計數)|`cnt1 == cnt2`|
|---|---|---|---|
|0|"ei"|`[0,0,1,0,1,...]`|False|
|1|"id"|`[0,0,1,1,0,...]`|False|
|2|"db"|`[0,1,0,1,0,...]`|False|
|3|"ba"|`[1,1,0,0,0,...]`|**True**|

**結果**：`True`（`"ba"` 是 `"ab"` 的排列）

---

### **範例 2**

python

複製編輯

`s1 = "abc" s2 = "bbbca"`

**步驟**

|i|當前窗口|`cnt2` (頻率計數)|`cnt1 == cnt2`|
|---|---|---|---|
|0|"bbb"|`[0,3,0,...]`|False|
|1|"bbc"|`[0,2,1,...]`|False|
|2|"bca"|`[1,1,1,...]`|**True**|

**結果**：`True`（`"bca"` 是 `"abc"` 的排列）

---

## **時間與空間複雜度分析**

- **時間複雜度**
    
    - 初始化 `cnt1` 和 `cnt2`：`O(n)`
    - 遍歷 `s2`（滑動窗口）：`O(m - n)`
    - **總體時間複雜度為 `O(n + (m - n)) = O(m)`**
- **空間複雜度**
    
    - 只用了兩個大小為 `26` 的陣列 `cnt1` 和 `cnt2`，**空間複雜度 `O(1)`**（因為英文字母數量是固定的）

---

## **其他解法想法（不含代碼）**

1. **暴力解法 (`O(n * m!)`)**
    
    - 生成 `s1` 的所有排列（`n!` 程度），然後在 `s2` 中檢查每個排列是否出現過。
    - 時間複雜度極高，完全不可行。
2. **Rabin-Karp (滾動哈希) (`O(m)`)**
    
    - 用一個哈希函數計算 `s1` 的哈希值，並用滾動哈希方法計算 `s2` 的每個長度為 `n` 的子串哈希值來比對。
    - 若哈希值相等，進行額外檢查來避免哈希碰撞。
3. **Boyer-Moore 字符串匹配 (`O(n + m)`)**
    
    - 當 `s1` 很短而 `s2` 很長時，使用 `Boyer-Moore` 可跳過大量無用匹配點，加速檢索。
4. **位運算最佳化 (`O(m)`)**
    
    - 將 `cnt1` 和 `cnt2` 用 **32-bit 整數** 表示，每次滑動只需 `O(1)` 的運算來更新頻率，能加快運算速度。

---

## **結論**

- **最佳方法** 為 **滑動窗口 + 字符頻率計數**，時間複雜度 `O(m)`，空間複雜度 `O(1)`。
- 其他如 **暴力法** 和 **全排列法** 適用於 `s1` 非常短的情況。
- **Rabin-Karp** 和 **Boyer-Moore** 可作為替代方法，但未必更快。

這樣的做法使得問題能夠高效解決，適合大規模的 `s2` 進行搜索。