Lintcode 927
给定一个字符串，请你反转字符串中**单词**的顺序。
单词被定义为不包含空格的字符串，输入字符串数组不包含前导或尾部空格，单词总是用单个空格分隔。

**样例1**
```python
"""
输入: s = "the sky is blue"
输出: "blue is sky the"
```
**样例2**
```python
"""
输入: "a b c"
输出: "c b a"
```


```python
class Solution:
    def trim_spaces(self, s: str) -> list:
        left, right = 0, len(s) - 1
        # 去掉字符串开头的空白字符
        while left <= right and s[left] == ' ':
            left += 1
        
        # 去掉字符串末尾的空白字符
        while left <= right and s[right] == ' ':
            right -= 1
        
        # 将字符串间多余的空白字符去除
        output = []
        while left <= right:
            if s[left] != ' ':
                output.append(s[left])
            elif output[-1] != ' ':
                output.append(s[left])
            left += 1
        
        return output
            
    def reverse(self, l: list, left: int, right: int) -> None:
        while left < right:
            l[left], l[right] = l[right], l[left]
            left, right = left + 1, right - 1
            
    def reverse_each_word(self, l: list) -> None:
        n = len(l)
        start = end = 0
        
        while start < n:
            # 循环至单词的末尾
            while end < n and l[end] != ' ':
                end += 1
            # 翻转单词
            self.reverse(l, start, end - 1)
            # 更新start，去找下一个单词
            start = end + 1
            end += 1
                
    def reverse_words(self, s: str) -> str:
        l = self.trim_spaces(s)
        
        # 翻转字符串
        self.reverse(l, 0, len(l) - 1)
        
        # 翻转每个单词
        self.reverse_each_word(l)
        
        return ''.join(l)
```
pass

一起探討這兩種反轉字串中單字順序的解法。讓我們仔細比較一下它們的思路和優缺點。

**解法一：簡潔之道**

這個解法非常簡潔，它巧妙地利用了 Python 內建的字串處理函數：

1. `s.strip()`: 這個函數會移除字串 `s` 開頭和結尾的空白字元。根據題目描述，輸入字串不包含這些空白，所以這個步驟在這個特定情境下是多餘的，但它使解法更具通用性，能處理可能包含前後空白的輸入。
2. `s.strip().split()`: 接著，`split()` 方法會將處理後的字串以空格為分隔符分割成一個單字列表。
3. `reversed(...)`: `reversed()` 函數會返回一個反向迭代器，用於遍歷單字列表。
4. `' '.join(...)`: 最後，`join()` 方法會使用空格將反向迭代器中的單字重新連接成一個字串。

**優點：**

- **簡潔易懂：** 這個解法只需要一行程式碼，邏輯清晰，非常容易理解和閱讀。
- **高效便捷：** Python 的內建函數通常經過高度優化，執行效率不錯。

**缺點：**

- **依賴內建函數：** 如果在不允許使用這些內建函數的環境下，這個解法就無法使用。
- **空間複雜度：** `split()` 會創建一個新的單字列表，因此空間複雜度是 O(n)，其中 n 是字串中單字的數量。

**解法二：逐步操作**

這個解法採取了更為底層的操作方式，逐步完成任務：

1. `trim_spaces(self, s: str) -> list`: 這個方法首先手動去除字串開頭和結尾的空白，然後遍歷字串，將單字和單個空格添加到 `output` 列表中，有效地處理了單字之間可能存在的多個空格。
2. `reverse(self, l: list, left: int, right: int) -> None`: 這是一個通用的原地反轉列表指定範圍元素的輔助函數。
3. `reverse_each_word(self, l: list) -> None`: 這個方法遍歷單字列表 `l`，識別出每個單字的起始和結束位置，然後使用 `self.reverse()` 方法原地反轉每個單字。
4. `reverse_words(self, s: str) -> str`: 這個主方法首先調用 `trim_spaces()` 處理輸入字串，然後對整個處理後的列表進行反轉（此時單字的順序是反的，但單字本身也是反的），最後再調用 `reverse_each_word()` 來反轉每個單字，從而得到最終的結果。

**優點：**

- **更底層的控制：** 這個解法完全依靠手動操作，更能理解字串和列表處理的細節。
- **可能更節省空間：** 雖然 `trim_spaces` 仍然創建了一個新的列表，但後續的反轉操作都是在原地進行的，如果輸入字串中有多餘的空格，`trim_spaces` 實際上可以縮減列表的長度，在某些情況下可能比解法一更節省空間。

**缺點：**

- **程式碼較長且複雜：** 相較於解法一，這個解法需要編寫更多的程式碼，邏輯也更為複雜，理解和調試的難度較高。
- **效率可能稍低：** 由於涉及到更多的手動遍歷和操作，在處理非常長的字串時，效率可能不如直接使用內建函數的解法一。

**總結比較**

|特性|解法一 (簡潔之道)|解法二 (逐步操作)|
|---|---|---|
|程式碼長度|短|長|
|可讀性|高|中|
|理解難度|低|高|
|依賴內建函數|是|否 (核心反轉邏輯是手動實現)|
|空間複雜度|O(n) (創建單字列表)|最壞情況 O(n) (創建處理後的列表)，可能更優|
|時間複雜度|通常較好 (內建函數優化)|可能稍差 (更多手動遍歷)|
|通用性|良好 (能處理前後空白，但題目已說明無)|良好 (更能處理單字間的多個空格)|

**在給定的題目情境下（輸入字串不包含前導或尾部空格，單字總是用單個空格分隔）：**

解法一通常是更優的選擇，因為它更簡潔、易懂且效率通常不錯。解法二雖然提供了更底層的控制，但在這個特定問題上顯得有些過於複雜。

然而，如果題目條件更加複雜，例如輸入字串可能包含多個連續空格，或者不允許使用某些內建函數，那麼解法二的逐步操作方式可能會更具優勢，因為它可以更精細地控制字串的處理過程。

希望這個比較對您有所幫助！如果您還有其他問題，歡迎隨時提出。