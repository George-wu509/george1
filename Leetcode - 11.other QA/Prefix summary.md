
在數組處理中，「**前綴和 (Prefix Sum)**」、「**後綴和 (Suffix Sum)**」、「**前綴積 (Prefix Product)**」和「**後綴積 (Suffix Product)**」是常見的計算方式，它們的計算方式如下：

---


|                                    | nums = [1, 2, 3, 4]                   |     |
| ---------------------------------- | ------------------------------------- | --- |
| 前綴和 (Prefix Sum)                   | prefix_sum = [0, 1, 3, 6, 10]         |     |
| 後綴和 (Suffix Sum)                   | suffix_sum = [10, 9, 7, 4, 0]         |     |
| 前綴積 (Prefix Product)               | prefix_product = [1, 1, 2, 6, 24]     |     |
| 後綴積 (Suffix Product)               | suffix_product = [24, 24, 12, 4, 1]   |     |
|                                    |                                       |     |
| nums[1:3] 區域內和<br>=nums[1]+nums[2] | prefix_sum[3] - refix_sum[1]          |     |
| output[2] 元素以外乘積                   | Prefix Product[2] x Suffix Product[3] |     |

|                                  |     |
| -------------------------------- | --- |
| [[### 何時用前綴和? 何時用Two pointers?]] |     |
|                                  |     |
|                                  |     |

### 1. **前綴和 (Prefix Sum)**

**定義**：前綴和是指從數組的第一個元素開始，累積到當前元素的總和。

**計算方式**：

- `prefix_sum[i] = nums[0] + nums[1] + ... + nums[i]`
- 以 `nums = [1, 2, 3, 4]` 為例：

prefix_sum[0] = 1  
prefix_sum[1] = 1 + 2 = 3  
prefix_sum[2] = 1 + 2 + 3 = 6  
prefix_sum[3] = 1 + 2 + 3 + 4 = 10  

**結果**：

`prefix_sum = [1, 3, 6, 10]`

**應用**：
	`Sum[1,2,3] = nums[1]+ nums[2]+ nums[3]`
	`= prefix-sum[3] - prefix-sum[0] =10-1 = 9` 

- **區間和查詢 (Range Sum Query, RSQ)**，用來快速計算某段範圍 `[l, r]` 的總和 ，時間複雜度從 `O(n)` 降至 `O(1)`。總和=prefix[r] - prefix[l-1]
- **動態規劃 (Dynamic Programming)** 的狀態轉移時，常用來快速查詢累計和。

---

### 2. **後綴和 (Suffix Sum)**

**定義**：後綴和是指從數組的最後一個元素開始，累積到當前元素的總和。

**計算方式**：

- `suffix_sum[i] = nums[i] + nums[i+1] + ... + nums[n-1]`
- 以 `nums = [1, 2, 3, 4]` 為例：

suffix_sum[3] = 4  
suffix_sum[2] = 3 + 4 = 7  
suffix_sum[1] = 2 + 3 + 4 = 9  
suffix_sum[0] = 1 + 2 + 3 + 4 = 10  

**結果**：

`suffix_sum = [10, 9, 7, 4]`

**應用**：

- 在某些需要從後往前處理數組的問題，例如 **右側區間和查詢** 或 **滑動窗口問題**。

---

### 3. **前綴積 (Prefix Product)**

**定義**：前綴積是指從數組的第一個元素開始，累積到當前元素的乘積。

**計算方式**：

- `prefix_product[i] = nums[0] * nums[1] * ... * nums[i]`
- 以 `nums = [1, 2, 3, 4]` 為例：

prefix_product[0] = 1  
prefix_product[1] = 1 * 2 = 2  
prefix_product[2] = 1 * 2 * 3 = 6  
prefix_product[3] = 1 * 2 * 3 * 4 = 24  


**結果**：

`prefix_product = [1, 2, 6, 24]`

**應用**：
    Product[1,2,3] = nums[1]  * nums[2]  * nums[3] 

- 用於 **乘積查詢問題** 或 **求某元素除自身外的乘積 (Product of Array Except Self)**，這在 Leetcode/Lintcode 上是一道經典題。
- **解法（使用前綴積與後綴積）**：

1. 計算 `prefix_product`，存儲從 `0` 到 `i-1` 的乘積。prefix_product[i-1] 
2. 計算 `suffix_product`，存儲從 `i+1` 到 `n-1` 的乘積。prefix_product[i+1] 
3. `output[i] = prefix_product[i-1] × suffix_product[i+1]`

---

### 4. **後綴積 (Suffix Product)**

**定義**：後綴積是指從數組的最後一個元素開始，累積到當前元素的乘積。

**計算方式**：

- `suffix_product[i] = nums[i] * nums[i+1] * ... * nums[n-1]`
- 以 `nums = [1, 2, 3, 4]` 為例：

suffix_product[3] = 4  
suffix_product[2] = 3 * 4 = 12  
suffix_product[1] = 2 * 3 * 4 = 24  
suffix_product[0] = 1 * 2 * 3 * 4 = 24  


**結果**：

`suffix_product = [24, 24, 12, 4]`

**應用**：

- 用於 **求某元素除自身外的乘積 (Product of Array Except Self)** 問題，避免直接計算所有元素相乘再除以當前元素，從而提高效率。

---

### 📌 **應用於 LintCode / LeetCode**

這些前綴和、後綴和、前綴積、後綴積的概念在競程 (competitive programming) 和演算法問題中有很多應用，例如：

1. **Leetcode 303. Range Sum Query - Immutable**
    
    - 使用前綴和來高效計算區間和。
2. **Leetcode 238. Product of Array Except Self**
    
    - 透過前綴積和後綴積來計算 **不使用除法** 的解法。
3. **LintCode 206. Interval Sum**
    
    - 使用前綴和來優化區間查詢。
4. **LintCode 665. Range Sum Query II**
    
    - 動態更新數組時的區間和查詢，結合前綴和與樹狀數組 (Fenwick Tree)。
5. **Leetcode 560. Subarray Sum Equals K**
    
    - 利用前綴和搭配哈希表來高效計算連續子數組總和為 `k` 的次數。

這些技巧能大幅提升演算法的效率，避免暴力 `O(n^2)` 的計算方式，讓某些問題可以在 `O(n)` 或 `O(log n)` 時間內解決。

[^1]: 

[^2]: prefix_sum[0] = 1
	prefix_sum[1] = 1 + 2 = 3
	prefix_sum[2] = 1 + 2 + 3 = 6
	prefix_sum[3] = 1 + 2 + 3 + 4 = 10



### 何時用前綴和? 何時用Two pointers?

讓我們來分析一下 Lintcode 上那些關於尋找子數組和的題目，以及何時使用前綴和或 Two Pointers（滑動窗口）是更優的選擇。

**適用前綴和的題目：**

- **和為 K 的子數組個數 (Subarray Sum Equals K):**
    - **原因：** 前綴和可以快速計算任意子數組的和 `sum(nums[i:j+1]) = prefix_sum[j+1] - prefix_sum[i]`。我們可以遍歷數組，計算每個前綴和，並使用哈希表記錄每個前綴和出現的次數。對於當前前綴和 `current_sum`，如果存在一個之前的前綴和 `prev_sum` 使得 `current_sum - prev_sum == K`，那麼就找到了一個和為 K 的子數組。哈希表能幫助我們在 O(1) 的平均時間內查找 `prev_sum` 的出現次數。
- **和為 0 的子數組 (Subarray Sum Equals Zero):**
    - **原因：** 這可以看作是和為 K 的子數組的特例，其中 K=0。如果存在兩個相同的前綴和 `prefix_sum[i] == prefix_sum[j]` (其中 `i < j`)，那麼 `nums[i:j]` 這個子數組的和就是 0。我們可以使用哈希表記錄每個前綴和是否出現過。
- **和接近 0 的子數組 (Subarray Sum Closest to Zero):**
    - **原因：** 計算所有前綴和，然後對前綴和數組進行排序。兩個相鄰的前綴和的差值對應一個子數組的和。排序後，差值最小的兩個相鄰前綴和對應的子數組的和最接近 0。
- **和為 K 的最長子數組 (Maximum Size Subarray Sum Equals K):**
    - **原因：** 類似於計算個數，我們可以使用前綴和和哈希表。哈希表儲存每個前綴和第一次出現的索引。當我們找到一個前綴和 `current_sum`，如果 `current_sum - K` 存在於哈希表中，那麼我們就找到了一個和為 K 的子數組，其長度為當前索引減去 `current_sum - K` 的第一次出現的索引。我們需要記錄找到的最長長度。

**適用 Two Pointers (滑動窗口) 的題目：**

- **和為 K 的最短子數組 (Minimum Size Subarray Sum Equals K):**
    - **原因：** 滑動窗口非常適合尋找滿足特定條件的**連續**子數組的**最小**或**最大**長度。我們可以維護一個窗口，並根據當前窗口的和與 K 的比較來調整窗口的左右邊界。如果窗口和小於 K，則擴展右邊界；如果窗口和大於或等於 K，則記錄當前長度並嘗試縮小左邊界以尋找更小的滿足條件的子數組。
- **和為 K 的最長子數組 (Maximum Size Subarray Sum Equals K):**
    - **原因：** 雖然前綴和也能解決，但滑動窗口在處理連續子數組長度問題時通常更直觀。我們可以擴展窗口直到和等於 K，然後記錄長度。如果和超過 K，則縮小左邊界。需要注意的是，如果數組中包含負數，滑動窗口可能不總是適用於尋找最長子數組，因為縮小窗口後可能再次達到 K。在有負數的情況下，前綴和可能是更穩健的選擇。
- **和** **大於或等於** **K 找最短子數組 (Minimum Size Subarray Sum Greater Than or Equal to Target):**
    - **原因：** 這是一個典型的滑動窗口應用場景。我們可以維護一個窗口，如果窗口和小於 K，則擴展右邊界；如果窗口和**大於或等於** K，則記錄當前長度並嘗試縮小左邊界以尋找更小的滿足條件的子數組。

**為何選擇前綴和？**

- **計算任意子數組的和高效：** 一旦計算了前綴和數組，獲取任何連續子數組的和只需要 O(1) 的時間。
- **處理非連續性的條件：** 前綴和結合哈希表可以有效地處理那些不要求子數組必須是連續的情況，例如尋找是否存在兩個子數組的和為 K 等（雖然這些不是直接的子數組問題）。
- **處理負數：** 前綴和方法通常可以很好地處理包含負數的數組。

**為何選擇 Two Pointers (滑動窗口)？**

- **專注於連續子數組：** 滑動窗口的核心思想是維護一個連續的子數組，因此非常適合解決涉及連續子數組的長度、最小/最大等問題。
- **通常具有更好的時間複雜度：** 對於某些問題（特別是尋找滿足特定和條件的最小/最大長度連續子數組），滑動窗口可以在 O(n) 的時間複雜度內解決，而前綴和方法可能需要 O(n2) 或 O(nlogn)（如果涉及到排序）。
- **更少的額外空間：** 滑動窗口通常只需要常數的額外空間，而前綴和方法需要 O(n) 的額外空間來儲存前綴和數組或哈希表。

**總結：**

- 當問題涉及到**計算任意子數組的和**，或者需要**統計滿足特定和條件的子數組個數**（不一定是最短或最長），或者數組中包含**負數**且需要尋找特定和的最長子數組時，**前綴和**通常是一個很好的選擇，特別是結合哈希表使用。
- 當問題明確要求尋找**連續子數組**的**最小或最大長度**，並且目標是找到第一個滿足條件的子數組時，**Two Pointers (滑動窗口)** 通常是更優的選擇，因為它可以提供更優的時間複雜度。

在實際解題時，理解問題的約束條件（例如，是否只包含正數、是否要求連續子數組）以及目標（例如，計數、尋找長度）是選擇合適方法的關鍵。