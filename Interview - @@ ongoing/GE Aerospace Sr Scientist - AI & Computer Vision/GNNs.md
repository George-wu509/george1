


|                          |     |     |
| ------------------------ | --- | --- |
| [[###GNN應用在FEA的example]] |     |     |
| [[###GNN應用在CFD的example]] |     |     |



### GNN應用在FEA的example

使用 4 個節點代表一個 FEA 網格，目標是預測在這個網格上穩態流體流動的**速度向量 `(v_x, v_y)`**。

**場景設定：**

假設我們模擬一個頂蓋驅動流 (Lid-Driven Cavity) 的簡化二維情況。網格依然是 4 個節點構成的 1x1 正方形。

- **節點 (Nodes):** 0, 1, 2, 3。
    - 節點 0: (0, 0)
    - 節點 1: (1, 0)
    - 節點 2: (0, 1)
    - 節點 3: (1, 1)
- **網格/連接關係 (Edges):** 為了更好地捕捉資訊傳播，我們假設節點之間不僅沿著邊連接，也沿著對角線連接（代表構成網格的兩個三角形元素）。
    - 邊: (0, 1), (1, 3), (3, 2), (2, 0), (0, 3), (1, 2)
    - 這個連接關係比單純的邊連接更密集。
- **邊界條件 (Boundary Conditions) - 頂蓋驅動流:**
    - 底部 (節點 0, 1) 和 左側 (節點 0, 2) 是固定牆壁 (Wall)，速度為 (0, 0)。
    - 頂部 (節點 2, 3) 是移動的蓋子 (Lid)，速度為 `(U_lid, 0)` (假設蓋子沿 x 方向移動，速度為 `U_lid`)。
    - 右側 (節點 1, 3) 也是固定牆壁 (Wall)，速度為 (0, 0)。
    - **節點處的邊界條件:**
        - 節點 0, 1, 2: 位於固定牆壁上，速度為 (0, 0)。
        - 節點 3: 位於移動蓋子上，同時也在右側牆壁上。通常以移動蓋子的速度為準，速度為 `(U_lid, 0)`。
- **目標 (Target):** 預測所有 4 個節點的速度向量 `(v_x, v_y)`。即使某些節點的速度已知（邊界節點），模型也應該能預測出來，並且要預測內部節點（在這個例子中沒有純粹的內部節點，但原理適用於更大網格）的速度。

**使用 GNN (以 GCN 為例) 的步驟：**

**步驟 1: 圖的定義 (Graph Definition)**

將流體問題映射到圖結構。

- **圖節點 (Graph Nodes):** FEA 的 4 個節點。
- **圖邊 (Graph Edges):** 由設定的連接關係 `{(0, 1), (1, 3), (3, 2), (2, 0), (0, 3), (1, 2)}` (及其反向邊) 定義。
- **鄰接矩陣 (Adjacency Matrix, A):** 根據上述邊構建。
    
    ```
    A = [[0, 1, 1, 1],  # Node 0 connects to 1, 2, 3
         [1, 0, 1, 1],  # Node 1 connects to 0, 2, 3
         [1, 1, 0, 1],  # Node 2 connects to 0, 1, 3
         [1, 1, 1, 0]]  # Node 3 connects to 0, 1, 2
    ```
    
    _注意：在這個例子中，由於包含了對角線，圖變成了全連接圖（除了自環）。_

**步驟 2: 節點特徵表示 (Node Feature Representation)**

定義每個節點的初始特徵向量 `h_i^(0)`。需要包含能區分節點物理狀態的資訊。

- 包含節點座標 (x, y)。
- 包含節點是否為邊界節點以及其速度是否已知（Dirichlet 條件）。

一個可能的特徵向量設計 `[x, y, is_fixed_vx, is_fixed_vy, fixed_vx, fixed_vy]` (6 維)：

- `is_fixed_vx`: 該節點的 x 方向速度是否由邊界條件固定 (1 for yes, 0 for no)。
- `is_fixed_vy`: 該節點的 y 方向速度是否由邊界條件固定 (1 for yes, 0 for no)。
- `fixed_vx`: 如果 x 方向速度固定，則為其固定值；否則為 0（或某個特殊值）。
- `fixed_vy`: 如果 y 方向速度固定，則為其固定值；否則為 0。

根據我們的頂蓋驅動流設定：

- `h_0^(0)` (節點 0): `[0.0, 0.0, 1.0, 1.0, 0.0, 0.0]` (Wall)
- `h_1^(0)` (節點 1): `[1.0, 0.0, 1.0, 1.0, 0.0, 0.0]` (Wall)
- `h_2^(0)` (節點 2): `[0.0, 1.0, 1.0, 1.0, 0.0, 0.0]` (Wall)
- `h_3^(0)` (節點 3): `[1.0, 1.0, 1.0, 1.0, U_lid, 0.0]` (Lid)

將這些向量堆疊成初始特徵矩陣 `H^(0)` (4x6)。

**步驟 3: GNN 層 - 圖卷積 (Graph Convolution Layer)**

同樣使用 GCN 層來聚合鄰居資訊並更新節點表示：

`H^(l+1) = σ( Â * H^(l) * W^(l) )`

- `H^(l)`: 第 `l` 層的節點特徵矩陣。
- `W^(l)`: 第 `l` 層的可學習權重 (例如 6x16 for l=0)。
- `Â`: 歸一化的鄰接矩陣 (加上自環)。計算步驟同上一個例子：
    1. `Ã = A + I` (因為 A 已經是全連接，Ã 每行/列的和都是 4)
        
        ```
        Ã = [[1, 1, 1, 1],
             [1, 1, 1, 1],
             [1, 1, 1, 1],
             [1, 1, 1, 1]]
        ```
        
    2. `D̃ = diag(4, 4, 4, 4)`
    3. `D̃^(-1/2) = diag(1/2, 1/2, 1/2, 1/2)`
    4. `Â = D̃^(-1/2) * Ã * D̃^(-1/2) = (1/4) * Ã`
        
        ```
        Â = [[0.25, 0.25, 0.25, 0.25],
             [0.25, 0.25, 0.25, 0.25],
             [0.25, 0.25, 0.25, 0.25],
             [0.25, 0.25, 0.25, 0.25]]
        ```
        
- `σ`: 激活函數 (e.g., ReLU)。

**演練一層 GCN：**

1. 輸入 `H^(0)` (4x6) 和 `Â` (4x4)。
2. 計算 `X = Â * H^(0) * W^(0)`。
    - `Â * H^(0)`: 在這個全連接的例子中，每個節點的新表示都是**所有節點**（包括自身）舊表示的**平均值**。這是一種信息的全局平滑。
    - `... * W^(0)`: 對平均後的特徵進行線性變換。
3. `H^(1) = ReLU(X)` (維度 4x16)。

通過堆疊更多層，模型可以學習更複雜的節點間相互作用模式，例如頂蓋的速度如何影響其他節點的速度場，同時考慮到固定牆壁的約束。初始特徵中的邊界條件信息會通過多層 GNN 傳播並影響最終的預測。

**步驟 4: 輸出層 (Output Layer)**

將最後一層 GNN 的節點表示 `H^(L)` (假設維度 4x32) 映射到目標輸出：速度 `(v_x, v_y)`。

- `Output = H^(L) * W_out`
    - `W_out` 是輸出層權重 (32x2)。
- `Output` 矩陣 (4x2) 的第 `i` 行是對節點 `i` 速度 `(v_x, v_y)` 的預測。

**步驟 5: 訓練 (Training)**

1. **數據集:** 需要運行傳統的 CFD (計算流體動力學) 求解器來生成訓練數據。每個樣本包含：
    - 描述流動問題的輸入圖（包含節點座標、邊界條件信息，例如不同的 `U_lid` 值）。
    - 對應的 CFD 計算出的穩態速度場 `V_true` (4x2 矩陣，作為標籤)。
2. **損失函數 (Loss Function):** 計算預測速度 `Output` 和真實速度 `V_true` 之間的均方誤差 (MSE)。 `Loss = Σ_i || Output[i] - V_true[i] ||^2`
3. **優化器 (Optimizer):** 使用 Adam 等優化器，通過反向傳播最小化損失，更新 GNN 的權重 `W^(l)` 和 `W_out`。
4. **迭代訓練:** 反复進行數據加載、前向傳播、損失計算、反向傳播和權重更新。

**步驟 6: 預測 (Prediction)**

訓練好的 GNN 可以快速預測新的流動情況（例如，在訓練範圍內的新的 `U_lid` 值）。

1. 為新情況構建輸入圖特徵 `H^(0)`。
2. 將其輸入 GNN。
3. 模型輸出預測的速度場 `Output` (4x2)。

**總結:**

這個例子展示了 GNN 如何應用於預測 FEA/CFD 網格上的流速。關鍵在於：

1. 將網格、節點屬性（座標、邊界條件）表示為圖結構和節點特徵。
2. 使用 GNN 層（如 GCN）來模擬節點間的信息傳播和相互影響，學習物理規律（例如流體動量傳遞、邊界約束）。
3. 通過在 CFD 模擬數據上進行監督學習來訓練模型。

訓練完成的 GNN 可以作為一個快速的代理模型，用於在相似條件下快速估算流場，避免了每次都運行耗時的 CFD 模擬。同樣地，模型的準確性和泛化能力依賴於訓練數據和網路設計。



總結一下上面 **預測流速** 的 GNN 例子中，模型的輸入、輸出和結構：

**1. 輸入 (Input)**

GNN 模型需要兩方面的輸入資訊：

- **圖結構 (Graph Structure):**
    - 描述節點之間如何連接。在這個例子中，由 4 個節點和它們之間的邊（包括對角線）定義。
    - 在模型內部，這通常通過**鄰接矩陣 (A)** 或其**歸一化的形式 (Â)** 來表示，用於 GCN 層的計算，決定資訊如何在節點間傳遞。
- **初始節點特徵矩陣 (Initial Node Feature Matrix, H^(0)):**
    - 一個維度為 `(N, F_in)` 的矩陣，其中 `N` 是節點數量（這裡是 4），`F_in` 是每個節點的初始輸入特徵維度。
    - 在這個例子中，每個節點的特徵向量是 `[x, y, is_fixed_vx, is_fixed_vy, fixed_vx, fixed_vy]`，所以 `F_in = 6`。
    - 因此，輸入特徵矩陣 `H^(0)` 的維度是 **4x6**。這個矩陣包含了每個節點的幾何位置和邊界條件資訊。

**2. 輸出 (Output)**

- **預測節點物理量矩陣 (Predicted Node Quantity Matrix, Output):**
    - 一個維度為 `(N, F_out)` 的矩陣，`N` 仍然是節點數量（4），`F_out` 是模型要為每個節點預測的物理量的維度。
    - 在這個例子中，目標是預測每個節點的 x 和 y 方向速度 `(v_x, v_y)`，所以 `F_out = 2`。
    - 因此，輸出矩陣 `Output` 的維度是 **4x2**。矩陣的第 `i` 行代表模型對節點 `i` 的速度預測。

**3. 模型結構 (Model Structure)**

這個例子中使用的 GNN 模型結構（以 GCN 為例）包含以下部分：

- **輸入層 (Input Layer):** 隱式定義，接收 4x6 的節點特徵矩陣 `H^(0)`。
- **多個 GCN 圖卷積層 (GCN Layers):**
    - 至少包含一層，可以堆疊多層（例如 2-3 層）。
    - 每一層 `l` 的計算遵循 `H^(l+1) = σ( Â * H^(l) * W^(l) )` 的規則。
        - `Â`: 使用固定的、歸一化的鄰接矩陣來聚合鄰居信息。
        - `W^(l)`: 該層的可學習權重矩陣，用於對聚合後的特徵進行線性變換（例如，從 6 維變到 16 維，再從 16 維變到 32 維）。
        - `σ`: 非線性激活函數（例如 ReLU），增加模型表達能力。
- **輸出層 (Output Layer):**
    - 通常是一個線性全連接層。
    - 將最後一個 GCN 層輸出的節點表示 `H^(L)`（例如 4x32 維）通過一個可學習的權重矩陣 `W_out` (32x2 維) 映射到最終的輸出維度 (2)。
    - `Output = H^(L) * W_out`。通常輸出層不使用（或使用線性）激活函數，以便直接預測物理量的值。

簡單來說，這個 GNN 模型通過多層圖卷積操作，結合節點自身的初始特徵（座標、邊界條件）和其鄰居節點的資訊（通過圖結構傳遞），逐步學習和提煉出能夠預測每個節點流速的表示，最後通過一個線性層輸出預測結果。

============================================





### GNN應用在CFD的example


再來舉一個 GNN 的例子，這次同樣使用 4 個節點代表一個 FEA 網格，目標是預測在這個網格上穩態流體流動的**速度向量 `(v_x, v_y)`**。

**場景設定：**

假設我們模擬一個頂蓋驅動流 (Lid-Driven Cavity) 的簡化二維情況。網格依然是 4 個節點構成的 1x1 正方形。

- **節點 (Nodes):** 0, 1, 2, 3。
    - 節點 0: (0, 0)
    - 節點 1: (1, 0)
    - 節點 2: (0, 1)
    - 節點 3: (1, 1)
- **網格/連接關係 (Edges):** 為了更好地捕捉資訊傳播，我們假設節點之間不僅沿著邊連接，也沿著對角線連接（代表構成網格的兩個三角形元素）。
    - 邊: (0, 1), (1, 3), (3, 2), (2, 0), (0, 3), (1, 2)
    - 這個連接關係比單純的邊連接更密集。
- **邊界條件 (Boundary Conditions) - 頂蓋驅動流:**
    - 底部 (節點 0, 1) 和 左側 (節點 0, 2) 是固定牆壁 (Wall)，速度為 (0, 0)。
    - 頂部 (節點 2, 3) 是移動的蓋子 (Lid)，速度為 `(U_lid, 0)` (假設蓋子沿 x 方向移動，速度為 `U_lid`)。
    - 右側 (節點 1, 3) 也是固定牆壁 (Wall)，速度為 (0, 0)。
    - **節點處的邊界條件:**
        - 節點 0, 1, 2: 位於固定牆壁上，速度為 (0, 0)。
        - 節點 3: 位於移動蓋子上，同時也在右側牆壁上。通常以移動蓋子的速度為準，速度為 `(U_lid, 0)`。
- **目標 (Target):** 預測所有 4 個節點的速度向量 `(v_x, v_y)`。即使某些節點的速度已知（邊界節點），模型也應該能預測出來，並且要預測內部節點（在這個例子中沒有純粹的內部節點，但原理適用於更大網格）的速度。

**使用 GNN (以 GCN 為例) 的步驟：**

**步驟 1: 圖的定義 (Graph Definition)**

將流體問題映射到圖結構。

- **圖節點 (Graph Nodes):** FEA 的 4 個節點。
- **圖邊 (Graph Edges):** 由設定的連接關係 `{(0, 1), (1, 3), (3, 2), (2, 0), (0, 3), (1, 2)}` (及其反向邊) 定義。
- **鄰接矩陣 (Adjacency Matrix, A):** 根據上述邊構建。
    
    ```
    A = [[0, 1, 1, 1],  # Node 0 connects to 1, 2, 3
         [1, 0, 1, 1],  # Node 1 connects to 0, 2, 3
         [1, 1, 0, 1],  # Node 2 connects to 0, 1, 3
         [1, 1, 1, 0]]  # Node 3 connects to 0, 1, 2
    ```
    
    _注意：在這個例子中，由於包含了對角線，圖變成了全連接圖（除了自環）。_

**步驟 2: 節點特徵表示 (Node Feature Representation)**

定義每個節點的初始特徵向量 `h_i^(0)`。需要包含能區分節點物理狀態的資訊。

- 包含節點座標 (x, y)。
- 包含節點是否為邊界節點以及其速度是否已知（Dirichlet 條件）。

一個可能的特徵向量設計 `[x, y, is_fixed_vx, is_fixed_vy, fixed_vx, fixed_vy]` (6 維)：

- `is_fixed_vx`: 該節點的 x 方向速度是否由邊界條件固定 (1 for yes, 0 for no)。
- `is_fixed_vy`: 該節點的 y 方向速度是否由邊界條件固定 (1 for yes, 0 for no)。
- `fixed_vx`: 如果 x 方向速度固定，則為其固定值；否則為 0（或某個特殊值）。
- `fixed_vy`: 如果 y 方向速度固定，則為其固定值；否則為 0。

根據我們的頂蓋驅動流設定：

- `h_0^(0)` (節點 0): `[0.0, 0.0, 1.0, 1.0, 0.0, 0.0]` (Wall)
- `h_1^(0)` (節點 1): `[1.0, 0.0, 1.0, 1.0, 0.0, 0.0]` (Wall)
- `h_2^(0)` (節點 2): `[0.0, 1.0, 1.0, 1.0, 0.0, 0.0]` (Wall)
- `h_3^(0)` (節點 3): `[1.0, 1.0, 1.0, 1.0, U_lid, 0.0]` (Lid)

將這些向量堆疊成初始特徵矩陣 `H^(0)` (4x6)。

**步驟 3: GNN 層 - 圖卷積 (Graph Convolution Layer)**

同樣使用 GCN 層來聚合鄰居資訊並更新節點表示：

`H^(l+1) = σ( Â * H^(l) * W^(l) )`

- `H^(l)`: 第 `l` 層的節點特徵矩陣。
- `W^(l)`: 第 `l` 層的可學習權重 (例如 6x16 for l=0)。
- `Â`: 歸一化的鄰接矩陣 (加上自環)。計算步驟同上一個例子：
    1. `Ã = A + I` (因為 A 已經是全連接，Ã 每行/列的和都是 4)
        
        ```
        Ã = [[1, 1, 1, 1],
             [1, 1, 1, 1],
             [1, 1, 1, 1],
             [1, 1, 1, 1]]
        ```
        
    2. `D̃ = diag(4, 4, 4, 4)`
    3. `D̃^(-1/2) = diag(1/2, 1/2, 1/2, 1/2)`
    4. `Â = D̃^(-1/2) * Ã * D̃^(-1/2) = (1/4) * Ã`
        
        ```
        Â = [[0.25, 0.25, 0.25, 0.25],
             [0.25, 0.25, 0.25, 0.25],
             [0.25, 0.25, 0.25, 0.25],
             [0.25, 0.25, 0.25, 0.25]]
        ```
        
- `σ`: 激活函數 (e.g., ReLU)。

**演練一層 GCN：**

1. 輸入 `H^(0)` (4x6) 和 `Â` (4x4)。
2. 計算 `X = Â * H^(0) * W^(0)`。
    - `Â * H^(0)`: 在這個全連接的例子中，每個節點的新表示都是**所有節點**（包括自身）舊表示的**平均值**。這是一種信息的全局平滑。
    - `... * W^(0)`: 對平均後的特徵進行線性變換。
3. `H^(1) = ReLU(X)` (維度 4x16)。

通過堆疊更多層，模型可以學習更複雜的節點間相互作用模式，例如頂蓋的速度如何影響其他節點的速度場，同時考慮到固定牆壁的約束。初始特徵中的邊界條件信息會通過多層 GNN 傳播並影響最終的預測。

**步驟 4: 輸出層 (Output Layer)**

將最後一層 GNN 的節點表示 `H^(L)` (假設維度 4x32) 映射到目標輸出：速度 `(v_x, v_y)`。

- `Output = H^(L) * W_out`
    - `W_out` 是輸出層權重 (32x2)。
- `Output` 矩陣 (4x2) 的第 `i` 行是對節點 `i` 速度 `(v_x, v_y)` 的預測。

**步驟 5: 訓練 (Training)**

1. **數據集:** 需要運行傳統的 CFD (計算流體動力學) 求解器來生成訓練數據。每個樣本包含：
    - 描述流動問題的輸入圖（包含節點座標、邊界條件信息，例如不同的 `U_lid` 值）。
    - 對應的 CFD 計算出的穩態速度場 `V_true` (4x2 矩陣，作為標籤)。
2. **損失函數 (Loss Function):** 計算預測速度 `Output` 和真實速度 `V_true` 之間的均方誤差 (MSE)。 `Loss = Σ_i || Output[i] - V_true[i] ||^2`
3. **優化器 (Optimizer):** 使用 Adam 等優化器，通過反向傳播最小化損失，更新 GNN 的權重 `W^(l)` 和 `W_out`。
4. **迭代訓練:** 反复進行數據加載、前向傳播、損失計算、反向傳播和權重更新。

**步驟 6: 預測 (Prediction)**

訓練好的 GNN 可以快速預測新的流動情況（例如，在訓練範圍內的新的 `U_lid` 值）。

1. 為新情況構建輸入圖特徵 `H^(0)`。
2. 將其輸入 GNN。
3. 模型輸出預測的速度場 `Output` (4x2)。

**總結:**

這個例子展示了 GNN 如何應用於預測 FEA/CFD 網格上的流速。關鍵在於：

1. 將網格、節點屬性（座標、邊界條件）表示為圖結構和節點特徵。
2. 使用 GNN 層（如 GCN）來模擬節點間的信息傳播和相互影響，學習物理規律（例如流體動量傳遞、邊界約束）。
3. 通過在 CFD 模擬數據上進行監督學習來訓練模型。

訓練完成的 GNN 可以作為一個快速的代理模型，用於在相似條件下快速估算流場，避免了每次都運行耗時的 CFD 模擬。同樣地，模型的準確性和泛化能力依賴於訓練數據和網路設計。

所以上面的例子GNNs的輸入是甚麼, 輸出是甚麼, GNNs model的結構是甚麼

顯示思路

好的，我們來總結一下上面 **預測流速** 的 GNN 例子中，模型的輸入、輸出和結構：

**1. 輸入 (Input)**

GNN 模型需要兩方面的輸入資訊：

- **圖結構 (Graph Structure):**
    - 描述節點之間如何連接。在這個例子中，由 4 個節點和它們之間的邊（包括對角線）定義。
    - 在模型內部，這通常通過**鄰接矩陣 (A)** 或其**歸一化的形式 (Â)** 來表示，用於 GCN 層的計算，決定資訊如何在節點間傳遞。
- **初始節點特徵矩陣 (Initial Node Feature Matrix, H^(0)):**
    - 一個維度為 `(N, F_in)` 的矩陣，其中 `N` 是節點數量（這裡是 4），`F_in` 是每個節點的初始輸入特徵維度。
    - 在這個例子中，每個節點的特徵向量是 `[x, y, is_fixed_vx, is_fixed_vy, fixed_vx, fixed_vy]`，所以 `F_in = 6`。
    - 因此，輸入特徵矩陣 `H^(0)` 的維度是 **4x6**。這個矩陣包含了每個節點的幾何位置和邊界條件資訊。

**2. 輸出 (Output)**

- **預測節點物理量矩陣 (Predicted Node Quantity Matrix, Output):**
    - 一個維度為 `(N, F_out)` 的矩陣，`N` 仍然是節點數量（4），`F_out` 是模型要為每個節點預測的物理量的維度。
    - 在這個例子中，目標是預測每個節點的 x 和 y 方向速度 `(v_x, v_y)`，所以 `F_out = 2`。
    - 因此，輸出矩陣 `Output` 的維度是 **4x2**。矩陣的第 `i` 行代表模型對節點 `i` 的速度預測。

**3. 模型結構 (Model Structure)**

這個例子中使用的 GNN 模型結構（以 GCN 為例）包含以下部分：

- **輸入層 (Input Layer):** 隱式定義，接收 4x6 的節點特徵矩陣 `H^(0)`。
- **多個 GCN 圖卷積層 (GCN Layers):**
    - 至少包含一層，可以堆疊多層（例如 2-3 層）。
    - 每一層 `l` 的計算遵循 `H^(l+1) = σ( Â * H^(l) * W^(l) )` 的規則。
        - `Â`: 使用固定的、歸一化的鄰接矩陣來聚合鄰居信息。
        - `W^(l)`: 該層的可學習權重矩陣，用於對聚合後的特徵進行線性變換（例如，從 6 維變到 16 維，再從 16 維變到 32 維）。
        - `σ`: 非線性激活函數（例如 ReLU），增加模型表達能力。
- **輸出層 (Output Layer):**
    - 通常是一個線性全連接層。
    - 將最後一個 GCN 層輸出的節點表示 `H^(L)`（例如 4x32 維）通過一個可學習的權重矩陣 `W_out` (32x2 維) 映射到最終的輸出維度 (2)。
    - `Output = H^(L) * W_out`。通常輸出層不使用（或使用線性）激活函數，以便直接預測物理量的值。

簡單來說，這個 GNN 模型通過多層圖卷積操作，結合節點自身的初始特徵（座標、邊界條件）和其鄰居節點的資訊（通過圖結構傳遞），逐步學習和提煉出能夠預測每個節點流速的表示，最後通過一個線性層輸出預測結果。

請具體舉一個GNNs應用到流體力學 CFD的非常簡單例子, 並中文詳細說明每個步驟, 並說明輸入輸出跟model結構

顯示思路

好的，我們來舉一個非常簡單的 GNN 在 CFD 相關領域（為了簡化，我們用熱傳導代替完整流體力學）的應用例子。這個例子將使用 GNN 預測一維杆上的穩態溫度分佈。

**場景設定：一維穩態熱傳導**

想像一根長度為 1 的細杆，我們只關心沿著杆長度方向的溫度變化。我們將杆離散化為 4 個等距節點。

- **物理問題:** 求解一維穩態熱傳導方程 `d²T/dx² = 0`，其中 T 是溫度，x 是沿杆的位置。
- **計算域/網格:** 沿 x 軸有 4 個節點。
    - 節點 0: x = 0.0
    - 節點 1: x = 1/3 ≈ 0.33
    - 節點 2: x = 2/3 ≈ 0.67
    - 節點 3: x = 1.0
- **連接關係:** 節點僅與其直接相鄰的節點連接。
    - 邊: (0, 1), (1, 2), (2, 3)
- **邊界條件 (Boundary Conditions):**
    - 杆的左端（節點 0）溫度固定為 `T = 0`。
    - 杆的右端（節點 3）溫度固定為 `T = 1`。
- **目標 (Target):** 使用 GNN 預測所有節點的溫度，特別是內部節點 1 和 2 的溫度。（這個問題的解析解是 `T(x) = x`，所以我們期望 `T(1) ≈ 0.33`, `T(2) ≈ 0.67`）。

**使用 GNN (以 GCN 為例) 的步驟：**

**步驟 1: 圖的定義 (Graph Definition)**

將這個一維問題表示為圖。

- **圖節點 (Graph Nodes):** 離散化的 4 個節點 (0, 1, 2, 3)。
- **圖邊 (Graph Edges):** 節點間的物理連接 `{(0, 1), (1, 2), (2, 3)}` (無向)。
- **鄰接矩陣 (Adjacency Matrix, A):**
    
    ```
    A = [[0, 1, 0, 0],
         [1, 0, 1, 0],
         [0, 1, 0, 1],
         [0, 0, 1, 0]]
    ```
    

**步驟 2: 節點特徵表示 (Node Feature Representation)**

為每個節點設計初始特徵向量 `h_i^(0)`。

- **包含節點座標 `[x]`** (1 維)。
- **包含邊界條件信息 `[is_dirichlet, dirichlet_T]`** (2 維)：
    - `is_dirichlet`: 1 表示該節點為 Dirichlet 邊界 (溫度固定)，0 表示否。
    - `dirichlet_T`: 如果是 Dirichlet 邊界，則為固定的溫度值；否則為 0。
- **總特徵維度:** 1 + 2 = 3 維。

具體的初始特徵向量：

- `h_0^(0)`: `[0.0, 1.0, 0.0]` (x=0, Dirichlet, T=0)
- `h_1^(0)`: `[0.33, 0.0, 0.0]` (x=0.33, 非 Dirichlet)
- `h_2^(0)`: `[0.67, 0.0, 0.0]` (x=0.67, 非 Dirichlet)
- `h_3^(0)`: `[1.0, 1.0, 1.0]` (x=1.0, Dirichlet, T=1)

堆疊成初始特徵矩陣 `H^(0)` (4x3)。

**步驟 3: GNN 模型結構 (GNN Model Structure)**

我們使用一個包含 GCN 層的簡單 GNN。

- **輸入層:** 接收 4x3 的 `H^(0)`。
- **GCN 層 (可堆疊):** 執行圖卷積 `H^(l+1) = σ( Â * H^(l) * W^(l) )`。
    - **歸一化鄰接矩陣 Â:**
        1. `Ã = A + I = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]]` (加自環)
        2. `D̃ = diag(2, 3, 3, 2)` (度矩陣)
        3. `D̃^(-1/2) = diag(1/√2, 1/√3, 1/√3, 1/√2)`
        4. `Â = D̃^(-1/2) * Ã * D̃^(-1/2)` (對稱歸一化)
            
            ```
            Â ≈ [[0.50, 0.41, 0.00, 0.00],
                 [0.41, 0.33, 0.33, 0.00],
                 [0.00, 0.33, 0.33, 0.41],
                 [0.00, 0.00, 0.41, 0.50]]
            ```
            
            這個 `Â` 矩陣定義了每個節點如何從其鄰居（和自身）聚合信息。例如，節點 1（第二行）會從節點 0, 1, 2 聚合信息。
    - **權重 W^(l):** 可學習的線性變換矩陣 (例如，`W^(0)` 維度 3x16)。
    - **激活 σ:** 非線性函數 (例如 ReLU)。
    - _信息傳播:_ 經過一層 GCN，節點 1 的表示會融合節點 0, 1, 2 的初始信息；節點 2 會融合節點 1, 2, 3 的信息。經過多層後，兩端邊界的信息可以傳播到中間的節點。
- **輸出層:** 一個線性層，將最後一層 GNN 的隱藏特徵（例如 4x16）映射到最終的輸出維度（溫度，1 維）。
    - `Output = H^(L) * W_out` (`W_out` 維度 16x1)。

**步驟 4: 輸入與輸出總結 (Input & Output Summary)**

- **輸入 (Input):**
    - **圖結構 (Graph Structure):** 由 4 個節點和邊 (0,1), (1,2), (2,3) 定義，體現在 GCN 層使用的歸一化鄰接矩陣 `Â` (4x4) 中。
    - **初始節點特徵 (Initial Node Features):** `H^(0)` 矩陣 (維度 4x3)，包含每個節點的 x 座標和邊界條件信息。
- **輸出 (Output):**
    - **預測溫度 (Predicted Temperature):** `Output` 矩陣 (維度 4x1)，包含模型對每個節點溫度的預測值。

**步驟 5: 訓練 (Training)**

1. **數據/標籤:** 在這個極簡單的例子中，解析解是 `T(x) = x`。所以真實標籤 `T_true` 為 `[0.0, 0.33, 0.67, 1.0]`<sup>T</sup> (4x1 向量)。對於更複雜的問題，標籤來自傳統 CFD/FEA 求解器的結果。如果邊界條件會變化（例如，`T(1)` 的值可以不同），則需要生成多組不同邊界條件下的模擬結果作為訓練數據。
2. **損失函數:** 計算預測 `Output` 和真實 `T_true` 之間的均方誤差 (MSE)。 `Loss = MSE(Output, T_true)`
3. **優化:** 使用 Adam 等優化器通過反向傳播調整 GNN 權重 `W^(l)` 和 `W_out` 以最小化 Loss。

**步驟 6: 預測 (Prediction)**

訓練完成後，模型可以（在訓練數據覆蓋的範圍內）預測不同情況下的溫度。例如，如果模型訓練時包含了不同的右端溫度 `T(1)` 作為變化的輸入特徵或條件，它可以預測新的 `T(1)` 值下的溫度分佈。對於本例的固定 BC，它應該能準確預測出內部節點的溫度接近 0.33 和 0.67。

**這個例子的意義：**

儘管非常簡單（甚至可以用簡單的線性插值解決），它展示了 GNN 應用於物理模擬的基本流程：

1. 將物理域離散化為圖。
2. 將物理屬性（座標、邊界條件）編碼為節點特徵。
3. 利用 GNN 層模擬節點間的相互作用和信息傳播（近似求解 PDE 的過程）。
4. 通過監督學習（對比模擬/解析解）訓練模型。
5. 用訓練好的模型進行快速預測。


















Reference:
Blog
https://distill.pub/2021/gnn-intro/

youtube
https://www.youtube.com/watch?v=sejA2PtCITw

https://www.bilibili.com/video/BV1iT4y1d7zP/?spm_id_from=333.337.search-card.all.click

