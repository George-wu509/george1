
### **LintCode 1469：树上最长路径**

#### **题目描述**

给定一个无向树，其中包含 `n` 个节点和 `n-1` 条边，求树上最长路径的长度。

输入示例：
```python
n = 5
starts = [0, 0, 2, 2]
ends = [1, 2, 3, 4]
lens = [1, 2, 5, 6]

```
对应的树结构：

markdown
```markdown
      0
     / \
    1   2
       / \
      3   4

```
边的长度：

- 边 0→10 \to 10→1 长度为 1。
- 边 0→20 \to 20→2 长度为 2。
- 边 2→32 \to 32→3 长度为 5。
- 边 2→42 \to 42→4 长度为 6。

输出：

`13 （最长路径为 3 → 2 → 4 或 4 → 2 → 3）`

---
lintcode solution:
https://www.lintcode.com/problem/1469/solution/22814
### **DFS 解法**

#### **算法思路**

树上最长路径的长度，也称为树的「直径」，可以通过以下两次 DFS 求解：

1. **第一次 DFS**：
    
    - 从任意节点（如节点 0）出发，找到离其最远的节点 pospospos。
    - 使用一个数组 `dp` 存储从起点到其他节点的路径长度。
2. **第二次 DFS**：
    
    - 从节点 pospospos 出发，再次运行 DFS，找到离其最远的节点，并记录路径长度。
3. **最长路径**：
    
    - 第二次 DFS 的结果即为树的直径。

---
Example:
**Example 1:**
```python
Input：n=5,starts=[0,0,2,2],ends=[1,2,3,4],lens=[1,2,5,6]
Output：11
解释:
(3→2→4)这条路径长度为`11`，当然(4→2→3)也是一样的。
```

**Example 2:**
```python
Input：n=5,starts=[0,0,2,2],ends=[1,2,3,4],lens=[5,2,5,6]
Output：13
解释:
(1→0→2→4)这条路径长度为`13`，当然(4→2→0→1)也是一样的。
```


#### **代码解析**
```python

class Solution:
    G = []  # 邻接表，存储树的结构
    dp = []  # dp 数组，存储每个节点到起点的路径长度

    def dfs(self, u, pre):
        """DFS 遍历，计算从当前节点 u 到其他节点的路径长度"""
        for x in self.G[u]:
            if x[0] != pre:  # 忽略回到父节点的边
                self.dp[x[0]] = self.dp[u] + x[1]  # 更新路径长度
                self.dfs(x[0], u)  # 递归处理子节点

    def longestPath(self, n, starts, ends, lens):
        """主函数：计算树的直径"""
        import sys
        sys.setrecursionlimit(200000)  # 设置递归深度
        self.G = [[] for i in range(n)]  # 初始化邻接表
        self.dp = [0 for i in range(n)]  # 初始化 dp 数组

        # 构建邻接表
        for i in range(n - 1):
            self.G[starts[i]].append([ends[i], lens[i]])
            self.G[ends[i]].append([starts[i], lens[i]])

        # 第一次 DFS，找到离节点 0 最远的节点 pos
        self.dp[0] = 0
        self.dfs(0, 0)
        pos = max(range(n), key=lambda i: self.dp[i])  # 找到最远节点 pos

        # 第二次 DFS，从 pos 出发找到树的直径
        self.dp[pos] = 0
        self.dfs(pos, pos)
        return max(self.dp)  # 返回最长路径

```
pass

#### **执行过程**

複製程式碼

`n = 5 starts = [0, 0, 2, 2] ends = [1, 2, 3, 4] lens = [1, 2, 5, 6]`

1. **构建邻接表**：

    `G = [     [[1, 1], [2, 2]],  # 节点 0 的邻居     [[0, 1]],          # 节点 1 的邻居     [[0, 2], [3, 5], [4, 6]],  # 节点 2 的邻居     [[2, 5]],          # 节点 3 的邻居     [[2, 6]]           # 节点 4 的邻居 ]`
    
2. **第一次 DFS**：
    
    - 从节点 0 出发，得到 `dp` 数组：

        `dp = [0, 1, 2, 7, 8]  # 节点 4 离节点 0 最远`
        
    - 最远节点 `pos = 4`。
3. **第二次 DFS**：
    
    - 从节点 4 出发，重新计算 `dp` 数组：
        
        python
        
        複製程式碼
        
        `dp = [8, 9, 6, 13, 0]  # 节点 3 离节点 4 最远`
        
    - 树的直径为 `max(dp) = 13`。

输出：

text

複製程式碼

`13`

---

### **复杂度分析**

1. **时间复杂度**：
    
    - 构建邻接表的时间为 O(n)O(n)O(n)。
    - 每次 DFS 遍历树中的所有节点和边，时间为 O(n)O(n)O(n)。
    - 总时间复杂度为 **O(n)O(n)O(n)**。
2. **空间复杂度**：
    
    - 邻接表需要 O(n)O(n)O(n) 空间。
    - `dp` 数组需要 O(n)O(n)O(n) 空间。
    - 递归深度为 O(n)O(n)O(n)（最坏情况树为链表）。
    - 总空间复杂度为 **O(n)O(n)O(n)**。

---

### **其他解法**

#### 1. **广度优先搜索（BFS）**

- 替代 DFS 的方法是两次 BFS。
- 从任意节点开始进行第一次 BFS，找到最远节点。
- 再从第一次 BFS 的最远节点开始，进行第二次 BFS，得到树的直径。

#### 2. **树形动态规划**

- 使用动态规划计算每个节点的子树中最长路径和与其他子树的最长路径，合并得到直径。

#### 3. **中心拓展法**

- 从树的重心开始，向外扩展，直接计算直径。

---

### **总结**

- **DFS** 是求树的直径最常用的方法，简单高效，时间复杂度为 O(n)O(n)O(n)。
- **BFS** 和 **树形 DP** 是可替代的方法，适用于不同问题场景。
- 如果有其他问题，或需要更详细的解释，请随时告知！

## **为什么需要两次 DFS？**

### **第一次 DFS 的目的：找到最长路径的一个端点**

- 我们 **随便选一个起点**（通常选择 `0`）。
- 从该起点执行 **DFS 计算所有节点的最远距离**，找到 **最远的节点 `pos`**。
- 这个 `pos` 必然是直径的 **其中一个端点**（但不一定是整个树直径的两端）。

### **第二次 DFS 的目的：从 `pos` 再次 DFS，找到最长路径**

- 以 `pos` 为起点，进行 **第二次 DFS**，计算所有节点的距离。
- 这次 DFS 计算出的 **最远距离即为树的直径（最长路径）**。

---

## **如果只执行一次 DFS，会发生什么问题？**

假设我们 **只进行一次 DFS**，从 `0` 开始计算所有节点的距离，然后直接取 `dp` 数组中的最大值，可能会得到错误的结果。

来看一个具体的 **错误案例**：

### **错误示例**

考虑如下树：

markdown

複製編輯

    `0      \       1        \         2        / \       3   4`

其中边权如下：

- (0,1) = 1
- (1,2) = 1
- (2,3) = 5
- (2,4) = 5

---

### **假设只进行一次 DFS**

1. **从 `0` 出发执行 DFS，计算所有节点到 `0` 的距离：**
    
    bash
    
    複製編輯
    
    `dp[0] = 0 dp[1] = 1 dp[2] = 2 dp[3] = 7  # 2 + 5 dp[4] = 7  # 2 + 5`
    
    - 最大距离是 **7**，但这个结果 **不是树的直径**。
2. **正确的直径是什么？**
    
    - 实际上，最长路径应该是 `3 -> 2 -> 4`，长度 `5 + 5 = 10`，但是 **一次 DFS 无法找到这个路径**。

---

## **为什么第二次 DFS 能解决这个问题？**

1. **第一次 DFS 找到的 `pos` 是离 `0` 最远的节点**，它 **一定是直径的其中一个端点**（例如 `3`）。
2. **第二次 DFS 以 `pos` 为起点，找到最远的另一端**，这样才确保得到了真正的直径（如 `3 -> 2 -> 4`）。

---

## **总结**

- **一次 DFS 只能找到“相对于起点最远的点”，但不一定是直径的端点。**
- **两次 DFS 保证了我们从直径的一个端点出发，找到真正的最长路径。**

### **关键点**

✅ **第一遍 DFS**：找到最长路径的一个端点 `pos`。  
✅ **第二遍 DFS**：从 `pos` 出发，找到树的直径（最长路径）。

**这就是为什么方法 1 需要两次 DFS，而不是一次。** 🚀