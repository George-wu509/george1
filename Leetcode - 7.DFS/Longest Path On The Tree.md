
### **LintCode 1469：树上最长路径**

#### **题目描述**

给定一个无向树，其中包含 `n` 个节点和 `n-1` 条边，求树上最长路径的长度。

输入示例：
```python
n = 5
starts = [0, 0, 2, 2]
ends = [1, 2, 3, 4]
lens = [1, 2, 5, 6]

```
对应的树结构：

markdown
```markdown
      0
     / \
    1   2
       / \
      3   4

```
边的长度：

- 边 0→10 \to 10→1 长度为 1。
- 边 0→20 \to 20→2 长度为 2。
- 边 2→32 \to 32→3 长度为 5。
- 边 2→42 \to 42→4 长度为 6。

输出：

`13 （最长路径为 3 → 2 → 4 或 4 → 2 → 3）`

---

### **DFS 解法**

#### **算法思路**

树上最长路径的长度，也称为树的「直径」，可以通过以下两次 DFS 求解：

1. **第一次 DFS**：
    
    - 从任意节点（如节点 0）出发，找到离其最远的节点 pospospos。
    - 使用一个数组 `dp` 存储从起点到其他节点的路径长度。
2. **第二次 DFS**：
    
    - 从节点 pospospos 出发，再次运行 DFS，找到离其最远的节点，并记录路径长度。
3. **最长路径**：
    
    - 第二次 DFS 的结果即为树的直径。

---
Example:
**Example 1:**
```
Input：n=5,starts=[0,0,2,2],ends=[1,2,3,4],lens=[1,2,5,6]
Output：11
解释:
(3→2→4)这条路径长度为`11`，当然(4→2→3)也是一样的。
```

**Example 2:**
```
Input：n=5,starts=[0,0,2,2],ends=[1,2,3,4],lens=[5,2,5,6]
Output：13
解释:
(1→0→2→4)这条路径长度为`13`，当然(4→2→0→1)也是一样的。
```


#### **代码解析**
```python

class Solution:
    G = []  # 邻接表，存储树的结构
    dp = []  # dp 数组，存储每个节点到起点的路径长度

    def dfs(self, u, pre):
        """DFS 遍历，计算从当前节点 u 到其他节点的路径长度"""
        for x in self.G[u]:
            if x[0] != pre:  # 忽略回到父节点的边
                self.dp[x[0]] = self.dp[u] + x[1]  # 更新路径长度
                self.dfs(x[0], u)  # 递归处理子节点

    def longestPath(self, n, starts, ends, lens):
        """主函数：计算树的直径"""
        import sys
        sys.setrecursionlimit(200000)  # 设置递归深度
        self.G = [[] for i in range(n)]  # 初始化邻接表
        self.dp = [0 for i in range(n)]  # 初始化 dp 数组

        # 构建邻接表
        for i in range(n - 1):
            self.G[starts[i]].append([ends[i], lens[i]])
            self.G[ends[i]].append([starts[i], lens[i]])

        # 第一次 DFS，找到离节点 0 最远的节点 pos
        self.dp[0] = 0
        self.dfs(0, 0)
        pos = max(range(n), key=lambda i: self.dp[i])  # 找到最远节点 pos

        # 第二次 DFS，从 pos 出发找到树的直径
        self.dp[pos] = 0
        self.dfs(pos, pos)
        return max(self.dp)  # 返回最长路径

```
pass

#### **执行过程**

複製程式碼

`n = 5 starts = [0, 0, 2, 2] ends = [1, 2, 3, 4] lens = [1, 2, 5, 6]`

1. **构建邻接表**：

    `G = [     [[1, 1], [2, 2]],  # 节点 0 的邻居     [[0, 1]],          # 节点 1 的邻居     [[0, 2], [3, 5], [4, 6]],  # 节点 2 的邻居     [[2, 5]],          # 节点 3 的邻居     [[2, 6]]           # 节点 4 的邻居 ]`
    
2. **第一次 DFS**：
    
    - 从节点 0 出发，得到 `dp` 数组：
        
        python
        
        複製程式碼
        
        `dp = [0, 1, 2, 7, 8]  # 节点 4 离节点 0 最远`
        
    - 最远节点 `pos = 4`。
3. **第二次 DFS**：
    
    - 从节点 4 出发，重新计算 `dp` 数组：
        
        python
        
        複製程式碼
        
        `dp = [8, 9, 6, 13, 0]  # 节点 3 离节点 4 最远`
        
    - 树的直径为 `max(dp) = 13`。

输出：

text

複製程式碼

`13`

---

### **复杂度分析**

1. **时间复杂度**：
    
    - 构建邻接表的时间为 O(n)O(n)O(n)。
    - 每次 DFS 遍历树中的所有节点和边，时间为 O(n)O(n)O(n)。
    - 总时间复杂度为 **O(n)O(n)O(n)**。
2. **空间复杂度**：
    
    - 邻接表需要 O(n)O(n)O(n) 空间。
    - `dp` 数组需要 O(n)O(n)O(n) 空间。
    - 递归深度为 O(n)O(n)O(n)（最坏情况树为链表）。
    - 总空间复杂度为 **O(n)O(n)O(n)**。

---

### **其他解法**

#### 1. **广度优先搜索（BFS）**

- 替代 DFS 的方法是两次 BFS。
- 从任意节点开始进行第一次 BFS，找到最远节点。
- 再从第一次 BFS 的最远节点开始，进行第二次 BFS，得到树的直径。

#### 2. **树形动态规划**

- 使用动态规划计算每个节点的子树中最长路径和与其他子树的最长路径，合并得到直径。

#### 3. **中心拓展法**

- 从树的重心开始，向外扩展，直接计算直径。

---

### **总结**

- **DFS** 是求树的直径最常用的方法，简单高效，时间复杂度为 O(n)O(n)O(n)。
- **BFS** 和 **树形 DP** 是可替代的方法，适用于不同问题场景。
- 如果有其他问题，或需要更详细的解释，请随时告知！

