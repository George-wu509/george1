
### **LintCode 17 子集 (Subsets)**

問題是給定一個整數數組 `nums`，返回該數組的所有子集（包括空集和自身）。要求生成子集的順序不影響答案。

---

### **DFS 解法**

我們使用遞歸深度優先搜索（DFS）來生成子集，具體步驟如下：

#### **算法步驟**

1. **排序輸入數組**：
    
    - 將 `nums` 排序以保證生成的子集有序（題目中未要求，但這通常是標準處理）。
    - 避免因為數字順序不同導致的重複子集。
2. **定義遞歸函數 `dfs(nums, k, subset, res)`**：
    
    - `nums`：輸入數組。
    - `k`：當前選擇的起始索引，保證選擇的數字不重複。
    - `subset`：當前生成的子集。
    - `res`：保存所有子集的結果集。
3. **遞歸過程**：
    
    - 每次遞歸中，將當前子集 `subset` 複製並加入結果集中。
    - 遍歷從當前索引 `k` 開始的數字：
        - 將該數字加入 `subset`。
        - 進一步遞歸處理下一層。
        - 回溯：刪除剛加入的數字以探索其他選擇。
4. **返回結果**：
    
    - 遞歸完成後，返回結果集 `res`。

---

Example:
**样例 1：**
输入：
```
nums = [0] 
```
输出：
```
[ 
  [], 
  [0] 
] 
```
解释：
[0]的子集只有[]和[0]。

**样例 2：**
输入：
```
nums = [1,2,3] 
```
输出：
```
[ 
  [3], 
  [1], 
  [2], 
  [1,2,3], 
  [1,3], 
  [2,3], 
  [1,2], 
  [] 
] 
```
[1,2,3]的子集有[],[1],[2],[3],[1,2],[1,3],[2,3],[1,2,3]。


For compare
```python
class Solution:
    def run(self, nums):
        results = []
        nums.sort()
        self.dfs(nums, 0, [], results)
        return results
     
    def dfs(self, nums, start, num, results): 
        results.append(num[:])
        
        for i in range(start, len(nums)):
            num.append(nums[i])
            self.dfs(nums, i+1, num, results)
            del num[-1]
```
在dfs裡面的results.append(num) 是會出現錯誤, 因為使用 `results.append(num)` 時，你添加到 `results` 列表中的並不是 `num` 列表的內容副本，而是 `num` 列表本身的**引用 (reference)**。這意味著 `results` 列表中所有元素都指向同一個 `num` 列表對象。由於 `num` 列表在遞歸過程中會不斷地被修改（通過 `num.append()` 和 `del num[-1]`），所有在 `results` 中引用的子集都會隨著 `num` 的變化而變化。最終，當所有遞歸結束時，`num` 列表將會被清空（因為所有的 `del num[-1]` 操作），導致 `results` 列表中所有的子集都變成了空列表 `[]`。

所以只要使用results.append(num[:]) 或 results.append(list(num)), 它會創建 `num` 列表的一個淺拷貝 (shallow copy). 就不會出現錯誤

如果沒有這行 `del num[-1]` 會怎麼樣？無限增長的 `num` 列表：** `num` 列表會持續增長，從不移除元素。


好的，這就為您詳細解釋這段求解 LeetCode 子集問題的 Python 程式碼，逐行剖析其邏輯與用途。

```python
class Solution:
```

這行定義了一個名為 `Solution` 的類別 (class)。在 LeetCode 問題中，通常會要求將解答寫在一個類別裡面，這是常見的結構。

```Python
    def run(self, nums):
```

這是 `Solution` 類別中的一個方法 (method)，名為 `run`。它是我們開始解決問題的入口點。

- `self`：代表類別實例本身，Python 方法的第一個參數通常是 `self`。
- `nums`：這是輸入參數，一個整數列表，例如 `[1, 2, 3]`。我們要找出這個列表的所有子集。

```Python
        results = []
```

這行初始化了一個空列表 `results`。這個列表將用來儲存我們找到的所有子集。每個子集都會作為一個列表被添加到 `results` 中。

```Python
        nums.sort()
```

這行對輸入列表 `nums` 進行了原地排序 (in-place sort)。雖然對於生成子集本身來說，排序並不是絕對必要的（因為子集的元素順序不重要），但在某些情況下，例如當輸入包含重複元素時，排序可以幫助我們更方便地處理去重問題（不過這個特定的程式碼沒有包含重複元素去重的邏輯）。對於沒有重複元素的子集問題，排序通常是為了讓輸出結果有固定的順序，方便檢查。

```Python
        self.dfs(nums, 0, [], results)
```

這是程式的核心，調用了一個遞歸的深度優先搜索 (DFS) 輔助函數 `dfs` 來生成子集。

- `self.dfs`：呼叫 `Solution` 類別內部的 `dfs` 方法。
- `nums`：原始的輸入列表。
- `0`：這是一個索引參數 `k` 的初始值。它表示我們從 `nums` 列表中哪個位置開始考慮選擇元素。初始時從索引 0 開始。
- `[]`：這是一個空列表 `num`，代表當前正在構建的子集。它會隨著遞歸的深入而逐漸添加元素。
- `results`：我們用來儲存所有子集的總列表，作為引用傳遞。

```Python
        return results
```

當 `dfs` 函數的所有遞歸調用完成後，`results` 列表中就包含了所有可能的子集，此行將其返回。

---


```Python
    def dfs(self, nums, k, num, results):
```

這是我們遞歸的深度優先搜索 (DFS) 輔助函數。

- `self`：類別實例本身。
- `nums`：原始的數字列表。
- `k`：當前考慮的起始索引。它確保我們只選擇當前索引或之後的元素，避免生成重複的子集（例如，選了 `[1,2]` 就不會再選 `[2,1]`）。
- `num`：當前正在構建的子集（一個列表）。
- `results`：儲存所有子集的總列表。

```Python
        results.append(num[:])
```

這是 DFS 的一個關鍵步驟。**無論 `num` 當前是空的、包含一個元素還是多個元素，它都代表一個有效的子集**。因此，我們將 `num` 的一個**副本**添加到 `results` 列表中。

- `num[:]`：這是一個 Python 的切片操作，它會創建 `num` 列表的一個**淺拷貝**。這樣做的原因非常重要：如果直接 `results.append(num)`，那麼 `results` 中儲存的將是指向同一個 `num` 列表的引用。當 `num` 在後續的遞歸中被修改時，`results` 中已添加的子集也會隨之改變，導致錯誤的結果。創建副本可以保證每個子集都是獨立的。

```Python
        for i in range(k, len(nums)):
```

這是一個迴圈，用於選擇 `nums` 列表中從索引 `k` 開始到結尾的每個元素。

- `range(k, len(nums))`：生成一個從 `k` 到 `len(nums)-1` 的索引序列。`k` 的作用是確保我們只考慮當前位置或之後的元素，避免重複生成子集。例如，如果 `k` 是 1，我們就不會再回頭選擇索引 0 的元素。

```Python
            num.append(nums[i])
```

**選擇 (Choose)**：將當前迴圈迭代到的元素 `nums[i]` 添加到正在構建的子集 `num` 中。這意味著我們決定將 `nums[i]` 包含在當前的子集中。

```Python
            self.dfs(nums, i+1, num, results)
```

**探索 (Explore)**：進行遞歸調用。

- `nums`：原始列表不變。
- `i+1`：這是關鍵。下一個遞歸調用會從當前選擇的元素 `nums[i]` **之後**的元素開始考慮。這樣就保證了每個子集中的元素順序是遞增的，並且不會重複選擇同一個位置的元素（例如，如果選了 `nums[0]`，下次就從 `nums[1]` 開始考慮）。
- `num`：傳入當前已經添加了 `nums[i]` 的子集。
- `results`：繼續傳遞總結果列表。

```Python
            del num[-1]
```

**回溯 (Backtrack)**：當遞歸調用 `self.dfs(nums, i+1, num, results)` 完成並返回後，我們需要撤銷當前選擇。這行代碼刪除 `num` 列表中最後一個添加的元素（也就是 `nums[i]`）。

- 回溯的目的是為了恢復 `num` 到上一個狀態，以便 `for` 迴圈的下一次迭代可以探索其他不包含 `nums[i]` 的子集分支，或者在處理完以 `nums[i]` 開頭的所有子集後，允許其上層的遞歸調用探索其他選擇。

這個 DFS 算法通過遞歸地「選擇」或「不選擇」每個元素（實際上是通過「選擇一個元素並遞歸」和「不選擇這個元素，而是在當前層級考慮下一個元素」來實現的），從而巧妙地生成了所有可能的子集。






---

### **複雜度分析**

1. **時間複雜度**：
    
    - 遞歸樹中每個節點都代表一個子集。
    - 有 `2^n` 個子集，每個子集的生成需要線性時間處理（最多為 `O(n)`）。
    - 時間複雜度為 **O(n × 2^n)**。
2. **空間複雜度**：
    
    - 遞歸深度最多為 `n`（對應數組長度）。
    - 空間複雜度為 **O(n)**。

---

### **其他解法簡述**

#### 1. **位運算法**

- 使用二進制數表示子集的選擇，例如對於長度為 `n` 的數組，共有 `2^n` 種二進制數，`1` 表示選擇該數字，`0` 表示不選。
- 時間複雜度：**O(n × 2^n)**

#### 2. **迭代法**

- 從空集開始，對於數組中的每個數字，將其加入當前已有的所有子集中形成新的子集，並不斷更新結果集。
- 時間複雜度：**O(n × 2^n)**

#### 3. **內建函數**

- 使用 Python 的內建模組 `itertools`：
    
```python
from itertools import combinations
def subsets(nums):
    res = []
    for i in range(len(nums) + 1):
        res.extend(combinations(nums, i))
    return res

```
    
- 時間複雜度：**O(n × 2^n)**