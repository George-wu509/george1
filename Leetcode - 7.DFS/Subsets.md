
### **LintCode 17 子集 (Subsets)**

問題是給定一個整數數組 `nums`，返回該數組的所有子集（包括空集和自身）。要求生成子集的順序不影響答案。

---

### **DFS 解法**

我們使用遞歸深度優先搜索（DFS）來生成子集，具體步驟如下：

#### **算法步驟**

1. **排序輸入數組**：
    
    - 將 `nums` 排序以保證生成的子集有序（題目中未要求，但這通常是標準處理）。
    - 避免因為數字順序不同導致的重複子集。
2. **定義遞歸函數 `dfs(nums, k, subset, res)`**：
    
    - `nums`：輸入數組。
    - `k`：當前選擇的起始索引，保證選擇的數字不重複。
    - `subset`：當前生成的子集。
    - `res`：保存所有子集的結果集。
3. **遞歸過程**：
    
    - 每次遞歸中，將當前子集 `subset` 複製並加入結果集中。
    - 遍歷從當前索引 `k` 開始的數字：
        - 將該數字加入 `subset`。
        - 進一步遞歸處理下一層。
        - 回溯：刪除剛加入的數字以探索其他選擇。
4. **返回結果**：
    
    - 遞歸完成後，返回結果集 `res`。

---

Example:
**样例 1：**
输入：
```
nums = [0] 
```
输出：
```
[ 
  [], 
  [0] 
] 
```
解释：
[0]的子集只有[]和[0]。

**样例 2：**
输入：
```
nums = [1,2,3] 
```
输出：
```
[ 
  [3], 
  [1], 
  [2], 
  [1,2,3], 
  [1,3], 
  [2,3], 
  [1,2], 
  [] 
] 
```
[1,2,3]的子集有[],[1],[2],[3],[1,2],[1,3],[2,3],[1,2,3]。


For compare
```python
class Solution:
    def run(self, nums):
        results = []
        nums.sort()
        self.dfs(nums, 0, [], results)
        return results
     
    def dfs(self, nums, k, num, results): 
        results.append(num[:])
        
        for i in range(k, len(nums)):
            num.append(nums[i])
            self.dfs(nums, i+1, num, results)
            del num[-1]
```



#### **代碼解析**
```python
class Solution1:
    def subsets(self, nums):
        res = []  # 保存所有子集
        nums.sort()  # 確保數組有序
        self.dfs(nums, 0, [], res)  # 初始調用 dfs
        return res

    def dfs(self, nums, k, subset, res):
        res.append(subset[:])  # 將當前子集加入結果集（需要拷貝）
        for i in range(k, len(nums)):  # 遍歷當前索引到末尾的元素
            subset.append(nums[i])  # 將當前數字加入子集
            self.dfs(nums, i + 1, subset, res)  # 遞歸處理下一個數字
            del subset[-1]  # 回溯：移除剛加入的數字

```
pass

### **具體例子**

輸入：`nums = [1, 2, 3]`

執行過程：

1. 初始調用：`dfs(nums=[1, 2, 3], k=0, subset=[], res=[])`
    
    - 空子集 `[]` 加入結果集。
    - 遍歷 `nums` 的每個元素。
2. 第一層遞歸：
    
    - 選擇 `1`，執行：`dfs(nums=[1, 2, 3], k=1, subset=[1], res=[[]])`
        - 子集 `[1]` 加入結果集。
3. 第二層遞歸：
    
    - 選擇 `2`，執行：`dfs(nums=[1, 2, 3], k=2, subset=[1, 2], res=[[], [1]])`
        - 子集 `[1, 2]` 加入結果集。
4. 第三層遞歸：
    
    - 選擇 `3`，執行：`dfs(nums=[1, 2, 3], k=3, subset=[1, 2, 3], res=[[], [1], [1, 2]])`
        - 子集 `[1, 2, 3]` 加入結果集。
    - 回溯到 `subset=[1, 2]`。
5. 回溯並選擇其他分支：
    
    - 刪除 `2`，嘗試加入 `3`：`dfs(nums=[1, 2, 3], k=3, subset=[1, 3], res=[[], [1], [1, 2], [1, 2, 3]])`
        - 子集 `[1, 3]` 加入結果集。
6. 繼續回溯：
    
    - 移除 `1`，選擇 `2`：`dfs(nums=[1, 2, 3], k=2, subset=[2], res=[[], [1], [1, 2], [1, 2, 3], [1, 3]])`
        - 子集 `[2]` 加入結果集。
7. 重複上述過程，生成所有子集，最終結果為：
    
    python
    
    複製程式碼
    
    `[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]`
    

---

### **複雜度分析**

1. **時間複雜度**：
    
    - 遞歸樹中每個節點都代表一個子集。
    - 有 `2^n` 個子集，每個子集的生成需要線性時間處理（最多為 `O(n)`）。
    - 時間複雜度為 **O(n × 2^n)**。
2. **空間複雜度**：
    
    - 遞歸深度最多為 `n`（對應數組長度）。
    - 空間複雜度為 **O(n)**。

---

### **其他解法簡述**

#### 1. **位運算法**

- 使用二進制數表示子集的選擇，例如對於長度為 `n` 的數組，共有 `2^n` 種二進制數，`1` 表示選擇該數字，`0` 表示不選。
- 時間複雜度：**O(n × 2^n)**

#### 2. **迭代法**

- 從空集開始，對於數組中的每個數字，將其加入當前已有的所有子集中形成新的子集，並不斷更新結果集。
- 時間複雜度：**O(n × 2^n)**

#### 3. **內建函數**

- 使用 Python 的內建模組 `itertools`：
    
```python
from itertools import combinations
def subsets(nums):
    res = []
    for i in range(len(nums) + 1):
        res.extend(combinations(nums, i))
    return res

```
    
- 時間複雜度：**O(n × 2^n)**