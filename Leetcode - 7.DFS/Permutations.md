
LintCode 15 全排列（Permutations）問題需要生成一組數字的所有可能排列。這裡用深度優先搜索（DFS）解決問題，並逐步解釋，附具體例子和複雜度分析。

---

### **題目描述**

給定一個包含不重複數字的數組 `nums`，返回這些數字的所有可能排列。

例如：
`輸入: [1,2,3] 輸出: [   [1,2,3],   [1,3,2],   [2,1,3],   [2,3,1],   [3,1,2],   [3,2,1] ]`

---

### **DFS 解法**

DFS 是通過遞歸遍歷所有可能的排列，並在每個分支中選擇未訪問的數字。

#### **算法步驟**

1. **初始設置**：
    
    - 使用一個布爾數組 `visited`，記錄數字是否已經被選過。
    - 定義遞歸函數 `dfs(path)`，其中 `path` 表示當前的排列。
2. **遞歸結束條件**：
    
    - 當 `path` 的長度等於 `nums` 的長度時，將 `path` 加入結果集中。
3. **遞歸邏輯**：
    
    - 遍歷 `nums` 中的每個數字：
        - 如果該數字未被訪問，將其標記為已訪問，並將其加入 `path`。
        - 繼續遞歸 `dfs`。
        - 回溯：將該數字標記為未訪問，並從 `path` 中移除。
4. **返回結果**：
    
    - 遞歸結束後，返回所有排列。

---
Example:
样例
**样例 1：**
输入：
```python
列表 = [1]
```
输出：
```python
[
  [1]
]
```

**样例 2：**
输入：
```python
列表 = [1,2,3]
```
输出：
```python
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```

#### **具體實現代碼**

```python
def permute(nums):
    result = []        # 存儲最終的排列結果
    visited = [False] * len(nums)  # 用於記錄是否訪問過

    def dfs(path):
        if len(path) == len(nums):   # 遞歸結束條件
            result.append(path[:])   # 保存當前排列
            return
        
        for i in range(len(nums)):
            if not visited[i]:       # 若當前數字未被訪問
                visited[i] = True    # 標記為訪問
                path.append(nums[i]) # 加入當前排列
                dfs(path)            # 繼續遞歸
                path.pop()           # 回溯，移除當前數字
                visited[i] = False   # 重置訪問標記

    dfs([])  # 初始化遞歸
    return result

```
pass

---

#### **具體例子**

輸入 `nums = [1,2,3]`，執行過程如下：

1. 初始：
    
    - `path = []`，`visited = [False, False, False]`
2. 遍歷過程：
    
    - 選擇 `1`：`path = [1]`，`visited = [True, False, False]`
    - 選擇 `2`：`path = [1, 2]`，`visited = [True, True, False]`
    - 選擇 `3`：`path = [1, 2, 3]`，保存結果。
    - 回溯到 `path = [1, 2]`，選擇 `3`。
    - 重複上述步驟，直到所有排列被生成。

---

#### **複雜度分析**

1. **時間複雜度**：
    
    - 每次遞歸都需要在剩餘數字中進行選擇，樹的高度為 `n`，總共有 `n!` 個葉節點。
    - 時間複雜度為 **O(n × n!)**，因為每次構造排列時需要拷貝 `path`。
2. **空間複雜度**：
    
    - 遞歸深度為 `n`，需要 `O(n)` 的額外空間來存儲 `path` 和 `visited`。
    - 空間複雜度為 **O(n)**。

---

### **其他解法簡述**

#### 1. **迭代插入法**

- 核心思想是從空列表開始，逐步插入數字。
- 每插入一個數字時，遍歷當前的所有排列，將新數字插入到每個排列的每個位置。
- 時間複雜度：**O(n × n!)**

#### 2. **標準庫方法**

- 使用 Python 的內建 `itertools.permutations` 函數：
    
    python
    
    複製程式碼
    
    `from itertools import permutations def permute(nums):     return list(permutations(nums))`
    
- 時間複雜度：**O(n!)**

#### 3. **字典序生成法（非遞歸）**

- 將 `nums` 排序，然後按字典序不斷生成下一個排列（類似於全排列生成算法）。
- 時間複雜度：**O(n × n!)**



https://www.lintcode.com/problem/15/solution/56332

# 回溯算法入门级详解 + 练习

---

## 回溯算法与深度优先遍历

以下是维基百科中「回溯算法」和「深度优先遍历」的定义。  
  
  
**回溯法** 采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：  
  

- 找到一个可能存在的正确的答案；
- 在尝试了所有可能的分步方法后宣告该问题没有答案。

  
**深度优先搜索** 算法（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树或图的算法。这个算法会 **尽可能深** 的搜索树的分支。当结点 `v` 的所在边都己被探寻过，搜索将 **回溯** 到发现结点 `v` 的那条边的起始结点。这一过程一直进行到已发现从源结点可达的所有结点为止。如果还存在未被发现的结点，则选择其中一个作为源结点并重复以上过程，整个进程反复进行直到所有结点都被访问为止。  
我刚开始学习「回溯算法」的时候觉得很抽象，一直不能理解为什么递归之后需要做和递归之前相同的逆向操作，在做了很多相关的问题以后，我发现其实「回溯算法」与「 **深度优先遍历** 」有着千丝万缕的联系。  

## 个人理解

「回溯算法」与「深度优先遍历」都有「不撞南墙不回头」的意思。我个人的理解是：「回溯算法」强调了「深度优先遍历」思想的用途，用一个 **不断变化** 的变量，在尝试各种可能的过程中，搜索需要的结果。强调了 **回退** 操作对于搜索的合理性。而「深度优先遍历」强调一种遍历的思想，与之对应的遍历思想是「广度优先遍历」。至于广度优先遍历为什么没有成为强大的搜索算法，我们在题解后面会提。

## 搜索与遍历

我们每天使用的搜索引擎帮助我们在庞大的互联网上搜索信息。搜索引擎的「搜索」和「回溯搜索」算法里「搜索」的意思是一样的。

搜索问题的解，可以通过 **遍历** 实现。所以很多教程把「回溯算法」称为爆搜（暴力解法）。因此回溯算法用于 **搜索一个问题的所有的解** ，通过深度优先遍历的思想实现。

## 与动态规划的区别

### 共同点

用于求解多阶段决策问题。多阶段决策问题即：

- 求解一个问题分为很多步骤（阶段）；
- 每一个步骤（阶段）可以有多种选择。

### 不同点

- 动态规划只需要求我们评估最优解是多少，最优解对应的具体解是什么并不要求。因此很适合应用于评估一个方案的效果；
- 回溯算法可以搜索得到所有的方案（当然包括最优解），但是本质上它是一种遍历算法，时间复杂度很高。

## 从全排列问题开始理解回溯算法

我们尝试在纸上写 33 个数字、44 个数字、55 个数字的全排列，相信不难找到这样的方法。以数组 `[1, 2, 3]` 的全排列为例。

- 先写以 11 开头的全排列，它们是：`[1, 2, 3], [1, 3, 2]`，即 `1` + `[2, 3]` 的全排列（注意：**递归结构体现在这里**）；
- 再写以 22 开头的全排列，它们是：`[2, 1, 3], [2, 3, 1]`，即 `2` + `[1, 3]` 的全排列；
- 最后写以 33 开头的全排列，它们是：`[3, 1, 2], [3, 2, 1]`，即 `3` + `[1, 2]` 的全排列。

总结搜索的方法：按顺序枚举每一位可能出现的情况，已经选择的数字在 **当前** 要选择的数字中不能出现。按照这种策略搜索就能够做到 **不重不漏**。这样的思路，可以用一个树形结构表示。

看到这里的朋友，建议先尝试自己画出「全排列」问题的树形结构。  

![image.png](https://media-lc.lintcode.com/new_storage_v2/public/None/4/21/f759466a-c117-11ec-bed7-0242ac1f0002/image.png)

**说明**：

- **每一个结点表示了求解全排列问题的不同的阶段**，这些阶段通过变量的「不同的值」体现，这些变量的不同的值，称之为「状态」；
- 使用深度优先遍历有「回头」的过程，在「回头」以后， **状态变量需要设置成为和先前一样** ，因此在回到上一层结点的过程中，需要撤销上一次的选择，这个操作称之为「状态重置」；
- 深度优先遍历，借助系统栈空间，保存所需要的状态变量，在编码中只需要注意遍历到相应的结点的时候，状态变量的值是正确的，具体的做法是：往下走一层的时候，`path` 变量在尾部追加，而往回走的时候，需要撤销上一次的选择，也是在尾部操作，因此 `path` 变量是一个栈；
- 深度优先遍历通过「回溯」操作，实现了全局使用一份状态变量的效果。

使用编程的方法得到全排列，就是在这样的一个树形结构中完成 **遍历**，从树的根结点到叶子结点形成的路径就是其中一个全排列。

## 设计状态变量

- 首先这棵树除了根结点和叶子结点以外，每一个结点做的事情其实是一样的，即：在已经选择了一些数的前提下，在剩下的还没有选择的数中，依次选择一个数，这显然是一个 **递归** 结构；
- 递归的终止条件是： **一个排列中的数字已经选够了** ，因此我们需要一个变量来表示当前程序递归到第几层，我们把这个变量叫做 `depth`，或者命名为 `index` ，表示当前要确定的是某个全排列中下标为 `index` 的那个数是多少；
- 布尔数组 `used`，初始化的时候都为 `false` 表示这些数还没有被选择，当我们选定一个数的时候，就将这个数组的相应位置设置为 `true` ，这样在考虑下一个位置的时候，就能够以 O(1)O(1) 的时间复杂度判断这个数是否被选择过，这是一种「以空间换时间」的思想。

这些变量称为「状态变量」，它们表示了在求解一个问题的时候所处的阶段。需要根据问题的场景设计合适的状态变量。