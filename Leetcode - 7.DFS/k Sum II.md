
### **LintCode 90 k Sum II**

#### **題目描述**

給定一個整數數組 `A`，找出所有大小為 `k` 的子集，使得子集內所有元素的和等於 `target`。

例如：

`輸入: A = [1, 2, 3, 4], k = 2, target = 5 輸出: [[1, 4], [2, 3]]`

---

### **DFS 解法**

#### **算法思路**

使用深度優先搜索（DFS）遞歸遍歷所有可能的子集，過程中剪枝以提高效率。

1. **初始設置**：
    
    - 將數組 `A` 排序，方便剪枝處理。
    - 定義遞歸函數 `dfs(A, index, k, target, subset, subsets)`，其中：
        - `index`：當前遞歸處理的數組起始索引。
        - `k`：還需要選擇的元素個數。
        - `target`：還需達到的目標和。
        - `subset`：當前子集。
        - `subsets`：保存所有滿足條件的子集。
2. **遞歸終止條件**：
    
    - 當 `k == 0` 且 `target == 0`，將當前子集加入結果集。
    - 當 `k == 0` 或 `target <= 0` 時，無法再選擇更多元素，返回。
3. **遞歸邏輯**：
    
    - 遍歷從 `index` 開始的數字，嘗試選擇該數字加入子集：
        - 遞歸處理下一個數字。
        - 回溯：將該數字從子集中移除。

Example:
**样例 1：**
输入：
```
数组 = [1,2,3,4]
k = 2
target = 5
```
输出：
```
[[1,4],[2,3]]
```
解释：
1+4=5,2+3=5

**样例 2：**
输入：
```
数组 = [1,3,4,6]
k = 3
target = 8
```
输出：
```
[[1,3,4]]
```
解释：
1+3+4=8

#### **代碼解析**

```python
class Solution:
    def kSumII(self, A, k, target):
        A = sorted(A)  # 排序數組，方便剪枝
        subsets = []   # 保存結果
        self.dfs(A, 0, k, target, [], subsets)
        return subsets

    def dfs(self, A, index, k, target, subset, subsets):
        # 遞歸終止條件
        if k == 0 and target == 0:
            subsets.append(list(subset))  # 找到符合條件的子集
            return
        
        if k == 0 or target <= 0:  # 剪枝條件
            return

        # 遍歷剩餘的數字
        for i in range(index, len(A)):
            subset.append(A[i])  # 選擇當前數字
            self.dfs(A, i + 1, k - 1, target - A[i], subset, subsets)  # 遞歸處理下一層
            subset.pop()  # 回溯，移除當前數字

```
pass

#### **具體執行過程**

輸入：`A = [1, 2, 3, 4], k = 2, target = 5`

1. **初始化**：
    
    - `A = [1, 2, 3, 4]`（排序後無變化）。
    - `subsets = []`，開始遞歸。
2. **遞歸步驟**：
    
    - 第一層遞歸（工人數字選擇）：
        - 選擇 `1`：
            - 第二層遞歸：
                - 選擇 `2`，和為 `1 + 2 = 3`，不符合條件。
                - 選擇 `4`，和為 `1 + 4 = 5`，符合條件，加入結果集。
            - 回溯到第一層。
        - 選擇 `2`：
            - 第二層遞歸：
                - 選擇 `3`，和為 `2 + 3 = 5`，符合條件，加入結果集。
            - 回溯到第一層。
        - 選擇 `3`，和 `k` 不足，剪枝。
        - 選擇 `4`，和 `k` 不足，剪枝。
3. 最終結果：
    
    python
    
    複製程式碼
    
    `subsets = [[1, 4], [2, 3]]`
    

---

### **複雜度分析**

1. **時間複雜度**：
    
    - 理論上，遞歸遍歷所有大小為 `k` 的組合，總共有 (nk)\binom{n}{k}(kn​) 種組合，每種組合的構造需要線性時間 O(k)O(k)O(k)。
    - 時間複雜度為 **O(k × \binom{n}{k})**。
2. **空間複雜度**：
    
    - 遞歸深度為 `k`，每層需要存儲當前的 `subset`。
    - 空間複雜度為 **O(k)**。

---

### **其他解法簡述**

#### 1. **動態規劃**

- 定義狀態 `dp[i][j][t]` 表示前 `i` 個數字中選擇 `j` 個數字和為 `t` 的方案數。
- 狀態轉移：
    - 若不選第 `i` 個數字：`dp[i][j][t] = dp[i-1][j][t]`
    - 若選第 `i` 個數字：`dp[i][j][t] += dp[i-1][j-1][t-A[i]]`
- 最後返回所有合法方案。

#### 2. **迭代法**

- 使用類似 DFS 的邏輯，通過栈模擬遞歸過程。
- 時間複雜度與 DFS 相同。

#### 3. **位運算法**

- 遍歷所有大小為 `k` 的組合，計算其和是否等於 `target`。
- 時間複雜度較高，不適合大數據集。