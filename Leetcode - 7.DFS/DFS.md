
![[Pasted image 20240914170851.png]]
![[Pasted image 20240914170923.png]]

1. BFS vs DFS 複雜度
    
    時間複雜度= O(V + E), V頂點個數, E邊數
    
    BFS空間複雜度取決於寬度
    
    DFS空間複雜度取決於深度
    

5 DFS時間複雜度通用公式 = O(方案總數 * 構造每個方案的時間)

6 DFS都可以用遞歸(Recursion) 實現. 遞歸三步驟: 1遞歸定義2 遞歸拆解3 遞歸出口

7 絕大多數二叉樹(Binary Tree)的問題都可以用DFS求解. 遇到找所有方案的題基本上就是用DFS

8 90% DFS的題都是二叉樹, 10%DFS的題是組合(combination) 或排列(permutation), [1,2,3]和[3,2,1]是同一個組合但不同的排列

![[Pasted image 20240914171001.png]]

## **Lintcode模板 - 深度优先搜索 DFS**

## **使用条件**

- 找满足某个条件的所有方案（99%）
- 二叉树 `Binary Tree` 的问题（90%）
- 组合问题（95%）
    - 问题模型：求出所有满足条件的“组合”
    - 判断条件：组合中的元素是顺序无关的
- 排列问题（95%）
    - 问题模型：求出所有满足条件的“排列”
    - 判断条件：组合中的元素是顺序“相关”的

## **不要用 `DFS` 的场景**

- 连通块问题（一定要用 `BFS`，否则 `StackOverflow`）
- 拓扑排序（一定要用 `BFS`，否则 `StackOverflow`）
- 一切 `BFS` 可以解决的问题

## **复杂度**

- 时间复杂度：_O_(方案个数∗构造每个方案的时间)
    
    O(方案个数 * 构造每个方案的时间)
    
    - 树的遍历 ：_O_(_n_)
    - 排列问题 ：_O_(_n_!∗_n_)
    - 组合问题 ：_O_(2_n_∗_n_)

**代码模板**
![[Pasted image 20240914171047.png]]


| **题目编号**         | **题目名称 (英文/中文)**                                               | **题目简述 (中文)**                      | **样例**                                                                                                      | **解法**                              |
| ---------------- | -------------------------------------------------------------- | ---------------------------------- | ----------------------------------------------------------------------------------------------------------- | ----------------------------------- |
| 15<br>**<br>(m)  | 全排列 <br>[[Permutations]]                                       | 给定一个没有重复数字的数组，返回所有可能的排列。           | 输入：<br>[1,2,3]<br>输出：[<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1] ] | 使用 DFS 和回溯生成所有排列组合。                 |
| 816<br>*<br>(h)  | 旅行商问题 <br>[[Traveling Salesman Problem]]<br>                   | 给定城市的距离矩阵，找到访问所有城市的最短路径并返回起点。      | 输入: <br>n = 3<br>tuple = [<br>[1,2,1],<br>[2,3,2],<br>[1,3,3]]<br>输出: 3<br>                                 | 使用 DFS + 剪枝搜索所有路径，记录最小路径和。          |
| 17<br>**<br>(m)  | 子集 <br>[[Subsets]]                                             | 给定一个没有重复元素的数组，返回所有可能的子集。           | 輸入<br>[1,2,3]<br>輸出<br>[ [], [1], [1, 2],<br> [1, 2, 3], [1, 3], <br>[2], [2, 3], [3] ]                     | 使用 DFS 生成所有可能的组合，逐步扩展路径。            |
| 18<br>*<br>(m)   | 子集II <br>[[SubsetsII]]                                         | 给定一个可能包含重复元素的数组，返回所有可能的子集，且子集不能重复。 | 输入：<br>nums = [0] <br>输出：[ <br>  [], <br>  [0] ]                                                            | 对数组排序后使用 DFS，跳过重复元素生成子集。            |
| 90<br>*<br>(m)   | k数和（二） <br>[[k Sum II]]                                        | 找出数组中 k 个数字和等于目标值的所有组合，数字不可重复使用。   | 输入：数组 = <br>[1,2,3,4]<br>k = 2,target = 5<br>输出：<br>[ [1,4],[2,3] ]                                         | 使用 DFS 和回溯，按顺序选取数字并跳过重复组合。          |
| 802<br>*<br>(h)  | 数独 <br>[[Sudoku Solver]]<br>                                   | 求解一个数独问题，返回其唯一解。                   |                                                                                                             | 使用 DFS 尝试填充每个空格，验证数独规则，找到唯一解法。      |
| 427<br>*<br>(m)  | 生成括号 <br>[[Generate Parentheses]]<br>                          | 给定一个正整数 n，生成所有合法的括号组合。             | 输入: 2<br>输出: <br>["()()", <br>"(())"]                                                                       | 使用 DFS 和回溯生成合法括号组合，动态维护左右括号数量。      |
| 582<br>*<br>(h)  | 单词拆分II <br>[[Word BreakII]]                                    | 给定一个字符串和一个单词字典，返回该字符串的所有可能分割方案。    | 输入：<br>"lintcode"，<br>["de","ding",<br>"co","code",<br>"lint"]<br>输出：<br>["lint code", <br>"lint co de"]    | 使用 DFS 搜索分割点，结合回溯生成所有可能方案。          |
| 1360<br>*<br>(m) | 对称树 <br>[[Symmetric Tree]] <br>                                | 判断一棵二叉树是否为对称树。                     | 输入: <br>{1,2,2,3,4,4,3}<br>输出: true                                                                         | 使用 DFS 递归比较左右子树是否对称，检查值和结构是否一致。     |
| 1909<br>*<br>(m) | 订单分配 <br>[[Order Allocation]]                                  | 给定一个数组，返回所有可能的排列组合，支持重复数字。         | 输入：[<br>[1,2,4],<br>[7,11,16],<br>[37,29,22] ]<br>输出：<br>[1,2,0]                                            | 使用 DFS 和回溯生成所有排列，跳过重复组合。            |
| 1271<br>*<br>(h) | 查找集群内的<br>「关键连接」 <br>[[Critical Connections in a Network]]<br> | 找到网络中所有的关键连接，删除这些连接会导致网络分裂。        | 輸入: 4<br>[ [0,1],[1,2],<br>[2,0],[1,3] ]<br>輸出<br>[ [1,3] ]                                                 | 使用 Tarjan 算法实现 DFS，记录时间戳和低链接值，找出桥边。 |
| 480<br>**<br>(e) | 二叉树的<br>所有路径 <br>[[Binary Tree Paths]] <br>                    | 找出二叉树中从根到叶子的所有路径。                  | 输入：<br>{1,2}<br>输出：<br>["1->2"]                                                                             | 使用 DFS 遍历所有路径，记录从根到叶子的每条路径。         |
| 1469<br><br>(m)  | 树上最长路径 [[Longest Path On The Tree]]                            | 找出树中任意两个节点之间的最长路径长度。               | 输入:  <br>edges = [[1,2],[2,3],[2,4],[4,5]]  <br>输出: 3                                                       | 使用两次 DFS：第一次找出最远节点，第二次从最远节点计算最长路径。  |






