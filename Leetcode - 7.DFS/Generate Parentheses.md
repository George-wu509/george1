
### **LintCode 427：Generate Parentheses**

#### **題目描述**

給定一個整數 `n`，生成所有合法的 `n` 對括號的排列。

例如：
輸入: n = 3
輸出: [ "((()))", "(()())", "(())()", "()(())", "()()()" ]

---

### **DFS 解法**

#### **算法思路**

利用深度優先搜索（DFS），遞歸構造所有可能的括號組合，並在過程中檢查合法性：

1. **合法括號的條件**：
    
    - 左括號數量 `(` 必須不小於右括號數量 `)`。
    - 左括號數量和右括號數量均不能超過 `n`。
2. **狀態表示**：
    
    - 當前構造的括號組合由字符串 `path` 表示。
    - `left` 表示已用的左括號數量，`right` 表示已用的右括號數量。
3. **遞歸結束條件**：
    
    - 當左括號和右括號的數量都等於 `n` 時，表示構造完成，將結果加入集合。
4. **遞歸過程**：
    
    - 若左括號數量小於 `n`，可繼續添加左括號。
    - 若右括號數量小於左括號數量，可繼續添加右括號。

---
Example:
**样例 1:**
```
输入: 3
输出: ["((()))", "(()())", "(())()", "()(())", "()()()"] 
```
**样例 2:**
```
输入: 2
输出: ["()()", "(())"]
```

#### **代碼詳解**

```python
class Solution:
    def generateParenthesis(self, n):
        result = []  # 保存結果
        self.dfs("", 0, 0, n, result)  # 初始調用 DFS
        return result

    def dfs(self, path, left, right, n, result):
        # 遞歸結束條件：左右括號數均達到 n
        if left == n and right == n:
            result.append(path)
            return

        # 遞歸過程
        if left < n:  # 可添加左括號
            self.dfs(path + "(", left + 1, right, n, result)
        if right < left:  # 可添加右括號
            self.dfs(path + ")", left, right + 1, n, result)

```
pass
#### **執行過程舉例**

輸入：
`n = 3`

1. **初始調用**：
    
    - `dfs("", 0, 0, 3, result)`。
2. **第一層遞歸**：
    
    - 添加左括號：`dfs("(", 1, 0, 3, result)`。
3. **第二層遞歸**：
    
    - 添加左括號：`dfs("((", 2, 0, 3, result)`。
4. **第三層遞歸**：
    
    - 添加左括號：`dfs("(((", 3, 0, 3, result)`。
    - 遞歸結束條件未滿足，嘗試添加右括號：`dfs("((()", 3, 1, 3, result)`。
5. **繼續回溯**：
    
    - 不斷嘗試添加右括號，直到生成合法結果 `"((()))"`，並將其加入 `result`。
    - 回溯到上一層，嘗試其他分支。
6. **最終結果**：
    
    - 遍歷所有可能的括號組合，最終結果為：

        `["((()))", "(()())", "(())()", "()(())", "()()()"]`
        

---

### **複雜度分析**

1. **時間複雜度**：
    
    - 遞歸樹的深度為 2n2n2n，每層最多有兩種選擇，理論上最多有 22n2^{2n}22n 個節點。
    - 但由於合法括號的條件限制，實際節點數量遠小於 22n2^{2n}22n。
    - 合法括號的數量由 **卡塔蘭數** 表示，其值為： $C_n = \frac{1}{n+1} \binom{2n}{n}$ 因此時間複雜度為 **O(Cn)。
2. **空間複雜度**：
    
    - 遞歸調用棧的深度為 O(2n)。
    - 空間複雜度為 **O(2n)。

---

### **其他解法簡述**

#### 1. **BFS（廣度優先搜索）**

- 使用佇列模擬構造過程，每次從佇列中取出一個部分結果，嘗試添加括號。
- 與 DFS 的邏輯相似，但使用迭代代替遞歸。

#### 2. **動態規劃**

- 定義 `dp[i]` 為 iii 對括號的所有合法組合。
- 狀態轉移：
    - 對於 iii 對括號，可以在每個可能的 jjj 對括號內部放置合法括號，外部再加上剩餘的括號： dp[i]=for j=0 to i−1, dp[j]+dp[i-1-j]dp[i] = \text{for } j = 0 \text{ to } i-1, \text{ dp[j]} + \text{dp[i-1-j]}dp[i]=for j=0 to i−1, dp[j]+dp[i-1-j]
- 時間複雜度：**O(Cn2)O(C_n^2)O(Cn2​)**。

#### 3. **回溯 + 剪枝**

- 與 DFS 解法相似，但在過程中加入更多剪枝條件以減少不必要的分支。

---

### **對比分析**

- **DFS** 是最直觀且實現簡單的方法，適合理解括號生成過程。
- **動態規劃** 更適合需要高效計算且不關注生成具體過程的場景。
- **BFS** 與 DFS 思路相同，但以迭代方式實現，適合避免深度遞歸的情況。