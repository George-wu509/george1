
|                                                                                                                                                                                                                                                        |                                                                                                              |                                                           |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------- |
| Array  [[###### 數組]]<br>String  [[###### 字符串]]<br>Prefix Sum Array  [[###### 前綴和數組]]<br>Sorting [[###### 排序]]<br>line sweep [[###### 掃描線]]                                                                                                             |                                                                                                              | (18)<br>(36)<br>(16)<br>(2)<br>(1)                        |
| Bindary Search [[###### 二分法]]                                                                                                                                                                                                                          | Array二分查找, 搜索二维矩阵, 斐波纳契数列                                                                                    | (22)                                                      |
| Two Pointers [[###### 雙指針]]                                                                                                                                                                                                                            | 回文串, K数之和, 分割数组, 去除重复                                                                                        | (30)                                                      |
| Linked List  [[###### 鍊表]]<br>Doubly linked list  雙向链表                                                                                                                                                                                                 | LRU                                                                                                          | (24)<br>(2)                                               |
| Queue  [[###### 隊列]]<br>deque  雙向隊列<br>Monotone queue  [[###### 單調隊列]]                                                                                                                                                                                 | [[###### BFS ]] 层次遍历, 最短路径, 滑动窗口<br>*能用BFS就不要用DFS<br>连通块, 拓扑排序一定要用BFS 否則會錯誤<br><br>BFS有兩種方法 - queue or deque | (8)<br>(6)<br>(26)                                        |
| Stack [[###### 棧]]<br>Monotonic stack  [[###### 單調棧]]                                                                                                                                                                                                  | [[###### DFS]], 组合排列(10%), Binary Tree(90%)<br><br>DFS有兩種方法- recursion, no recursion                         | (13)<br>(18)<br>(16)                                      |
| Hash Map [[###### 哈希表]]<br>Union find  [[###### 併查集]]<br>Iterator  [[###### 迭代器]]                                                                                                                                                                      |                                                                                                              | (15)<br>(22)<br>(12)                                      |
| Binary Tree [[###### 二叉树]]<br>Binary Search Tree  [[###### 二叉搜索树]]<br>Heap [[###### 堆]]<br>Trie [[###### 字典树]]<br>Segmetn Tree  [[###### 线段树]]<br>Balanced Binary Tree [[###### 平衡二叉树]]<br>Binary Indexed Tree  [[###### 树状数组]]<br>Graph  [[###### 圖]] |                                                                                                              | (14)<br>(24)<br>(19)<br>(15)<br>(10)<br>(2)<br>(4)<br>(5) |
| DP [[###### 動態規劃]]                                                                                                                                                                                                                                     |                                                                                                              | (8)                                                       |
| Math 數學  [[###### 數學]]                                                                                                                                                                                                                                 |                                                                                                              | (1)                                                       |


|                  |                                                                                                                                                                                                                                                                                                               |                                                                                    |
| ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------- |
| Array            | nums.sort()  <br>nums2 = num2.sorted()<br><br>nums.reverse()<br>nums2 = num2.reversed()<br><br>[[位元運算]] XOR(^), AND(&), (\|, ~, <<, >>)<br><br>min_len = float('inf')<br><br>[[if not nums]]                                                                                                                  |                                                                                    |
| String           | str.strip().split()<br><br>collections.Counter(str)<br><br>(char1, char2) in zip(str1, str2)<br><br>i, (char1, char2) in enumerate(zip(str1, str2))<br><br>ord(ch)-ord('a')<br><br>str1.find(str2)<br><br>[[hash table]] use dict()<br><br>for char in string <br>     dicr[char] = dict.get(char, 0) + 1<br> | ex1<br>s1 = "ab tk xf"<br>s2 = s1.strip().split()<br>-><br>s2 = ['ab', 'tk', 'xf'] |
| Prefix Sum Array | for i, num in enumerate(nums)<br><br>[[單調隊列跟單調棧]]                                                                                                                                                                                                                                                             |                                                                                    |
|                  |                                                                                                                                                                                                                                                                                                               |                                                                                    |
|                  |                                                                                                                                                                                                                                                                                                               |                                                                                    |


# **<mark style="background: #FF5582A6;">數組（Array）</mark>的詳細介紹**
###### 數組

| 题目编号                 | 题目名称（英文）                                                  | 题目简述（中文）                                 | 样例                                                                              | 解法                                          |
| -------------------- | --------------------------------------------------------- | ---------------------------------------- | ------------------------------------------------------------------------------- | ------------------------------------------- |
| 156<br>**<br>(e)<br> | [[Merge Intervals]]<br>合并区间                               | 给定一组区间，合并所有重叠的区间。                        | 输入: <br>[(1,3),(2,6),<br>(8,10),(15,18)]<br> <br>输出: [(1,6),<br>(8,10),(15,18)] | 按区间起点排序，遍历并合并重叠区间。                          |
| 8<br>*<br>(e)        | [[Rotate String]]旋转字符数组                                   | 给定一个字符串和一个偏移量，根据偏移量旋转字符串。                | 输入: <br>"abcdefg"<br>offset = 3 <br><br>输出: <br>"efgabcd"<br><br>O(n),O(n)      | 将字符串分为两部分，分别反转，然后再整体反转。                     |
| 111<br>*<br>(e)      | [[Climbing Stairs]]爬楼梯                                    | 一次可以爬 1 步或 2 步，求爬到第 n阶台阶的总方法数。           | 输入: <br>n = 3 <br><br>输出: 3<br><br>O(n)                                         | 使用动态规划或斐波那契数列公式递推计算方法数。                     |
| 101<br><br>(e)       | [[Remove Duplicates from Sorted Array II]]删除排序数组中的重复数字（二) | 删除排序数组中出现超过两次的重复项，使每个元素最多出现两次，并返回新的数组长度。 | 输入: <br>[1,1,1,2,2,3] <br><br>输出: <br>5 <br>([1,1,2,2,3])                       | 使用双指针，一个指向当前遍历位置，一个指向更新位置，控制每个元素的出现次数不超过两次。 |
| 397<br>*<br>(e)<br>G | 最长上升连续子序列 [[Longest Continuous Increasing Subsequence]]   | 找到一個數組中，最长的连续严格上升子序列的长度。                 | 输入: <br>nums = [ 1,5,2,3,4 ]  <br><br>输出: 3   <br>([2,3,4])<br><br>O(n),O(1)    | 使用遍历一次数组的方法，记录当前的连续上升子序列长度，动态更新最大值。         |

# **<mark style="background: #FF5582A6;">字符串（String）</mark>的詳細介紹**
###### 字符串

| 题目编号                | 题目名称（英文）                              | 题目简述（中文）                                         | 样例                                                                                                                                    | 解法                                   |
| ------------------- | ------------------------------------- | ------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------ |
| 13<br>*<br>(e)      | [[Implement strStr]]字符串查找             | 实现 `strStr()` 函数，返回子字符串在母字符串中首次出现的索引，若不存在则返回 -1。 | 输入: <br>source = "abcdabcdefg", <br>target = "bcd" <br><br>输出: 1<br><br>暴力匹配（Brute Force）<br>O(m*n),O(1)                              | 使用双指针從0,0出發遍历源字符串，检查目标字符串是否匹配        |
| 647<br>*<br>(m)<br> | [[Find All Anagrams in a String]]子串字谜 | 在字符串中找到目标字符串所有变位词的起始索引                           | 输入:  <br>s = "cbaebabacd"  <br>p = "abc" <br> <br>输出:  [0,6] <br><br>("cba","bac")                                                    | 使用滑动窗口和哈希表记录字符频率。                    |
| 415<br>*<br>(m)     | [[Valid Palindrome]]有效回文串             | 判断一个字符串是否为回文，只考虑字母和数字字符，忽略大小写。                   | 输入: "A man, a plan, a canal: Panama" <br><br>输出: true<br>                                                                             | 使用双指针从字符串两端向中间移动，跳过非字母数字字符，比较字符是否相同。 |
| 171<br>**<br>(m)    | 乱序字符串 [[Anagrams]]                    | 给定一个字符串列表，找出其中所有乱序的字符串组。                         | 输入:  <br>strs = <br>["eat", "tea", "tan", <br>"ate", "nat", "bat"]  <br><br>输出: <br>[ ["eat","tea","ate"],<br>["tan","nat"],["bat"] ] | 将字符串排序后作为key存入字典，按key分组。             |
| 10<br><br>(m)       | 字符串的不同排列 [[String Permutation II]]    | 给定一个字符串，返回其所有不同的排列（考虑字符重复）。                      | 输入:  <br>s = "aab"  <br><br>输出: <br>["aab", "aba", "baa"]                                                                             | 使用DFS生成排列，并用集合去重或在递归中跳过重复字符。         |

# **<mark style="background: #BBFABBA6;">前綴和數組（Prefix Sum Array）</mark>的詳細介紹**
###### 前綴和數組

see [[Prefix summary]]

|                                    | nums = [1, 2, 3, 4]                   |     |
| ---------------------------------- | ------------------------------------- | --- |
| 前綴和 (Prefix Sum)                   | prefix_sum = [0, 1, 3, 6, 10]         |     |
| 後綴和 (Suffix Sum)                   | suffix_sum = [10, 9, 7, 4, 0]         |     |
| 前綴積 (Prefix Product)               | prefix_product = [1, 1, 2, 6, 24]     |     |
| 後綴積 (Suffix Product)               | suffix_product = [24, 24, 12, 4, 1]   |     |
|                                    |                                       |     |
| nums[1:3] 區域內和<br>=nums[1]+nums[2] | prefix_sum[3] - refix_sum[1]          |     |
| output[2] 元素以外乘積                   | Prefix Product[2] x Suffix Product[3] |     |
如果是有最長或最短子數組 這時用Two pointers method更好

| 题目编号                    | 题目名称（英文）                                     | 题目简述（中文）                                 | 样例                                                                                     | 解法                                                   |
| ----------------------- | -------------------------------------------- | ---------------------------------------- | -------------------------------------------------------------------------------------- | ---------------------------------------------------- |
| **138**<br>*<br>(e)<br> | [[Subarray Sum]]<br>子数组之和为零<br>              | 给定一个整数数组，找到和为零的子数组，返回第一个出现的子数组的起始和结束下标。  | 输入: <br>[-3, 1, 2, -3, 4] <br><br>输出: <br>[0, 2]<br><br>(和為0 [-3, 1, 2])<br>O(n)       | 使用前缀和数组，记录每个前缀和第一次出现的位置，若再次出现相同的前缀和，则表示子数组和为零。       |
| 1844<br>*<br>(m)        | [[Subarray Sum Equals to K II]] 子数组和为K的最短子数组 | 给定一个整数数组和一个整数k，你需要找到和为k的最短非空子数组，并返回它的长度。 | 输入:  <br>nums = [1, 1, 1, 2], k = 3  <br>输出: 2  <br><br>(**和為0找最短**[1,2])<br>O(n),O(n) | 使用前缀和与哈希表记录出现的和，通过快速查找加速匹配和为K的子数组数量。(用Two pointers?) |
| 406<br>*<br>(m)         | [[Minimum Size Subarray Sum]] 子数组和大於K的最短子数组  | 找出数组中和大于或等于 S 的最小连续子数组长度。                | 输入:  <br>nums = [2,3,1,2,4,3], <br>s = 7  <br>输出: 2  ([4,3])<br><br>(**和大於S找最短**)      | 使用滑动窗口动态调整窗口范围，记录最短长度。(最長最短用Two pointers.)           |

###### 排序 
參考 [[排序]]

| **题目编号**        | **题目名称 (英文/中文)**                 | **题目简述 (中文)**           | **样例**                                                                | **解法**                |
| --------------- | -------------------------------- | ----------------------- | --------------------------------------------------------------------- | --------------------- |
| 463<br>*<br>(e) | 整數排序 [[Classical Sort Integers]] | 对给定的整数数组进行排序，并返回排序后的数组。 | 输入:  <br>nums = [3,2,1,4,5]  <br>输出: [1,2,3,4,5]<br><br>O(nlogn),O(n) | 使用快速排序或内置排序方法对数组进行排序。 |

### 二分法的題目

###### 二分法

參考 [[二分法]]

| 题目编号            | 题目名称（英文）                                       | 题目简述（中文）                                             | 样例                                                                    | 解法                                                                                                                                                                                        |
| --------------- | ---------------------------------------------- | ---------------------------------------------------- | --------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 457<br><br>(e)  | [[Classical Binary Search]]<br>经典二分查找问题        | 在排序数组中找target，返回该数出现的任意位置，如果不存在，返回 -1。               | 输入: <br>nums = <br>[1,2,2,3,4,4]<br>target=2<br><br>输出: <br>1 or 2    | Array從頭尾開始用雙指針start, end取中位數mid比較target.然後取左半邊array或右半邊array繼續逼近, 最後start, end應該落在target區間的左右                                                                                             |
| 460<br>*<br>(m) | [[Find K Closest Elements]]<br>在排序数组中找最接近的K个数  | 在升序排列A中找与target最接近的k个整数                              | 输入: <br>A = [1, 2, 3]<br>target = 2<br>k = 3<br><br>输出: <br>[2, 1, 3] | 先利用Binary Search找到最接近target的數, 然後用雙指針向左向右尋找最接近target直到找到k個                                                                                                                                |
| 62<br>*<br>(m)  | [[Search in Rotated Sorted Array]]<br>搜索旋转排序数组 | 有序数组以某个元素作为支点进行了旋转. 给定一个目标值target进行搜索，假设数组中不存在重复的元素。 | 输入：<br>[4, 5, 1, 2, 3]<br>target = 1<br><br>输出：2                      | Array從頭尾開始用雙指針start, end取中位數mid,先判斷mid是左半邊(arraymid大於array[end])或右半邊. 如果在mid左半邊, 如果target在start跟mid之間則將end換成mid繼續, 否則start換成mid. 如果在mid右半邊, 如果target在mid跟end之間則將start換成mid繼續, 否則end換成mid. |
| 366<br><br>(e)  | [[Fibonacciseries]]<br>斐波纳契数列                  | 斐波纳契数列是指：前2个数是 0 和 1 。第 i 个数是第 i-1 个数和第i-2 个数的和      | 输入: <br>series=<br>0, 1, 1, 2, <br>3, 5, 8, 13, <br>21, 34..          | 尋找Fibonacci數列的第N的數. 可以建立一個fib=[0,1]. for迴圈從2開始到n+1. i=2時0+1=1更新成[1,1],i=3時更新成[1,2], i=4時更新成[3,2]. 其中1+2=array[3]使用fib[i%2] = fib[0]+fib[1]更新數值輪流存在fib[0]跟fib[1]                           |

### 雙指針的題目
###### 雙指針
參考 [[雙指針]]

|                                                              |     |
| ------------------------------------------------------------ | --- |
| 在list找兩個或多個數的和為k:   sort -> 雙指針<br>在list找連續子數組的和為k:      前綴和 |     |
| 比較(1)Fast Sorting (2)雙指針                                     |     |
|                                                              |     |
|                                                              |     |

| **题目编号**        | **题目名称 (英文/中文)**                                  | **题目简述 (中文)**                                       | **样例**                                                                                                                | **解法**                                                 |
| --------------- | ------------------------------------------------- | --------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------ |
| 56<br>**<br>(e) | [[Two Sum]]<br>两数之和                               | 在数组中找到两个数，使得它们的和等于目标值，返回它们的下标。                      | 输入: <br>[2, 7, 11, 15]<br>target = 9 <br><br>输出: [0, 1]<br><br>O(nlogn),O(n)                                          | 先排序然後用雙指針從左右往中間, 和target比較決定往右往左                       |
| 58<br>**<br>(m) | 四数之和  [[4Sum]]                                    | 给一个包含n个数的整数数组S，在S中找到所有使得和为给定整数target四元组(a, b, c, d) | 输入:  <br>numbers = <br>[2,7,11,15]<br>target=3<br><br>输出: []<br><br>O(n^3),O(1)                                       | 固定两个点，然后用双指针的做法，扫描一下后续数组，记录答案即可。                       |
| 90<br>*<br>(m)  | K数之和 II [[k Sum II]]                              | 找出数组中和等于目标值的 k 个数的所有组合，每个数只能使用一次。                   | 输入:  <br>nums = <br>[10,1,2,7,6,1,5]<br>target = 8, <br>k = 2  <br><br>输出: [ <br>[1,7],[2,6] <br>]<br><br>O(2^n),O(k) | 使用DFS遞歸遍歷所有可能的子集，過程中剪枝以提高效率                            |
|                 | **滑動窗口**                                          |                                                     |                                                                                                                       |                                                        |
| 604<br>*<br>(e) | 滑动窗口内数的和 [[Window Sum]]                           | 给定一个数组和窗口大小 k，返回每个窗口的元素和。                           | 输入:  <br>nums = <br>[1,2,3,4,5]<br>k = 3  <br><br>输出: [6,9,12]                                                        | 使用双指针滑动窗口计算每个窗口的和，避免重复计算。                              |
|                 |                                                   |                                                     |                                                                                                                       |                                                        |
|                 | **分割數組**                                          |                                                     |                                                                                                                       |                                                        |
| 31<br>**<br>(m) | 分割数组 [[Partition Array]]                          | 给定一个数组和目标值，将数组分割成两部分，使得左边的所有数小于目标值，右边的所有数大于等于目标值。   | 输入:  <br>nums = [3,2,2,1]<br>target = 2  <br><br>输出: [1,2,2,3]                                                        | (Quick sort)使用双指针，从两端向中间移动，将小于目标值的数移到左边，大于等于目标值的数移到右边。 |
|                 |                                                   |                                                     |                                                                                                                       |                                                        |
| 64<br>*<br>(e)  | 合并排序数组（简单版） [[Merge Sorted Array (easy version)]] | 将两个已排序数组合并为一个排序数组。                                  | 输入<br>A = [1,2,3]<br>m = 3<br>B = [4,5]<br>n = 2<br><br>输出:<br>[1,2,3,4,5]                                            | 从两个数组的index=0,0开始比较，将较大元素依次插入 nums1 的后半部分。             |


# **<mark style="background: #FF5582A6;">链表（Linked List）</mark>的详细介绍**

###### 鍊表

| 题目编号               | 题目名称（英文）                                           | 题目简述（中文）                 | 样例                                                                              | 解法                                                                 |
| ------------------ | -------------------------------------------------- | ------------------------ | ------------------------------------------------------------------------------- | ------------------------------------------------------------------ |
| 35<br>*<br>(e)     | [[Reverse Linked List]]翻转链表                        | 反转一个链表。                  | 输入: <br>1->2->3->null <br><br>输出: <br>3->2->1->null                             | 使用迭代或递归方法反转链表。迭代方法中，遍历链表，将当前节点的 next 指向前一个节点。递归方法中，递归反转子链表，然后调整指针。 |
| 112<br><br>(e)<br> | [[Remove Duplicates from Sorted List]]删除排序链表中的重复元素 | 删除排序链表中的重复元素，使每个元素只出现一次。 | 输入: <br>1->1->2->3->3->null <br><br>输出: <br>1->2->3->null                       | 遍历链表，删除重复的节点。                                                      |
| 165<br>*<br>(e)    | [[Merge Two Sorted Lists]]合并两个排序链表                 | 将两个排序链表合并为一个新的排序链表。      | 输入: <br>1->2->4->null, <br>1->3->4->null <br><br>输出: <br>1->1->2->3->4->4->null | 使用迭代或递归方法合并两个链表。迭代方法中，使用两个指针遍历两个链表，按顺序连接节点。递归方法中，递归合并子链表。          |



# **<mark style="background: #FF5582A6;">队列（Queue）</mark>的详细介绍**

 ###### 隊列

| 题目编号                | 题目名称（英文）                                | 题目简述（中文）                                             | 样例                                                                                                                        | 解法                                                                                                              |
| ------------------- | --------------------------------------- | ---------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------- |
| 494<br>*<br>(e)<br> | [[Implement Stack using Queues]]双队列实现栈  | 使用队列实现栈，支持 `push(x)`、`pop()`、`top()` 和 `empty()` 操作。 | 输入：<br>push(1)<br>pop()<br>push(2)<br>isEmpty() // return false<br>top() // return 2<br>pop()<br>isEmpty() // return true | 使用两个队列实现栈功能：一个队列用于存储元素，另一个队列用于辅助反转元素顺序。每次插入元素时，将新元素添加到辅助队列，然后将主队列的所有元素依次移动到辅助队列，交换主辅队列。                         |
| 40<br><br>(m)       | [[Implement Queue by Two Stacks]]用栈实现队列 | 使用两个栈实现队列，支持 `push(element)`、`pop()` 和 `top()` 操作。   | 队列操作 = <br>    push(1)<br>    pop()    <br>    push(2)<br>    push(3)<br>    top()    <br>    pop()                       | 使用两个栈实现队列功能：一个栈用于入队操作，另一个栈用于出队操作。当出队栈为空时，将入队栈的所有元素依次弹出并压入出队栈，然后从出队栈弹出元素以实现队列的先进先出特性。                            |
| 362<br>**<br>(h)    | [[Sliding Window Maximum]]滑动窗口的最大值      | 给定一个整数数组和滑动窗口大小，找出每个窗口中的最大值。                         | 输入: <br>nums = <br>[1,3,-1,-3,<br>5,3,6,7]<br><br>k = 3 <br>输出: <br>[3,3,5,5,6,7]                                         | 使用双端队列（deque）维护当前窗口的最大值索引。遍历数组时，移除队列中不在当前窗口范围内的元素，并移除队列中小于当前元素的所有元素，然后将当前元素索引添加到队列。当前元素索引大于等于窗口大小时，队首即为当前窗口最大值。 |



# **<mark style="background: #ADCCFFA6;">单调队列（Monotone Queue）</mark>的详细介绍**

###### 單調隊列

| 题目编号             | 题目名称（英文）                                                | 题目简述（中文）                                                     | 样例                                                                                | 解法                                                                                                              |
| ---------------- | ------------------------------------------------------- | ------------------------------------------------------------ | --------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------- |
| 3542<br><br>(e)  | 非负前缀和 [[Non-Negative Prefix Sum]]                       | 给定一个环形整数数组 nums，其长度为 n. 计算该环形数组的前缀和，有多少个下标可以使得该前缀和的所有元素均为非负数 | 输入:  <br>nums = <br>[-3,5,1,2]<br><br>输出: 2                                       | 将nums复制一份并接在给定的nums之后做前缀和处理                                                                                     |
| 362<br>**<br>(h) | [[Sliding Window Maximum]]滑动窗口的最大值                      | 给定一个整数数组和滑动窗口大小，找出每个窗口中的最大值。                                 | 输入: <br>nums = <br>[1,3,-1,-3,<br>5,3,6,7]<br><br>k = 3 <br>输出: <br>[3,3,5,5,6,7] | 使用双端队列（deque）维护当前窗口的最大值索引。遍历数组时，移除队列中不在当前窗口范围内的元素，并移除队列中小于当前元素的所有元素，然后将当前元素索引添加到队列。当前元素索引大于等于窗口大小时，队首即为当前窗口最大值。 |
| 1507<br>*<br>(h) | 和至少为 K 的最短子数组 [[Shortest Subarray with Sum at Least K]] | 给定一个整数数组，找到和至少为K的最短子数组长度，若不存在返回-1。                           | 输入:  <br>nums = <br>[2, -1, 2]<br>k = 3  <br><br>输出: 3                            | 使用单调队列记录前缀和，动态检查当前子数组和是否满足条件并更新最短长度。                                                                            |

### BFS(寬度優先搜索)的題目
###### BFS 
參考 [[BFS]]

| **题目编号**                   | **题目名称 (英文/中文)**                 | **题目简述 (中文)**                                    | **样例**                                                                                                                 | **解法**                            |
| -------------------------- | -------------------------------- | ------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------- | --------------------------------- |
| 433<br>**<br>(e)           | 岛屿的个数 [[Number of Islands]]      | 给定一个二维网格，计算其中岛屿的数量。                              | 输入：<br>[<br>  [1,1,0,0,0],<br>  [0,1,0,0,1],<br>  [0,0,0,1,1],<br>  [0,0,0,0,0],<br>  [0,0,0,0,1]<br>]<br><br>输出：<br>3 | 使用 BFS 遍历每个岛屿，将相邻陆地标记为已访问。        |
| 611<br>**<br>(m)<br><br>PR | 骑士的最短路线 [[Knight Shortest Path]] | 在棋盘上从起点移动到终点，返回骑士所需的最小步数。                        | 输入:<br>[ [0,0,0],<br> [0,0,0],<br> [0,0,0] ]<br>source = [2, 0] <br>destination <br>= [2, 2] <br><br>输出: 2             | 使用 BFS 搜索骑士的合法移动路径，记录访问状态以避免重复。   |
| 598<br>*<br>(m)<br><br>PR  | 僵尸矩阵 [[Zombie in Matrix]]        | 给定一个二维网格，找到将所有人类转化为僵尸所需的最短时间。1:僵尸, `0`：人类, `2`：墙 | 输入:<br>grid = [<br>[0,1,0],<br>[1,0,0],<br>[0,0,0] ]<br><br>输出: 2                                                      | 使用 BFS 模拟传播过程，记录时间步数。**多源 BFS**   |
| 137<br>**<br>(m)           | 克隆图 [[Clone Graph]]              | 给定一个无向图，返回其深度克隆后的新图。                             | 输入:<br>{1,2,4#2,1<br>,4#4,1,2}<br><br>输出: <br>{1,2,4#2,1<br>,4#4,1,2}                                                  | 使用哈希表记录已访问节点，结合 BFS 克隆节点及其邻接点。    |
| 616<br>*<br>(m)            | 课程表 II [[Course Schedule II]]    | 判断是否可以完成所有课程，并返回完成课程的顺序。你只要返回一种就可以了。             | 输入: <br>n = 4,<br>prerequisites = <br>[ [1,0],[2,0],<br>[3,1],[3,2] ] <br><br>输出: <br>[0,1,2,3] or <br>[0,2,1,3]       | 使用 BFS 实现**拓扑排序**，记录节点的入度，依次完成课程。 |


### DFS(深度優先搜索)的題目

###### DFS
參考 [[DFS]]

輸入  [1,2,3]

Permutations: 排列
[ [1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1] ]

Subsets: 子集
[ [], [1], [1, 2],[1, 2, 3], [1, 3], [2], [2, 3], [3] ]

Combinations: 組合
[ [1,2], [2,3], [1,3] ]

| **题目编号**                  | **题目名称 (英文/中文)**            | **题目简述 (中文)**                   | **样例**                                                                                                                    | **解法**                     |
| ------------------------- | --------------------------- | ------------------------------- | ------------------------------------------------------------------------------------------------------------------------- | -------------------------- |
| 15<br>**<br>(m)<br><br>PR | 全排列 <br>[[Permutations]]    | 给定一个没有重复数字的数组，返回所有可能的排列。        | 输入：<br>[1,2,3]<br><br>输出：[<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1] ]           | 使用 DFS 和回溯生成所有排列组合。        |
| 17<br>**<br>(m)<br><br>PR | 子集 <br>[[Subsets]]          | 给定一个没有重复元素的数组，返回所有可能的子集。        | 輸入<br>[1,2,3]<br><br>輸出<br>[ [], [1], [1, 2],<br> [1, 2, 3], [1, 3], <br>[2], [2, 3], [3] ]                               | 使用 DFS 生成所有可能的组合，逐步扩展路径。   |
| 152<br><br>(m)            | [[Combinations]]组合          | 找到从 n 个数字中选择 k 个数字的所有组合。        | 输入:  <br>n = 4  ([1,2,3,4])<br>k = 2  <br><br>输出:  <br>[ [2,4],[3,4],<br>[2,3],[1,2],<br>[1,3],[1,4] ]<br>                | 使用回溯法和哈希表记录每次选择的数字。        |
| 153<br><br>(m)            | [[Combination Sum II]]组合II  | 找到数组中和等于目标值的所有不重复组合。            | 输入:  <br>candidates = <br>[10,1,2,7,6,1,5]  <br>target = 8  <br><br>输出:  <br>[ [1,1,6],[1,2,5]<br>,[1,7],[2,6] ]          | 使用回溯法结合哈希表记录已访问的数字避免重复。    |
| 582<br>*<br>(h)           | 单词拆分II <br>[[Word BreakII]] | 给定一个字符串和一个单词字典，返回该字符串的所有可能分割方案。 | 输入：<br>"lintcode"，<br>wordDict=<br>["de","ding",<br>"co","code",<br>"lint"]<br><br>输出：<br>["lint code", <br>"lint co de"] | 使用 DFS 搜索分割点，结合回溯生成所有可能方案。 |



# **<mark style="background: #FF5582A6;">栈（Stack）</mark>的详细介绍**

###### 棧

| 题目编号                | 题目名称（英文）                        | 题目简述（中文）                                          | 样例                                                                                                        | 解法                                          |
| ------------------- | ------------------------------- | ------------------------------------------------- | --------------------------------------------------------------------------------------------------------- | ------------------------------------------- |
| 12<br>*<br>(m)      | [[Min Stack]]带最小值操作的栈           | 设计一个支持常数时间内获取最小值的栈，支持 `push`、`pop` 和 `getMin` 操作。 | 输入:  <br>stack.push(-2)  <br>stack.push(0)  <br>stack.push(-3)  <br>stack.getMin() <br> <br>输出: -3        | 使用两个栈，一个存储元素，一个存储最小值，更新最小值时同步操作。            |
| 859<br>*<br>(h)<br> | 最大栈 [[Max Stack]]               | 设计一个支持 `push`、`pop` 和 `getMax` 操作的栈，能够返回栈中最大值。    | 输入:  <br>push(5), <br>push(1), <br>push(5), <br>getMax(), <br>pop(), <br>getMax()  <br><br>输出: <br>[5, 5] | 使用两个栈，一个存储元素，另一个维护当前最大值，确保 `getMax` 操作的高效性。 |
| 368<br>*<br>(h)     | 表达式求值 [[Expression Evaluation]] | 给一个用字符串表示的表达式数组，求出这个表达式的值。                        |                                                                                                           | 使用递归的方法，先处理 +-<br>再处理 */最后再处理括号。            |


# **<mark style="background: #ADCCFFA6;">单调栈（Monotonic Stack）</mark>的详细介绍**

###### 單調棧

| 题目编号                | 题目名称（英文）                                     | 题目简述（中文）                                                     | 样例                                                                                                      | 解法                                                               |
| ------------------- | -------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------- |
| 1206<br><br>(e)<br> | [[Next Greater Element I]]<br>下一个更大元素 I      | 给定两个数组 `nums1` 和 `nums2`，找出 `nums1` 中每个元素在 `nums2` 中的下一个更大元素 | 输入:  <br>nums1 = [4,1,2]<br>nums2 = [1,3,4,2]<br><br>输出: [-1,3,-1]                                      | 使用 单调递减栈 来找到 nums2 中每个元素的下一个更大值, 使用 哈希表记录每个元素的下一个更大值，方便在nums1中查找 |
| 363<br>**<br>(m)    | [[Trapping Rain Water]]接雨水                   | 计算柱状图中能够存储的雨水总量。                                             | 输入:  <br>height = <br>[0,1,0,2,<br>1,0,1,3,  <br>2,1,2,1] <br> <br>输出:  <br>6                           | 使用双指针和单调栈记录左右最大高度，计算每个位置的雨水。                                     |
| 1274<br><br>(m)<br> | [[Find K Pairs with Smallest Sum]]查找和最小的K对数字 | 找到两个已排序数组中和最小的 k 对数对。                                        | 输入:  <br>nums1 = [1,7,11]  <br>nums2 = [2,4,6]  <br>k = 3  <br><br>输出:  [<br>[1,2],<br>[1,4],<br>[1,6]] | 使用最小堆或单调栈动态生成数对并维护大小。                                            |


# **<mark style="background: #FF5582A6;">哈希表（Hash Map）</mark>的详细介绍**

###### 哈希表

| 题目编号             | 题目名称（英文）                               | 题目简述（中文）                            | 样例                                                                                                         | 解法                                   |
| ---------------- | -------------------------------------- | ----------------------------------- | ---------------------------------------------------------------------------------------------------------- | ------------------------------------ |
| 124<br>*<br>(m)  | [[Longest Consecutive Sequence]]最长连续序列 | 给定一个未排序的整数数组，找出最长连续序列的长度。           | 输入:  <br>nums = <br>[100,4,200,1,3,2]  <br><br>输出:  <br>4 (1,2,3,4)                                        | 使用哈希表记录数组中的数字，动态扩展连续序列的长度。           |
| 128<br>**<br>(m) | 哈希函数 [[Hash Function]]                 | 设计一个简单的哈希函数，将字符串映射到指定大小的哈希表。        | 输入:  <br>key = "hello"<br>HASH_SIZE = 10 <br> <br>输出: 2                                                    | 使用字符串的ASCII值结合哈希表大小进行取模运算。           |
| 129<br>**<br>(m) | 重哈希 [[Rehashing]]                      | 给定一个哈希表和一个新的大小，对其进行重新哈希，使得数据分布更加均匀。 | 输入:  <br>hash_table = <br>[null,21,null,<br>null,14,null] <br> <br>输出: <br>[null,null,null,<br>null,14,21] | 遍历原哈希表，将非空元素根据新大小重新计算哈希值并插入新哈希表。     |
| 547<br>**<br>(e) | 两数组的交集 [[Intersection of Two Arrays]]  | 给定两个数组，返回它们的交集，结果中不包含重复元素。          | 输入:  <br>nums1 = <br>[1,2,2,1]<br>nums2 = [2,2] <br> <br>输出: [2]                                           | 使用哈希表记录第一个数组的元素，遍历第二个数组时检查是否存在于哈希表中。 |


# **<mark style="background: #ADCCFFA6;">并查集（Union-Find）</mark>的详细介绍**

###### 併查集

| 题目编号             | 题目名称（英文）                                                                | 题目简述（中文）                  | 样例                                                                                                                                                    | 解法                               |
| ---------------- | ----------------------------------------------------------------------- | ------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------- |
| 432<br><br>(m)   | [[Find the Weak Connected Component in the Directed Graph]]找出有向图中的弱连通分量 | 找到有向图中所有的弱连通分量。           | 输入:  <br>nodes = <br>[ [1,2],[2,3],[4,5] ]  <br><br>输出:  <br>[ [1,2,3],[4,5] ]                                                                        | 使用并查集维护节点的连通性，合并有边的节点。           |
| 178<br>**<br>(m) | 图是否是树 [[Graph Valid Tree]]                                              | 判断一个无向图是否是一棵树。            | 输入: <br>n = 5 <br>edges = [<br>[0, 1], [0, 2], <br>[0, 3], [1, 4]]<br><br>输出: true                                                                    | 使用并查集判断图是否连通且无环。                 |
| 589<br>*<br>(m)  | 连接图 [[Connecting Graph]]                                                | 判断图中两个节点是否连通，并支持动态合并节点。   | 输入:<br>ConnectingGraph(5)<br>query(1, 2)<br>connect(1, 2)<br>query(1, 3) <br>connect(2, 4)<br>query(1, 4) <br><br>输出:<br>[false,false,true]           | 使用并查集维护节点连通关系，查询时检查根节点是否相同。      |
| 590<br>*<br>(m)  | 连接图II [[Connecting Graph II]]                                           | 在图的基础上增加边权，并支持动态合并和连通性查询。 | 输入:<br>ConnectingGraph2(5)<br>query(1)<br>connect(1, 2)<br>query(1)<br>connect(2, 4)<br>query(1)<br>connect(1, 4)<br>query(1)<br><br>输出:<br>[1,2,3,3] | 并查集基础上记录每个集合的边权和，查询时检查连通性并计算边权和。 |


# **<mark style="background: #ADCCFFA6;">迭代器（Iterator）</mark>的详细介绍**
###### 迭代器

| 题目编号               | 题目名称（英文）                                | 题目简述（中文）                        | 样例                                                                        | 解法                      |
| ------------------ | --------------------------------------- | ------------------------------- | ------------------------------------------------------------------------- | ----------------------- |
| 540<br><br>(m)<br> | [[Zigzag Iterator]]左旋右旋迭代器              | 给定两个列表，实现一个迭代器，以之字形顺序输出两个列表的元素。 | 输入:  <br>v1 = [1,2]  <br>v2 = [3,4,5,6]  <br><br>输出:  <br>[1,3,2,4,5,6]   | 使用队列存储非空列表的迭代器，按顺序依次访问。 |
| 528<br><br>(m)     | [[Flatten Nested List Iterator]]摊平嵌套的列表 | 将嵌套列表展开为一个扁平化的迭代器。              | 输入:  <br>nestedList = <br>[ [1,1],2,[1,1] ]  <br><br>输出:  <br>[1,1,2,1,1] | 使用栈存储嵌套列表，递归展开当前列表项。    |
| 601<br>*<br>(m)    | [[Flatten 2D Vector]]摊平二维向量             | 将二维数组展开为一个扁平化的迭代器。              | 输入:<br>vec2d = <br>[ [1,2],[3],[4,5,6] ]<br><br>输出:<br>[ 1,2,3,4,5,6 ]    | 使用索引记录当前行和列，动态访问元素。     |


# **<mark style="background: #FF5582A6;">二叉树（Binary Tree）</mark>的详细介绍**

###### 二叉树

| 题目编号               | 题目名称（英文）                                            | 题目简述（中文）              | 样例                                                                                    | 解法                                 |
| ------------------ | --------------------------------------------------- | --------------------- | ------------------------------------------------------------------------------------- | ---------------------------------- |
| 67<br>*<br>(e)     | [[Binary Tree Inorder Traversal]]- 二叉树的中序遍历         | 返回二叉树的中序遍历结果。         | 输入:  <br>root = <br>[1,null,2,3]  <br><br>输出:  <br>[1,3,2]                            | 使用递归或栈完成中序遍历操作。                    |
| 70<br>*<br>(m)<br> | [[Binary Tree Level Order Traversal II]]二叉树的层次遍历 II | 返回二叉树的层次遍历结果（从底层到顶层）。 | 输入:  <br>root = <br>[3,9,20,null,<br>null,15,7]  <br><br>输出:  [<br>[15,7],[9,20],[3]] | 使用队列按层遍历节点，结果反转。                   |
| 480<br>**<br>(e)   | 二叉树的<br>所有路径 <br>[[Binary Tree Paths]] <br>         | 找出二叉树中从根到叶子的所有路径。     | 输入：<br>{1,2}<br><br>输出：<br>["1->2"]                                                   | 使用 DFS 遍历所有路径，记录从根到叶子的每条路径。        |
| 1469<br><br>(m)    | 树上最长路径 [[Longest Path On The Tree]]                 | 找出树中任意两个节点之间的最长路径长度。  | 输入:  <br>edges = [<br>[1,2],[2,3],<br>[2,4],[4,5]]  <br><br>输出: 3                     | 使用两次 DFS：第一次找出最远节点，第二次从最远节点计算最长路径。 |


# **<mark style="background: #BBFABBA6;">二叉搜索树（Binary Search Tree）</mark>的详细介绍**
###### 二叉搜索树

| 题目编号             | 题目名称（英文）                                     | 题目简述（中文）                    | 最简单样例                                                                  | 解法                              |
| ---------------- | -------------------------------------------- | --------------------------- | ---------------------------------------------------------------------- | ------------------------------- |
| 597<br>**<br>(e) | 具有最大平均数的子树 [[Subtree with Maximum Average]]  | 找出二叉树中具有最大平均数的子树。           | 输入:  <br>root = <br>[1,-5,11,1,2,4,-2]  <br><br>输出: [11,4,-2]          | 使用递归后序遍历计算子树的节点和和节点数，动态更新最大平均值。 |
| 596<br>*<br>(e)  | 最小子树 [[Minimum Subtree]]                     | 找出二叉树中和最小的子树。               | 输入:  <br>root = <br>[1,-5,2,1,2,3,-4]  <br><br>输出: [-5,1,2]            | 使用后序遍历计算子树的和，动态记录最小值及其根节点。      |
| 88<br>**<br>(m)  | 最近公共祖先 [[Lowest Common Ancestor (LCA)]]      | 找出二叉树中两个节点的最近公共祖先，节点一定存在树中。 | 输入:  <br>root = <br>{4,3,7,#,#,5,6}<br>p = 3, <br>q = 5  <br><br>输出: 3 | 递归检查左右子树是否包含目标节点，结合二叉树特性优化查找。   |
| 1524<br><br>(e)  | 在二叉搜索树中查找 [[Search in a Binary Search Tree]] | 在二叉搜索树中查找一个值是否存在，并返回该节点。    | 输入:  <br>root = <br>[4,2,7,1,3]<br>val = 2  <br><br>输出: [2,1,3]        | 使用递归或迭代根据二叉搜索树特性快速定位目标节点。       |
| 1181<br>*<br>(e) | 二叉树的直径 [[Diameter of Binary Tree]]           | 找出二叉树中两个节点之间的最长路径长度。        | 输入:  <br>root = <br>[1,2,3,4,5]  <br><br>输出: 3                         | 使用后序遍历计算每个节点的左右子树深度，动态更新最长路径长度。 |


# **<mark style="background: #FF5582A6;">堆（Heap）</mark>的详细介绍**
###### 堆

| 题目编号            | 题目名称（英文）                                        | 题目简述（中文）                    | 最简单样例                                                                                               | 解法                           |
| --------------- | ----------------------------------------------- | --------------------------- | --------------------------------------------------------------------------------------------------- | ---------------------------- |
| 130<br><br>(m)  | [[Heapify]] 堆化                                  | 给定一个未排序的数组，将其调整为堆（最小堆或最大堆）。 | 输入:  <br>nums = <br>[3,2,1,4,5]  <br><br>输出:  <br>[1,2,3,4,5]                                       | 使用下沉操作构建堆，从最后一个非叶节点向上调整堆。    |
| 612<br>*<br>(m) | [[K Closest Points]] K个最近的点                     | 找到离原点最近的 k 个点。              | 输入:  <br>points = [<br>[1,3],[-2,2],[2,-2]]  <br>k = 2  <br><br>输出:  <br>[ [-2,2],[2,-2] ]          | 使用最大堆存储 k 个最近的点，动态比较并维护堆的大小。 |
| 839<br><br>(e)  | [[Merge Two Sorted Interval Lists]] 合并两个排序的间隔列表 | 合并两个排序的区间列表，返回一个合并后的列表。     | 输入:  <br>list1 = [<br>[1,2],[3,4]]  <br>list2 = [<br>[2,3],[5,6]]  <br><br>输出:  <br>[ [1,4],[5,6] ] | 使用最小堆维护区间的起点，逐步合并重叠区间。       |


# **<mark style="background: #ADCCFFA6;">字典树（Trie）</mark>的详细介绍**
###### 字典树


| 题目编号             | 题目名称（英文）                                | 题目简述（中文）                          | 最简单样例                                                                                           | 解法                          |
| ---------------- | --------------------------------------- | --------------------------------- | ----------------------------------------------------------------------------------------------- | --------------------------- |
| 442<br>**<br>(m) | [[Implement Trie (Prefix Tree)]] 实现前缀树  | 实现一个字典树（前缀树），支持插入、查找和判断前缀操作。      | 输入: <br>insert("lintcode")<br>search("lint")<br>startsWith("lint")<br><br>输出: <br>false<br>true | 使用嵌套字典构造前缀树，递归或迭代实现插入和查询操作。 |
| 473<br>**<br>(m) | [[Add and Search Word]] 单词的添加与查找        | 实现一个单词搜索数据结构，支持通配符查询（“.”表示任意字符）。  | 输入:<br>addWord("a")<br>search(".")<br><br>输出: <br>true                                          | 使用字典树构建单词结构，递归处理通配符匹配。      |
| 1071<br><br>(e)  | [[Longest Word in Dictionary ]]词典中最长的单词 | 找到字典中可以逐步构建的最长单词，多个答案时返回字典序最小的单词。 |                                                                                                 | 使用字典树构建词典，按长度和字典序排序返回结果。    |



# **<mark style="background: #ADCCFFA6;">线段树（Segment Tree）</mark>的详细介绍**
###### 线段树

| 题目编号            | 题目名称（英文）                                             | 题目简述（中文）                | 最简单样例                                                              | 解法                       |
| --------------- | ---------------------------------------------------- | ----------------------- | ------------------------------------------------------------------ | ------------------------ |
| 201<br><br>(m)  | [[Leetcode - 10.Advanced/Segment Tree Build]] 线段树的构造 | 构建一个线段树，支持范围查询和修改操作。    | 输入:  <br>nums = [3,2,1,4]<br>  <br>输出:  <br>线段树的根节点                | 使用递归分治构建线段树，每个节点存储区间值。   |
| 202<br><br>(m)  | [[Segment Tree Query]] 线段树的查询                        | 实现线段树的查询操作，返回指定范围内的最小值。 | 输入:  <br>nums = [3,2,1,4]  <br>query(1,3)  <br><br>输出:  1          | 使用线段树的递归方法，逐层访问区间并返回最小值。 |
| 212<br>*<br>(e) | [[Space Replacement ]]空格替换                           | 将字符串中的空格替换为 `%20`。      | 输入:  <br>s = "Mr John Smith"  <br><br>输出:  <br>"Mr%20John%20Smith" | 使用双指针从后向前遍历字符串，替换空格。     |


# **<mark style="background: #ADCCFFA6;">平衡二叉树（Balanced Binary Tree）</mark>的详细介绍**
###### 平衡二叉树

| **题目编号**        | **题目名称 (英文/中文)**               | **题目简述 (中文)**                        | **样例**                                                                     | **解法**                                     |
| --------------- | ------------------------------ | ------------------------------------ | -------------------------------------------------------------------------- | ------------------------------------------ |
| 93<br>*<br>(e)  | 平衡二叉树 [[Balanced Binary Tree]] | 判断一棵二叉树是否为平衡二叉树（每个节点的左右子树高度差不超过 1）。  | 输入:  <br>root = <br>[3,9,20,null,null,15,7]  <br><br>输出: true              | 使用递归计算每个节点的高度，检查左右子树的高度差，若所有节点满足条件则为平衡二叉树。 |
| 1513<br><br>(m) | 考场就座 [[Exam Room]]             | 实现一个考场就座系统，支持学生尽可能坐到离他人最远的位置，支持离开座位。 | 输入:  <br>seat(), <br>seat(), <br>leave(0), <br>seat()  <br><br>输出: [0,9,4] | 使用平衡二叉树存储座位区间，动态更新座位状态，通过区间长度计算最优座位。       |



# **<mark style="background: #ADCCFFA6;">树状数组（Binary Indexed Tree）</mark>的详细介绍**
###### 树状数组

| **题目编号**             | **题目名称 (英文/中文)**                                       | **题目简述 (中文)**                   | **样例**                                                                                                                                                      | **解法**                                   |
| -------------------- | ------------------------------------------------------ | ------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------- |
| 249<br>*<br>(h)      | 统计前面比自己小的数的个数 [[Count of Smaller Numbers Before Self]] | 给定一个数组，统计每个数字前面比它小的数字个数，并返回结果。  | 输入:  <br>nums = [5,2,6,1]  <br><br>输出:  <br>[2,1,1,0]                                                                                                       | 使用树状数组维护前缀和，动态更新数字的出现次数，通过查询累计小于当前数字的计数。 |
| 817<br>*<br>(m)      | 范围矩阵元素和 - 可变的 [[Range Sum Query 2D - Mutable]]         | 给定一个二维矩阵，支持更新单个元素值和查询任意子矩阵的元素和。 | 输入:  <br>matrix = [<br>[3,0,1,4,2],<br>[5,6,3,2,1],<br>[1,2,0,1,5],<br>[4,1,0,1,7],<br>[1,0,3,0,5]]<br>update(3,2,2)<br>sumRegion(2,1,4,3)  <br><br>输出: [8] | 使用二维树状数组，动态更新矩阵元素，通过查询累加子矩阵的和。           |
| 840<br>*<br>(m)      | 可变范围求和 [[Range Sum Query - Mutable]]                   | 给定一个数组，支持更新单个元素值和查询任意子数组的元素和。   | 输入:  <br>nums = [1,3,5]  <br>update(1,2)  <br>sumRange(0,2) <br><br>输出:  8                                                                                  | 使用树状数组维护前缀和，动态更新元素值，通过查询累加子数组的和。         |
| 1645<br>*<br>(m)<br> | 最少子序列 [[Minimum Subsequence in Non-Increasing Order]]  | 给定一个数组，找到总和大于剩余数字总和的最小递减子序列。    | 输入:  <br>nums = [4,3,10,9,8]  <br>输出: [10,9]                                                                                                                | 先对数组排序，使用树状数组维护前缀和，动态查找满足条件的最小子序列。       |



# **<mark style="background: #ADCCFFA6;">圖（Graph）</mark>的詳細介紹**
###### 圖

| 题目编号            | 题目名称（英文和中文）                                           | 题目简述（中文）                       | 最简单样例                                                                                                    | 解法                             |
| --------------- | ----------------------------------------------------- | ------------------------------ | -------------------------------------------------------------------------------------------------------- | ------------------------------ |
| 176<br><br>(m)  | [[Route Between Two Nodes in Graph]] (两点间路径)          | 判断有向图中是否存在两个节点之间的路径。           | 输入:  <br>graph = [ <br>[1, 2], <br>[3], <br>[3], [] ]  <br>start = 0  <br>end = 3  <br><br>输出:  <br>true | 使用 BFS 或 DFS 遍历图，检查是否能到达目标节点。  |
| 431<br>*<br>(m) | [[Connected Component in Undirected Graph]] (无向图连通分量) | 找到无向图中的所有连通分量。                 | 输入:  <br>graph = [ <br>[1, 2], [], <br>[3], [] ] <br> <br>输出:  <br>[<br>[0, 1, 2, 3]]                    | 使用 BFS 或 DFS 遍历图，记录每个连通分量中的节点。 |
| 618<br><br>(m)  | [[Search Graph Nodes ]](搜索图节点)                        | 在图中查找与目标节点颜色相同的所有节点，返回距离最近的节点。 | 输入:  <br>graph = [ <br>[1, 2], [0, 3], <br>[0, 3], [1, 2]]  <br>target = 2 <br> <br>输出:  [2, 3]          | 使用 BFS 遍历图，同时检查节点颜色。           |
| 1078<br><br>(e) | [[Degree of an Array]] (数组的度)                         | 找到具有数组中相同度的最短连续子数组长度。          | 输入:  <br>nums = <br>[1, 2, 2, 3, 1]  <br><br>输出:  2出:  <br>2                                             | 使用哈希表记录元素的首次和最后出现位置以及频率，计算结果。  |
| 836<br><br>(h)  | [[Partition to K Equal Sum Subsets]] (分割为K个等和子集)      | 判断是否可以将数组分成 k 个子集，使每个子集的和相等。   | 输入:  <br>nums = <br>[4, 3, 2, 3, 5, 2, 1]  <br>k = 4  <br><br>输出:  true                                  | 使用回溯和动态规划检查可能的分区方案。            |


### 動態規劃的題目
###### 動態規劃

| **题目编号**            | **题目名称 (英文/中文)**                                      | **题目简述 (中文)**                         | **样例**                                                       | **解法**                              |
| ------------------- | ----------------------------------------------------- | ------------------------------------- | ------------------------------------------------------------ | ----------------------------------- |
| 77<br>**<br>(m)<br> | 最长公共子序列 [[Longest Common Subsequence]]                | 找到两个字符串的最长公共子序列长度。                    | 输入:  <br>text1 = "abcde"<br>text2 = "ace"  <br><br>输出: 3     | 使用二维动态规划表记录两个字符串的匹配情况，逐步更新最长子序列长度。  |
| 119<br>*<br>(h)     | 编辑距离 [[Edit Distance]]                                | 找到两个字符串之间的最小编辑距离，包括插入、删除和替换操作。        | 输入:  <br>word1 = "horse"<br>word2 = "ros" <br><br>输出: 3      | 使用二维动态规划表记录转换的最小操作次数，更新每步操作结果。      |
| 76<br>*<br>(m)      | 最长上升子序列 [[Longest Increasing Subsequence]]            | 找到数组中的最长严格递增子序列。                      | 输入:  <br>nums = <br>[10,9,2,5,3,<br>7,101,18]  <br><br>输出: 4 | 使用动态规划记录以每个元素为结尾的最长子序列长度，遍历数组更新最大值。 |
| 92<br><br>(m)       | 背包问题 [[Backpack]]                                     | 给定一个背包的最大容量和一组物品的体积，找到可以装下的最大体积。      | 输入:  <br>m = 10, <br>nums = [3,4,8,5]  <br><br>输出: 9         | 使用动态规划记录每个容量下的最大体积，逐步更新最优解。         |
| 149<br>*<br>(m)     | [[Best Time to Buy and Sell Stock]]买卖股票的最佳时机          | 找到最大利润，允许一次买入和一次卖出股票。                 | 输入:  <br>prices =<br>[7,1,5,3,6,4]  <br><br>输出:  5           | 使用哈希表记录最低价格和当前利润。                   |
| 150<br>*<br>(m)     | [[Best Time to Buy and Sell Stock II]]买卖股票的最佳时机II     | 找到最大利润，可以多次买入和卖出股票。                   | 输入:  <br>prices = <br>[7,1,5,3,6,4]  <br><br>输出:  7          | 使用哈希表动态记录买入和卖出操作。                   |
| 1164<br><br>(m)<br> | [[Wiggle Subsequence]]摆动序列                            | 给定一个数组，找到最长的摆动子序列，摆动子序列的相邻数字之差总是正负交替。 | 输入:  <br>nums = <br>[1,7,4,9,2,5]  <br><br>输出:  6            | 使用动态规划记录以当前值结尾的最长摆动子序列长度。           |
| 151<br>*<br>(m)     | 买卖股票的最佳时机 III [[Best Time to Buy and Sell Stock III]] | 找到最多完成两笔交易的情况下可以获得的最大利润。              | 输入:  <br>prices = <br>[3,3,5,0,0,3,1,4]  <br><br>输出: 6       | 使用动态规划结合双指针，分别计算每次交易的最大利润。          |

###### 數學

| **题目编号**       | **题目名称 (英文/中文)**        | **题目简述 (中文)**                                   | **样例**                | **解法**                                                                     |
| -------------- | ----------------------- | ----------------------------------------------- | --------------------- | -------------------------------------------------------------------------- |
| 513<br><br>(m) | [[Perfect Squares]]完美平方 | 给定一个正整数 n，找到至少需要多少个完全平方数（比如 1、4、9 等）使得它们的和等于 n。 | 输入: `n = 12`<br>输出: 3 | 使用队列进行广度优先搜索（BFS）。从 n 开始，减去每个小于等于 n 的完全平方数，将结果作为下一层的节点，直到找到 0 为止，记录层数作为结果。 |
