
**Knowledge**

1. 時間複雜度:  O(longN)

> Before you build a better mousetrap, it helps to know if there are any mice out there. —Yogi Berra

2. 需要已升序排序

3. 查詢通常用Hash table, 時間複雜度O(1), 但缺點是Hash表是基於內存的, 如果集合太大會有問題

數組雖然放在內存但也可放在磁盤

4. 普通查找時間複雜度O(N) > O(logN) 二分法. 但消耗的空間一樣. 普通查找不需要有序

5. 二分模板要背! 注意要用 start+1<end 才不會最後一次可能死循環

## **Lintcode模板 - 二分法 Binary Search**

## **使用条件**

- 排序数组（30-40% 是二分）
- 当面试官要求你找一个比 O(n)_O_(_n_) 更小的时间复杂度算法的时候（99%）
- 找到数组中的一个分割位置，使得左半部分满足某个条件，右半部分不满足（100%）
- 找到一个最大/最小的值使得某个条件被满足（90%）

## **复杂度**

- 时间复杂度：O(logn)
- 空间复杂度：O(1)

**代码模板**
![[Pasted image 20240914165703.png]]

我的模板:
![[Pasted image 20240914165824.png]]

| 4. 二分法 Bindary Search                                                                                                                                     |                                                                                                                                                                                                                               |
| --------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| <span style="color:rgb(0, 256, 0)">Q457</span> ==经典二分查找问题== [[Classical Binary Search]]<br>nums = [1,2,2,3,4,4], target=2                                 | Array從頭尾開始用雙指針start, end取中位數mid比較target.然後取左半邊array或右半邊array繼續逼近, 最後start, end應該落在target區間的左右                                                                                                                                 |
| <span style="color:rgb(0, 256, 0)">Q14</span> 二分查找 [[Binary Search]]<br>nums = [1,2,2,3,4,4], target=2                                                    | Array從頭尾開始用雙指針start, end取中位數mid比較target.然後取左半邊array或右半邊array繼續逼近, 最後start, end應該落在target區間的左右, 取start                                                                                                                         |
| <span style="color:rgb(0, 256, 0)">Q458</span>  ==目标最后位置==  [[Last Position of Target]]<br>nums = [1,2,2,3,4,4], target=2                                 | Array從頭尾開始用雙指針start, end取中位數mid比較target.然後取左半邊array或右半邊array繼續逼近, 最後start, end應該落在target區間的左右, 取end                                                                                                                           |
| <span style="color:rgb(0, 0, 256)">Q447</span>  在大数组中查找  [[Search in a Big Sorted Array]]<br>nums = [1,3,6,9,21..], target=120                            | 先利用ArrayReader.get()找到比target大的index (在while迴圈x2直到大於target),然後就利用bindary search. Array的值用ArrayReader.get()取得                                                                                                                  |
| <span style="color:rgb(0, 0, 256)">Q460</span>  ==在排序数组中找最接近的K个数== [[Find K Closest Elements]]<br>nums = [1,4,6,8] target=3 k=3                           | 先利用Binary Search找到最接近target的數, 然後用雙指針向左向右尋找最接近target直到找到k個                                                                                                                                                                    |
| <span style="color:rgb(0, 0, 256)">Q585</span>  山脉序列中的最大值 [[Maximum Number in Mountain Sequence]]<br>nums = [1,2,4,8,6,3]                                 | Array從頭尾開始用雙指針start, end取中位數mid, 然後比較array[mid]-array[mid-1]. 如果小於0則以mid為end繼續逼近. 到最後取array[start],array[end]的最大值                                                                                                             |
| <span style="color:rgb(0, 0, 256)">Q159</span>  ==寻找旋转排序数组中的最小值== [[Find Minimum in Rotated Sorted Array]]<br>nums = [4,5,6,7,0,1,2]                      | Array從頭尾開始用雙指針start, end取中位數mid, 然後如果array[mid]大於array[end], 則mid取代start. 繼續逼近. 到最後取array[start],array[end]的最小值                                                                                                               |
| <span style="color:rgb(0, 0, 256)">Q62</span>  ==搜索旋转排序数组== [[Search in Rotated Sorted Array]]<br>nums = [4,5,1,2,3] target=1                             | Array從頭尾開始用雙指針start, end取中位數mid,先判斷mid是左半邊(arraymid大於array[end])或右半邊. 如果在mid左半邊, 如果target在start跟mid之間則將end換成mid繼續, 否則start換成mid. 如果在mid右半邊, 如果target在mid跟end之間則將start換成mid繼續, 否則end換成mid.                                     |
| <span style="color:rgb(0, 0, 256)">Q75</span>  寻找峰值 [[Find Peak Element]]<br>nums = [1,2,1,3,4,5,7,6]                                                     | 尋找任一個峰. Array用二分法尋找target.用雙指針start, end取中位數mid. 如果mid比右邊一個高(nums[mid]>nums[mid+1]), mid取代end. 反之則用mid取代start                                                                                                                 |
| <span style="color:rgb(256, 0, 0)">Q183</span>  木材加工 [[Wood Cut]]<br>L = [232, 124, 456] k=7<br>                                                          | 求得到至少k段木頭的最大長度. 先建立一個函數,get_pieces()輸入長度輸出pieces數. 木頭長度用start=1,end=max(nums=456)進行binary search, 尋找木頭段數最接近k的長度                                                                                                               |
| <span style="color:rgb(0, 256, 0)">Q28</span>  搜索二维矩阵 [[Search a 2D Matrix]]<br>matrix = [<br>[1,3,5,7]<br>[10,11,16,20]<br>[23,30,34,50]]<br>target=3    | 條件:搜索 m × n矩阵中的值 target是否存在. 每行中的整数从左到右是排序的。每行的第一个数大于上一行的最后一个整数. 所以這二維矩陣=一維連續矩陣, 使用Bindary Search, value=matrix[mid//col][mid%col] 將二維轉成一維                                                                                    |
| <span style="color:rgb(0, 0, 256)">Q38</span>  搜索二维矩阵（二） [[Search a 2D Matrix II]]<br>matrix = [<br>	[1,3,5,7]<br>	[2,4,7,8]<br>	[3,5,9,10]], target=3    | 條件:搜索 m × n矩阵中的值 target有幾個. 每行中的整数从左到右是排序的。每一列的整数从上到下是排序的。在每一行或每一列中没有重复的整数。可以使用从右上角开始的搜索 策略搜索target出現的次數. 右上角開始(0,len(matrix[0])-1)如果大於target則往左移動(i-=1), 如果小於target則往下移動(j+=1).                                              |
| <span style="color:rgb(256, 0, 0)">Q600</span>  包裹黑色像素点的最小矩形 [[Smallest Rectangle Enclosing Black Pixels]]<br>["1110","1100","0000","0000"], x = 0, y = 1 | 我们可以通过DFS或BFS来找到所有的黑色像素点，确定其矩形边界。此外，也可以利用二分搜索来快速找到黑色像素的边界（上下左右）。從上往下到x搜尋到第一個包含1的行, 以及其他三個方向搜尋(下左右). 從上往下到x搜尋先取mid然後用binaey search可以用 any(image[mid][j] == '1' for j in range(minR, maxR))確定那個row有沒有1                          |
| <span style="color:rgb(0, 0, 256)">Q437</span>  ==书籍复印== [[Copy Books]]<br>pages=[3,2,4]k=2                                                               | 求k個人複印完所有的書需要多少時間(example: k=1->9min,k=2->5min,k=3->4min). 用binary search在區間start=4,end=9尋找小於人數k的時間. 建立一個function get_least_people()輸入pages跟時間輸出人數. 在function內可以如下操作譬如time=6min, 從第一本書開始3<6, 3+2<6, 而3+2+4>6所以要加一個人. 所以輸出人數=2 |
| <span style="color:rgb(0, 256, 0)">Q366</span> 斐波纳契数列 [[Fibonacciseries]]<br>series=0, 1, 1, 2, 3, 5, 8, 13, 21, 34..                                     | 尋找Fibonacci數列的第N的數. 可以建立一個fib=[0,1]. for迴圈從2開始到n+1. i=2時0+1=1更新成[1,1],i=3時更新成[1,2], i=4時更新成[3,2]. 其中1+2=array[3]使用fib[i%2] = fib[0]+fib[1]更新數值輪流存在fib[0]跟fib[1]                                                               |
|                                                                                                                                                           |                                                                                                                                                                                                                               |
<mark style="background: #BBFABBA6;">Easy</mark>   <mark style="background: #FFB86CA6;">Mid</mark>   <mark style="background: #FF5582A6;">Hard</mark>

| 题目编号               | 题目名称（英文）                                            | 题目简述（中文）                      | 样例                                                                 | 解法                       |
| ------------------ | --------------------------------------------------- | ----------------------------- | ------------------------------------------------------------------ | ------------------------ |
| 60<br><br>(e)      | [[Search Insert Position]]搜索插入位置                    | 在排序数组中找到目标值的插入位置。             | 输入: [1, 3, 5, 6], target = 5 输出: 2                                 | 使用二分查找找到目标值或其应插入的位置。     |
| 61<br><br>(m)      | [[Search for a Range]]搜索区间                          | 在排序数组中找到目标值的起始和结束位置。          | 输入: [5, 7, 7, 8, 8, 10], target = 8 输出: [3, 4]                     | 使用二分查找分别找到目标值的起始和结束位置。   |
| 662<br><br>(e)<br> | [[Guess Number Higher or Lower]]猜数游戏                | 实现猜数字游戏，目标是找到一个 1 到 n 范围内的数字。 | 输入:  <br>n = 10, pick = 6  <br>输出:  <br>6                          | 使用二分搜索逐步缩小范围。            |
| 666<br><br>(m)     | [[Guess Number Higher or Lower II]]猜数游戏 II          | 找到最小的最大花费金额来猜中数字。             | 输入:  <br>n = 10  <br>输出:  <br>16                                   | 使用动态规划模拟猜测过程，优化最大花费。     |
| 148<br><br>(m)<br> | [[Sort Colors]]颜色分类                                 | 对数组中的三种颜色（0、1、2）进行排序。         | 输入:  <br>nums = [2,0,2,1,1,0]  <br>输出:  <br>[0,0,1,1,2,2]          | 使用哈希表记录每种颜色的频率后重建数组。     |
| 143<br><br>(m)     | [[Sort Colors II]]颜色分类 II                           | 对包含 k 种颜色的数组进行排序，颜色从 1 到 k。   | 输入:  <br>colors = [3,2,2,1,4]  <br>k = 4  <br>输出:  <br>[1,2,2,3,4] | 使用哈希表记录每种颜色出现的频率后重建数组。   |
| 144<br><br>(m)<br> | [[Interleaving Positive and Negative Numbers]]交错正负数 | 重新排列数组使得正负数交替出现。              | 输入:  <br>nums = [-1,-2,1,2]  <br>输出:  <br>[1,-1,2,-2]              | 使用哈希表和双指针分别记录正数和负数并交替排列。 |


### Q75  寻找峰值 Find Peak Element

这道题要求我们在给定的数组 `nums` 中找到一个峰值的位置。峰值的定义是满足条件 `nums[P] > nums[P-1]` 且 `nums[P] > nums[P+1]`。题目明确说明相邻元素不同，并且至少存在一个峰值，因此我们可以安全地搜索峰值而不会担心找不到它。

这里我们可以使用 **二分查找** 来高效地解决这个问题。二分查找的时间复杂度是 O(log⁡n)O(\log n)O(logn)，适用于此题的需求。

### 思路

1. 通过二分查找，将数组 `nums` 一分为二。
2. 计算中间位置 `mid`。
3. 如果 `nums[mid] > nums[mid + 1]`，则峰值可能在 `mid` 或左边（即左侧存在峰值），因此可以移动右指针到 `mid`。
4. 如果 `nums[mid] < nums[mid + 1]`，则峰值一定在右边（右侧存在峰值），可以将左指针移动到 `mid + 1`。
5. 最终，当左右指针重合时，即找到一个峰值的位置。

### 示例代码
```
from typing import List

def findPeakElement(nums: List[int]) -> int:
    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right) // 2
        # 如果中间值比右边的值大，峰值在左半部分或是 mid 本身
        if nums[mid] > nums[mid + 1]:
            right = mid
        else:
            # 如果中间值比右边的值小，峰值在右半部分
            left = mid + 1
    return left  # left == right 时返回任意一个峰值的位置

```
### 详细解释

假设 `nums` 是一个长度为 `n` 的数组。我们通过二分查找方法逐步缩小查找范围。每次将中间的元素与它右边的元素进行比较，根据大小关系来判断峰值的可能位置：

1. **初始化指针**：左指针 `left` 指向数组的起始位置 `0`，右指针 `right` 指向数组的末尾 `n-1`。
2. **计算中间值 `mid`**：在循环中每次更新 `mid = (left + right) // 2`。
3. **比较大小**：
    - 如果 `nums[mid] > nums[mid + 1]`，说明左边可能有峰值，也可能 `mid` 自己是一个峰值，因此我们将 `right` 更新为 `mid`。
    - 如果 `nums[mid] < nums[mid + 1]`，说明右边存在峰值，我们将 `left` 更新为 `mid + 1`。
4. **结束条件**：当 `left == right` 时，指针重合，峰值的位置已经找到，即 `left` 或 `right` 的位置。

### 时间复杂度分析

二分查找使得时间复杂度为 O(log⁡n)O(\log n)O(logn)，效率较高，尤其适用于大规模数据的情况。

### 示例

python

複製程式碼

`# 示例用例 print(findPeakElement([1, 2, 3, 1]))  # 输出可能是 2，因为 3 是一个峰值 print(findPeakElement([1, 2, 1, 3, 5, 6, 4]))  # 输出可能是 1 或 5`

### 复杂度分析

- **时间复杂度**：O(log⁡n)O(\log n)O(logn)，因为我们每次将搜索空间减半。
- **空间复杂度**：O(1)O(1)O(1)，只使用了常数空间来存储指针和变量。

这样，我们就成功地使用二分查找找到了峰值的位置。由于题目只要求返回一个峰值的位置，此方法满足需求并高效完成。


### Q38  搜索二维矩阵（二） Search a 2D Matrix II

要在这个二维矩阵 `matrix` 中高效地搜索目标值 `target` 并返回其出现的次数。矩阵的特点是每一行和每一列都是排序的并且严格递增，因此可以利用这一特性来设计一个更高效的算法。

### 原理和流程

考虑到矩阵是“部分有序”的（即每行、每列严格递增），可以使用一个 **从右上角开始的搜索** 策略。这种方法的优势在于：

- **当前元素比目标值大**：我们可以向左移动，因为这一列所有值都比当前值小。
- **当前元素比目标值小**：我们可以向下移动，因为这一行所有值都比当前值小。

通过这种策略，每次移动都能排除一整行或一整列，从而逐渐缩小搜索空间。

### 步骤

1. **初始化指针**：从矩阵的右上角开始，指针初始位置为 `(row, col) = (0, n - 1)`。
2. **比较并移动指针**：
    - 如果当前元素等于目标值 `target`，增加计数器 `count` 并向左移动一列（因为行中没有重复值，所以无需继续在同一行搜索）。
    - 如果当前元素大于目标值 `target`，向左移动一列（因为当前元素及其右边元素都大于目标）。
    - 如果当前元素小于目标值 `target`，向下移动一行（因为当前元素及其上方元素都小于目标）。
3. **结束条件**：当指针超出矩阵边界时，搜索结束，返回计数器 `count` 的值。

### 示例代码
```
from typing import List

def searchMatrix(matrix: List[List[int]], target: int) -> int:
    if not matrix or not matrix[0]:
        return 0
    
    # 行数和列数
    m, n = len(matrix), len(matrix[0])
    row, col = 0, n - 1  # 从右上角开始
    count = 0
    
    while row < m and col >= 0:
        if matrix[row][col] == target:
            count += 1  # 发现目标值，计数+1
            col -= 1  # 向左移动
        elif matrix[row][col] > target:
            col -= 1  # 当前值大于目标值，向左移动
        else:
            row += 1  # 当前值小于目标值，向下移动
    
    return count  # 返回出现次数

```

### 详细解释

假设 `matrix` 是一个大小为 `m x n` 的矩阵，`target` 是我们要搜索的目标值。

1. **初始化**：我们从右上角 `(row, col) = (0, n - 1)` 开始。这样设置有助于根据当前元素与 `target` 的大小关系确定移动方向。
2. **条件判断**：
    - **若 `matrix[row][col] == target`**：找到目标值，增加计数器 `count`，然后向左移动一列以继续搜索其他可能的匹配项。
    - **若 `matrix[row][col] > target`**：说明目标值在当前元素的左侧，因此将列指针左移 `col -= 1`。
    - **若 `matrix[row][col] < target`**：说明目标值可能在当前元素的下方，因此将行指针下移 `row += 1`。
3. **循环终止**：循环在 `row >= m` 或 `col < 0` 时结束，即当指针超出矩阵边界时。

### 时间复杂度分析

- **时间复杂度**：每次循环会使 `row` 增加或 `col` 减少，因此最多执行 `m + n` 步。所以时间复杂度为 O(m+n)O(m + n)O(m+n)。
- **空间复杂度**：我们只使用了常数空间 `O(1)`，因此空间复杂度为 O(1)O(1)O(1)。

### 示例
```
# 示例用例
matrix = [
    [1, 3, 5, 7],
    [2, 4, 7, 8],
    [3, 5, 9, 10]
]
target = 3
print(searchMatrix(matrix, target))  # 输出: 2

```
在上述示例中，`3` 在矩阵中出现了两次，因此返回结果为 `2`。

这种方法利用了矩阵的部分有序特性，避免了逐行、逐列线性扫描，大大提高了效率。


### Q600  包裹黑色像素点的最小矩形 Smallest Rectangle Enclosing Black Pixels

这道题要求我们找到包含所有黑色像素点的矩形区域的最小面积。给定矩阵中的黑色像素点（即 `1`）是相连的，并且是唯一的一块区域。我们需要计算该区域的最小边界矩形的面积。

### 原理和流程

我们可以通过 **深度优先搜索 (DFS)** 或 **广度优先搜索 (BFS)** 来找到所有的黑色像素点，确定其矩形边界。此外，也可以利用 **二分搜索** 来快速找到黑色像素的边界（上下左右）。

在这题中，我们选择 **二分搜索**，因为矩阵已经确定只有一个黑色区域，并且所有黑色像素相连。使用二分搜索可以更高效地确定上下左右的边界：

1. **定义边界**：我们需要找到包含所有黑色像素点的矩形的上边界、下边界、左边界和右边界。
2. **二分查找确定边界**：
    - 从上到下找出第一个包含黑色像素 `1` 的行，确定上边界。
    - 从下到上找出第一个包含黑色像素 `1` 的行，确定下边界。
    - 从左到右找出第一个包含黑色像素 `1` 的列，确定左边界。
    - 从右到左找出第一个包含黑色像素 `1` 的列，确定右边界。
3. **计算面积**：用找到的边界来计算矩形的面积。

### 示例代码
```
from typing import List

def minArea(image: List[List[str]], x: int, y: int) -> int:
    # 矩阵行数和列数
    m, n = len(image), len(image[0])
    
    # 使用二分查找确定上边界
    top = binarySearch(image, 0, x, 0, n, True, True)
    # 使用二分查找确定下边界
    bottom = binarySearch(image, x + 1, m, 0, n, False, True)
    # 使用二分查找确定左边界
    left = binarySearch(image, 0, y, top, bottom, True, False)
    # 使用二分查找确定右边界
    right = binarySearch(image, y + 1, n, top, bottom, False, False)
    
    # 计算矩形面积
    return (bottom - top) * (right - left)

# 二分查找函数
def binarySearch(image: List[List[str]], low: int, high: int, minR: int, maxR: int, goLower: bool, isRow: bool) -> int:
    while low < high:
        mid = (low + high) // 2
        hasBlackPixel = any(image[mid][j] == '1' for j in range(minR, maxR)) if isRow else any(image[i][mid] == '1' for i in range(minR, maxR))
        
        if hasBlackPixel == goLower:
            high = mid
        else:
            low = mid + 1
    return low

```

### 详细解释

假设 `image` 是大小为 `m x n` 的矩阵，`(x, y)` 是给定的一个黑色像素点的坐标。

1. **边界搜索**：
    
    - **上边界**：使用二分查找在 `0` 到 `x` 行范围中找到第一个包含黑色像素的行。
    - **下边界**：使用二分查找在 `x + 1` 到 `m` 行范围中找到第一个没有黑色像素的行。
    - **左边界**：使用二分查找在 `0` 到 `y` 列范围中找到第一个包含黑色像素的列。
    - **右边界**：使用二分查找在 `y + 1` 到 `n` 列范围中找到第一个没有黑色像素的列。
2. **二分查找过程**：
    
    - 在 `binarySearch` 函数中，检查当前中间行（或列）是否包含黑色像素。
    - 如果包含，则根据 `goLower` 的值决定是移动 `high` 还是 `low`，以缩小搜索范围。
    - 最终，返回符合条件的边界位置。
3. **计算面积**：
    
    - `top` 和 `bottom` 表示行边界；`left` 和 `right` 表示列边界。
    - 最小矩形的面积为 `(bottom - top) * (right - left)`。

### 时间和空间复杂度分析

- **时间复杂度**：O(log⁡m+log⁡n)O(\log m + \log n)O(logm+logn)
    - 因为每次二分查找的复杂度为 O(log⁡m)O(\log m)O(logm)（行）和 O(log⁡n)O(\log n)O(logn)（列），因此总体复杂度为 O(log⁡m+log⁡n)O(\log m + \log n)O(logm+logn)。
- **空间复杂度**：O(1)O(1)O(1)
    - 我们只使用了常数空间存储边界信息和其他变量。

### 示例
```
# 示例用例
image = [
    "1110",
    "1100",
    "0000",
    "0000"
]
x, y = 0, 1
print(minArea(image, x, y))  # 输出: 6

```
在上面的示例中，黑色像素点的边界矩形为 `(top=0, bottom=2, left=0, right=3)`，因此面积为 `6`。通过使用二分查找，我们有效地缩小了搜索范围，避免了全矩阵扫描。

### Q437  书籍复印 Copy Books

這個 `copyBooks` 問題的目的是要分配 `k` 個抄寫員來抄寫 `pages` 陣列中表示的書頁數，讓每個抄寫員所需的最大抄寫時間最小化。問題的關鍵在於，必須確保每位抄寫員負擔的總頁數（即總抄寫時間）不超過一定的限制 `time_limit`，並且希望找到一個最小的 `time_limit`，使得抄寫員數量剛好為 `k` 或更少。

### 問題解決思路

1. **使用二分搜索找最小的最大抄寫時間 `time_limit`**：由於我們要求抄寫員的最小抄寫時間上限，我們可以設置一個範圍，並在該範圍內使用二分法逐步逼近最小值。
    
    - `start` 是分配給抄寫員的最小抄寫時間，等於 `max(pages)`，因為每個抄寫員至少要負擔一整本書的頁數。
    - `end` 是分配給抄寫員的最大抄寫時間，等於 `sum(pages)`，即所有書的頁數總和（表示只有一個抄寫員負責全部書的情況）。
2. **二分搜索過程**：
    
    - 每次取 `mid = (start + end) // 2` 作為抄寫時間上限 `time_limit`，然後檢查在這個時間限制下，需要多少個抄寫員可以完成所有書的抄寫。
    - 根據 `get_least_people(pages, mid)` 計算的抄寫員數量進行二分：
        - 若所需抄寫員數量小於或等於 `k`，表示可以減少抄寫時間上限，因此將 `end` 更新為 `mid`。
        - 若所需抄寫員數量大於 `k`，則表示時間限制過低，無法在 `k` 個抄寫員內完成，因此將 `start` 更新為 `mid`。
3. **最終檢查**：
    
    - 當 `start` 與 `end` 相鄰時，若 `start` 的分配時間限制下可以在 `k` 個抄寫員內完成，則返回 `start`；否則返回 `end`。

### `get_least_people` 函數的作用

`get_least_people` 函數的目的是計算在給定的時間限制 `time_limit` 下，完成 `pages` 所需的最少抄寫員數量。方法如下：

1. **初始化**：使用 `count` 來記錄抄寫員的數量，`time_cost` 表示當前抄寫員已抄寫的總頁數。
2. **遍歷每本書的頁數 `page`**：
    - 若當前累計的抄寫時間 `time_cost + page` 超過 `time_limit`，則分配一位新的抄寫員，並將 `time_cost` 重置為 `0`。
    - 將該書的頁數加入到新的 `time_cost` 中。
3. **返回抄寫員數量**：因為最後一次計算 `time_cost` 時可能還有剩餘的抄寫員負擔頁數，因此返回 `count + 1` 表示最少的抄寫員數量。

### 具體代碼

```
class Solution:
    def copyBooks(self, pages, k):
        if not pages:
            return 0
            
        start, end = max(pages), sum(pages)
        while start + 1 < end:
            mid = (start + end) // 2
            if self.get_least_people(pages, mid) <= k:
                end = mid
            else:
                start = mid
                
        if self.get_least_people(pages, start) <= k:
            return start
            
        return end
        
    def get_least_people(self, pages, time_limit):
        count = 0
        time_cost = 0 
        for page in pages:
            if time_cost + page > time_limit:
                count += 1
                time_cost = 0
            time_cost += page
            
        return count + 1

```
### 時間和空間複雜度分析

- **時間複雜度**：O(nlog⁡S)O(n \log S)O(nlogS)，其中 `n` 是 `pages` 的長度，`S` 是書本頁數的總和。二分搜索的時間複雜度為 O(log⁡S)O(\log S)O(logS)，`get_least_people` 函數需要遍歷一次 `pages`（即 O(n)O(n)O(n)），因此總時間複雜度為 O(nlog⁡S)O(n \log S)O(nlogS)。
    
- **空間複雜度**：O(1)O(1)O(1)，只使用了常數空間來儲存指標和輔助變數。


### Q366 請提供leetcode python code查找斐波纳契数列中第 N 个数的數個解法

在这道题中，我们需要找到斐波那契数列的第 N 个数。斐波那契数列定义如下：

- `F(0) = 0, F(1) = 1`
- `F(n) = F(n-1) + F(n-2)` 对于 `n >= 2`

接下来，我们将提供几种不同的方法来解决这个问题，从简单到复杂，包括递推法、记忆化搜索（递归 + 备忘录）、矩阵快速幂。

### 方法 1: 递推法 (Iterative Approach)

递推法是最简单、直观的方法。我们从 `F(0)` 和 `F(1)` 开始，通过迭代计算每一个后续的斐波那契数，直到计算到 `F(N)`。

#### 实现代码
```
def fib(N):
    if N <= 1:
        return N
    a, b = 0, 1
    for _ in range(2, N + 1):
        a, b = b, a + b
    return b

```
#### 详细解释

- 初始化两个变量 `a = 0` 和 `b = 1`，分别对应 `F(0)` 和 `F(1)`。
- 从 `F(2)` 开始，通过循环迭代计算每一个斐波那契数，将 `a` 和 `b` 更新为当前的斐波那契值和下一个斐波那契值。
- 最后，`b` 将存储 `F(N)` 的值。

#### 时间和空间复杂度分析

- **时间复杂度**：O(N)，因为我们需要从 `F(2)` 迭代计算到 `F(N)`。
- **空间复杂度**：O(1)，只使用了常数个额外变量。
#### 时间复杂度分析

在这个方法中，我们使用一个 `for` 循环从 `2` 迭代到 `N`，每次更新两个变量 `a` 和 `b` 的值。因此：

- **循环次数**：循环执行 `N - 1` 次，从 `2` 到 `N`，计算每个数的时间是常数时间 O(1)。
- **总时间复杂度**：由于我们在每次迭代中仅执行常数操作，而总循环次数为 N−1，所以时间复杂度为 O(N)。

**示例**： 假设 `N = 5`，则算法的计算过程如下：

- 迭代 1：计算 `F(2) = F(1) + F(0)`，循环一次
- 迭代 2：计算 `F(3) = F(2) + F(1)`，循环一次
- 迭代 3：计算 `F(4) = F(3) + F(2)`，循环一次
- 迭代 4：计算 `F(5) = F(4) + F(3)`，循环一次

一共执行了 4 次循环，约等于 NNN 次。

#### 空间复杂度分析

在此方法中，我们只用了两个变量 `a` 和 `b` 来存储计算结果，此外没有其他额外的数据结构。因此空间复杂度为 O(1)。

---

### 方法 2: 记忆化搜索 (Memoization / Recursion with Memoization)

记忆化搜索利用递归的方式，但通过备忘录避免了重复计算。

#### 实现代码
```
def fib(N, memo={0: 0, 1: 1}):
    if N in memo:
        return memo[N]
    memo[N] = fib(N - 1, memo) + fib(N - 2, memo)
    return memo[N]

```
#### 详细解释

- 我们使用一个 `memo` 字典来存储已经计算过的斐波那契数，初始化 `F(0) = 0` 和 `F(1) = 1`。
- 如果 `N` 在 `memo` 中，直接返回 `memo[N]`，避免重复计算。
- 如果 `N` 不在 `memo` 中，递归计算 `fib(N - 1)` 和 `fib(N - 2)`，并将结果存储在 `memo` 中。

#### 时间和空间复杂度分析

- **时间复杂度**：O(N)O(N)O(N)，因为每个值 `F(n)` 只会计算一次并存储在 `memo` 中。
- **空间复杂度**：O(N)O(N)O(N)，递归栈的深度为 `N`，以及 `memo` 字典的大小为 `N`。

---

### 方法 3: 矩阵快速幂 (Matrix Exponentiation)

矩阵快速幂是计算斐波那契数的高效方法。斐波那契数列的递推关系可以通过矩阵表示：

$\begin{bmatrix} F(n+1) \\ F(n) \end{bmatrix} = \begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix} \times \begin{bmatrix} F(n) \\ F(n-1) \end{bmatrix}$

即，通过矩阵幂次可以推导出任意 `F(n)`。若将该矩阵记作 `M = [[1, 1], [1, 0]]`，则：

$\begin{bmatrix} F(n) \\ F(n-1) \end{bmatrix} = M^{(n-1)} \times \begin{bmatrix} F(1) \\ F(0) \end{bmatrix}$

#### 实现代码
```
def fib(N):
    if N <= 1:
        return N

    def matrix_multiply(A, B):
        return [
            [A[0][0] * B[0][0] + A[0][1] * B[1][0], A[0][0] * B[0][1] + A[0][1] * B[1][1]],
            [A[1][0] * B[0][0] + A[1][1] * B[1][0], A[1][0] * B[0][1] + A[1][1] * B[1][1]]
        ]

    def matrix_pow(matrix, n):
        result = [[1, 0], [0, 1]]
        while n > 0:
            if n % 2 == 1:
                result = matrix_multiply(result, matrix)
            matrix = matrix_multiply(matrix, matrix)
            n //= 2
        return result

    M = [[1, 1], [1, 0]]
    result = matrix_pow(M, N - 1)
    return result[0][0]

```

#### 详细解释

1. **矩阵乘法**：定义 `matrix_multiply(A, B)` 来进行 2x2 矩阵相乘。
2. **矩阵快速幂**：定义 `matrix_pow(matrix, n)`，用快速幂算法计算 `matrix^n`。在计算过程中，将矩阵 `matrix` 的幂次减半，并不断相乘以构成 `result`。
3. **计算结果**：当 `N > 1` 时，`fib(N)` 的值等于 `M^(N-1)[0][0]`，即矩阵幂次的第一行第一列。

#### 时间和空间复杂度分析

- **时间复杂度**：O(log⁡N)O(\log N)O(logN)，通过快速幂算法实现矩阵幂运算。
- **空间复杂度**：O(1)O(1)O(1)，仅使用了常数的额外空间。

---

### 总结

| 方法    | 时间复杂度    | 空间复杂度 |
| ----- | -------- | ----- |
| 递推法   | O(N)     | O(1)  |
| 记忆化搜索 | O(N)     | O(N)  |
| 矩阵快速幂 | O(log⁡N) | O(1)  |

- **递推法**适用于计算范围较小的情况，简单且高效。
- **记忆化搜索**适合递归风格，并减少重复计算。
- **矩阵快速幂**最优于大范围的 `N` 值。
