Lintcode 144
给出一个含有正整数和负整数的数组，重新排列成一个正负数交错的数组。

```python
"""
输入 : [-1, -2, -3, 4, 5, 6]
输出 : [-1, 5, -2, 4, -3, 6]
解释 : 或者任何满足条件的答案 
```


```python
class Solution:
    """
    @param: a: an integer array.
    @return: nothing
    """
    def rerange(self, a):
        pos, neg = 0, 0
        for num in a:
            if num > 0:
                pos += 1
            else:
                neg += 1
        
        self.partition(a, pos > neg)
        self.interleave(a, pos == neg)
            
    def partition(self, a, start_positive):
        flag = 1 if start_positive else -1
        left, right = 0, len(a) - 1
        while left <= right:
            while left <= right and a[left] * flag > 0:
                left += 1
            while left <= right and a[right] * flag < 0:
                right -= 1
            if left <= right:
                a[left], a[right] = a[right], a[left]
                left += 1
                right -= 1
    
    def interleave(self, a, has_same_length):
        left, right = 1, len(a) - 1
        if has_same_length:
            right = len(a) - 2
            
        while left < right:
            a[left], a[right] = a[right], a[left]
            left, right = left + 2, right - 2
```
pass


## **解題目標**

給定一個數組 `a`，其中包含 **正數與負數**，我們希望按照以下規則重新排列：

- **交錯排列**：正數與負數 **交替出現**。
- **數量差異處理**：
    - 若**正數數量大於負數**，則從 **正數開始排列**。
    - 若**負數數量較多**，則從 **負數開始排列**。
    - 若兩者相等，則正負交替。

---

## **解法核心**

這道題主要運用 **三步驟** 來解決：

1. **統計**：計算正數與負數的數量。
2. **分區 (Partitioning)**：
    - 重新排列數組，使得**所有正數放在一側，負數放在另一側**。
    - 選擇應該放在 **左邊** 的數字 (`start_positive` 判斷)。
3. **交錯交換 (Interleave)**：
    - 讓正負數 **間隔排列**。

---

## **解法步驟**

### **步驟 1: 統計數量**

我們先遍歷 `a`，統計 **正數與負數的個數**：

- `pos`：計算正數的個數
- `neg`：計算負數的個數

這樣可以決定：

- **正數較多**：需要以正數開頭
- **負數較多**：需要以負數開頭
- **數量相等**：正常交錯

---

### **步驟 2: 分區 (Partition)**

這一步類似於 **快排的 partition**：

- 目標是 **讓所有正數放在一邊，負數放在另一邊**。
- `flag = 1` 代表應該**從正數開始**，`flag = -1` 代表應該**從負數開始**。
- **雙指針 (Two Pointers)** 方法：
    - `left` 從左向右找錯放的數
    - `right` 從右向左找錯放的數
    - 交換 `a[left]` 和 `a[right]`，直到 `left` 超過 `right`。

---

### **步驟 3: 交錯交換 (Interleave)**

- 目標：讓正數和負數交錯排列
- **雙指針**：
    - **從索引 `1` 開始，間隔 2 位進行交換**（因為偶數索引是正數，奇數索引是負數）。
    - 若數量相等，則最後一個索引需要調整 (`right = len(a) - 2`)。

---

## **變數定義**

|變數名稱|作用|
|---|---|
|`pos`|記錄數組中正數的個數|
|`neg`|記錄數組中負數的個數|
|`flag`|`1` 代表從正數開始, `-1` 代表從負數開始|
|`left`|由左向右移動，尋找錯放的數|
|`right`|由右向左移動，尋找錯放的數|
|`start_positive`|是否應該從正數開始 (`pos > neg`)|
|`has_same_length`|是否正數和負數數量相等 (`pos == neg`)|

---

## **具體範例**

### **範例 1**

text

複製編輯

`輸入: a = [1, -2, -3, 4]`

#### **Step 1: 統計**

text

複製編輯

`正數數量: pos = 2 負數數量: neg = 2 pos == neg, 需要正負交錯`

#### **Step 2: 分區 (Partition)**

text

複製編輯

`初始陣列: [1, -2, -3, 4] 已經分區: [1, 4, -2, -3]`

#### **Step 3: 交錯交換 (Interleave)**

text

複製編輯

`交錯後結果: [1, -2, 4, -3]`

**輸出**: `[1, -2, 4, -3]`

---

### **範例 2**

text

複製編輯

`輸入: a = [1, -2, -3, 4, 5]`

#### **Step 1: 統計**

text

複製編輯

`正數數量: pos = 3 負數數量: neg = 2 pos > neg, 需要從正數開始`

#### **Step 2: 分區 (Partition)**

text

複製編輯

`初始陣列: [1, -2, -3, 4, 5] 已經分區: [1, 4, 5, -2, -3]`

#### **Step 3: 交錯交換 (Interleave)**

text

複製編輯

`交錯後結果: [1, -2, 4, -3, 5]`

**輸出**: `[1, -2, 4, -3, 5]`

---

## **時間與空間複雜度分析**

### **時間複雜度**

|操作|複雜度|說明|
|---|---|---|
|統計數量|`O(n)`|遍歷一次計算 `pos` 和 `neg`|
|分區|`O(n)`|`left` 和 `right` 互相靠近，每個元素最多交換一次|
|交錯交換|`O(n)`|`left` 和 `right` 互相交換，每個元素最多交換一次|
|**總計**|`O(n)`|線性時間複雜度|

### **空間複雜度**

- 只使用幾個額外變數 (`pos`, `neg`, `left`, `right`)，**空間複雜度為 `O(1)`**。

---

## **其他解法 (不寫 Code)**

1. **暴力 `O(n log n)` 排序**
    
    - 先按照數值大小排序，然後手動重新排列。
    - **缺點**：時間複雜度較高 (`O(n log n)`)，且不符合原地排序的要求。
2. **雙佇列 (Two Queues) `O(n)`**
    
    - 使用 **兩個隊列**：
        - **一個存正數**
        - **一個存負數**
    - 重新從兩個隊列交錯取數填充 `a`。
    - **缺點**：需要 `O(n)` 額外空間。
3. **一次遍歷 `O(n)`**
    
    - 遍歷數組，將正數放入偶數索引，負數放入奇數索引。
    - 可能需要**兩次遍歷來確保位置正確**。

---

## **總結**

|**解法**|**時間複雜度**|**空間複雜度**|**適用場景**|**優缺點**|
|---|---|---|---|---|
|**雙指針 (Two Pointers) `O(n)`**|`O(n)`|`O(1)`|**原地排序，最優解**|✅ 高效，原地操作|
|**暴力排序 `O(n log n)`**|`O(n log n)`|`O(1)`|當 `a` 很小時|❌ 需要額外處理交錯|
|**雙佇列 `O(n)`**|`O(n)`|`O(n)`|有額外空間時可行|❌ 空間消耗較大|
|**一次遍歷 `O(n)`**|`O(n)`|`O(1)`|若輸入格式較規律|⚠ 可能需要額外處理索引|

---

## **最佳解法**

✅ **雙指針 (Two Pointers) 為最優解**：

- 時間複雜度 **O(n)**
- 空間複雜度 **O(1)**
- **原地操作，不需要額外空間** 🚀