
### LintCode 598: 僵尸矩阵

---

### 问题描述

在一个 `n x m` 的二维矩阵 `grid` 中，每个位置可以是以下之一：

- `1`：表示僵尸。
- `0`：表示人类。
- `2`：表示墙。

僵尸每经过一天可以感染其上下左右相邻的人类。问最少需要多少天能让所有人类都被感染，如果无法感染所有人类，返回 `-1`。

---

### 解法：BFS（广度优先搜索）

#### 思路

1. **初始化**：
    
    - 遍历整个网格，将所有僵尸位置加入队列 `q`，作为 BFS 的起始点。
    - 初始化一个变量 `days`，表示感染所需的天数。
2. **BFS 遍历**：
    
    - 每轮 BFS 表示经过一天：
        - 对队列中的每个僵尸位置，尝试感染其上下左右四个方向的人类。
        - 如果相邻位置是人类，标记为僵尸，并将新感染的位置加入队列。
    - 每轮结束后，将新感染的僵尸作为下一轮 BFS 的起始点。
3. **终止条件**：
    
    - 如果队列为空，表示所有可以感染的位置已被处理。
    - 遍历网格，如果仍然存在未被感染的人类，返回 `-1`。
4. **结果**：
    
    - 返回 `days - 1`，因为最后一天没有新增感染，需减去一天。

---
Example:
例1:
```
输入:
[[0,1,2,0,0],
 [1,0,0,2,1],
 [0,1,0,0,0]]
输出:
2
```
例2:
```
输入:
[[0,0,0],
 [0,0,0],
 [0,0,1]]
输出:
4
```


### 代码实现

```python
from collections import deque
DIR = [(1, 0), (-1, 0), (0, 1), (0, -1)]

class Solution:
    def zombie(self, grid):
7        # write your code here
8        if len(grid) == 0 or len(grid[0]) == 0:
9            return 0
10        m, n = len(grid), len(grid[0])
11        queue = collections.deque()
12        for i in range(m):
13            for j in range(n):
14                if grid[i][j] == 1:
15                    queue.append((i, j))
16        day = 0
17        while queue:
18            size = len(queue)
19            day += 1
20            for k in range(size):
21                (i, j) = queue.popleft()
22                DIR = [(1, 0), (-1, 0), (0, 1), (0, -1)]
23                for (di, dj) in DIR:
24                    next_i, next_j = i + di, j + dj
25                    if next_i < 0 or next_i >= m or next_j < 0 or next_j >= n:
26                        continue
27                    if grid[next_i][next_j] == 1 or grid[next_i][next_j] == 2:
28                        continue
29                    grid[next_i][next_j] = 1
30                    queue.append((next_i, next_j))
31        for i in range(m):
32            for j in range(n):
33                if grid[i][j] == 0:
34                    return -1
35        return day - 1
```
pass
解釋:
step1  先遍歷一次grid找出所有僵尸(=1), 都加入deque  
step2  while queue迴圈之後day+1, 然後for loop將deque列表裡每一個元素做一次BFS(pop一次, 然後加入前後左右進去deque).   
step3  持續上面的步驟並增加day直到deque為空  
step4  最後再遍歷一次grid, 如果還有人類(0)則return -1  

### 示例输入输出

#### 输入

`grid = [     [0, 1, 2],     [0, 0, 0],     [2, 0, 1] ]`

#### 输出

`2`

#### 运行过程

1. **初始化**：
    
    - 初始队列 `q = [(0, 1), (2, 2)]`（僵尸的位置）。
    - 天数 `days = 0`。
2. **第一天 BFS**：
    
    - 当前僵尸位置：`(0, 1)` 和 `(2, 2)`。
    - 感染新位置：
        - `(1, 1)`，`(0, 0)`。
    - 更新队列：`q = [(1, 1), (0, 0)]`。
    - 天数 `days = 1`。
3. **第二天 BFS**：
    
    - 当前僵尸位置：`(1, 1)` 和 `(0, 0)`。
    - 感染新位置：
        - `(1, 0)`，`(1, 2)`。
    - 更新队列：`q = [(1, 0), (1, 2)]`。
    - 天数 `days = 2`。
4. **检查剩余人类**：
    
    - 网格中没有未感染的人类，返回 `days - 1 = 2`。

---

### 时间和空间复杂度分析

#### 时间复杂度

1. **初始化队列**：
    
    - 遍历整个网格，复杂度为 `O(n * m)`。
2. **BFS 遍历**：
    
    - 每个位置最多访问一次，每次尝试 4 个方向。
    - 总复杂度为 `O(n * m)`。

总时间复杂度为 **`O(n * m)`**。

#### 空间复杂度

1. **队列**：
    - 队列中存储所有待处理的僵尸位置，最多为网格大小，复杂度为 `O(n * m)`。

总空间复杂度为 **`O(n * m)`**。

---

### 其他解法简述

#### 1. 多源 BFS

- 初始化时，将所有僵尸位置同时作为 BFS 的起始点。
- 在每轮 BFS 中处理多个起始点，效果与当前解法相同。

#### 2. 模拟感染过程

- 按天数模拟感染过程，每天尝试更新所有僵尸位置的邻居。
- 时间复杂度更高，不推荐。

---

### 总结

- **BFS 解法**是解决该问题的最优选择，直观高效。
- 时间复杂度和空间复杂度均为 **`O(n * m)`**。
- **多源 BFS** 是等价替代方案，适用于多起点问题。