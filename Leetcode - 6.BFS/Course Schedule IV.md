
### LintCode 815: 课程表 IV

---

### 问题描述

给定 `n` 门课程（编号从 `0` 到 `n-1`）和一些先修课程的要求 `p`，每个 `p[i] = [a, b]` 表示要学习课程 `b`，必须先完成课程 `a`。返回总共可以有多少种拓扑排序的方式满足先修课程的要求。

---

### 解法：动态规划 + 位运算

#### 思路

1. **拓扑排序的定义**：
    
    - 拓扑排序是一种线性序列，满足对每条先修关系 `(a, b)`，`a` 必须排在 `b` 之前。
    - 我们需要统计满足拓扑排序的所有可能序列的数量。
2. **使用动态规划**：
    
    - 使用位运算状态压缩，每种状态用一个整数表示哪些课程已经完成。
    - 状态转移：尝试将未完成的课程加入当前状态，判断是否满足其先修课程要求。
3. **步骤**：
    
    - **状态表示**：
        - 用一个长度为 `2^n` 的数组 `dp[i]` 表示当前状态为 `i` 时的拓扑排序数量。
        - `i` 是一个整数，用二进制表示课程完成情况（`1` 表示完成，`0` 表示未完成）。
    - **状态初始化**：
        - 初始状态为 `dp[0] = 1`，表示未完成任何课程时有一种拓扑排序（空序列）。
    - **状态转移**：
        - 遍历所有可能状态 `i` 和所有课程 `j`：
            - 如果课程 `j` 的所有先修课程都已经完成，且课程 `j` 未被选择，则可以将 `j` 加入当前状态 `i`。
            - 转移公式：
                
                python
                
                複製程式碼
                
                `dp[i | (1 << j)] += dp[i]`
                
    - **结果**：
        - `dp[(1 << n) - 1]` 表示所有课程都完成时的拓扑排序数量。

---

**样例1**
```plain
输入:
n = 2
prerequisites = [[1,0]]
输出: 1
说明:
你必须按照0->1的顺序上课。
```
**样例2**
```plain
输入:
n = 2
prerequisites = []
Output: 2
输出:
你可以按0->1或1->0的顺序上课。
```


### 代码实现
```python
class Solution:
    def topologicalSortNumber(self, n, p):
        # 初始化课程的先修关系
        son = [0] * n
        for x, y in p:
            # 将课程 x 设置为课程 y 的先修课程
            son[y] |= 1 << x
        
        # 状态压缩的总范围
        lim = 1 << n
        dp = [0] * lim
        dp[0] = 1  # 初始状态：没有课程完成

        # 遍历所有状态
        for i in range(lim):
            for j in range(n):
                # 检查课程 j 是否可以加入当前状态 i
                if (i & son[j]) == son[j] and (i & (1 << j)) == 0:
                    dp[i | (1 << j)] += dp[i]
        
        # 返回完成所有课程的状态数量
        return dp[lim - 1]

```
pass

---

### 示例输入输出

#### 输入

`n = 3 p = [[0, 1], [1, 2]]`

#### 运行过程

1. **初始化先修关系**：
    
    - 课程 1 的先修课程为 `0`，用二进制表示为 `0001`。
    - 课程 2 的先修课程为 `1`，用二进制表示为 `0010`。
    - `son = [0, 1, 2]`。
2. **状态转移表**：
    
    - 状态 `dp[i]` 表示完成课程状态为 `i` 时的拓扑排序数量。
3. **状态转移**：
    
    - 初始状态 `dp[0] = 1`。
    - 遍历所有状态：
        - 状态 `i = 0`：
            - 可选课程 `0`，更新 `dp[1] = dp[0] + 1 = 1`。
        - 状态 `i = 1`：
            - 可选课程 `1`，更新 `dp[3] = dp[1] + 1 = 1`。
        - 状态 `i = 3`：
            - 可选课程 `2`，更新 `dp[7] = dp[3] + 1 = 1`。
4. **结果**：
    
    - 最终状态 `dp[7] = 1`，表示有一种拓扑排序。

#### 输出

`1`

---

### 时间和空间复杂度分析

#### 时间复杂度

1. **初始化先修关系**：
    
    - 遍历所有先修关系，复杂度为 `O(E)`，其中 `E` 是边数。
2. **状态转移**：
    
    - 遍历所有状态，复杂度为 `O(2^n)`。
    - 对每个状态，遍历所有课程，复杂度为 `O(n)`。

总时间复杂度为 **`O(n * 2^n)`**。

#### 空间复杂度

1. **动态规划数组**：
    
    - 存储所有状态的结果，空间复杂度为 `O(2^n)`。
2. **课程先修关系**：
    
    - 存储每门课程的先修关系，空间复杂度为 `O(n)`。

总空间复杂度为 **`O(2^n)`**。

---

### 其他解法简述

#### 1. DFS（深度优先搜索）

- 使用递归构造所有可能的拓扑排序。
- 每次递归选择入度为 0 的节点，继续递归处理剩余图。
- 时间复杂度较高，适合小规模图。

#### 2. BFS（广度优先搜索）

- 基于 Kahn 算法，动态维护入度为 0 的节点队列。
- 构造所有拓扑排序，复杂度类似 DFS。

---

### 总结

- 本解法通过动态规划结合状态压缩高效计算拓扑排序数量，适合中小规模问题。
- 时间复杂度为 **`O(n * 2^n)`**，空间复杂度为 **`O(2^n)`**，在课程数量较多时可能存在性能瓶颈。
- **DFS 和 BFS** 提供了生成拓扑排序的具体方案，但在大规模问题上效率较低。