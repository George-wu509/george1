
LintCode 611「骑士的最短路线」问题中，我们需要找到骑士（国际象棋中的马）从起点到目标点的最短移动步数。若目标点不可达，则返回 `-1`。

以下是该问题的中文详细解法以及具体示例。

---

### 问题理解

在棋盘上（二维网格），骑士的移动方式为“日”字形：

- 可以向上下左右两格，再向垂直方向一格。
- 或者向上下左右一格，再向垂直方向两格。

给定一个起点和一个终点，求骑士从起点移动到终点的最少步数。

输入包括：

1. 棋盘的大小 `(n, m)`。
2. 起点坐标 `(x, y)`。
3. 终点坐标 `(tx, ty)`。

---

### 解法步骤

由于骑士的移动方式是固定的，并且要求最短路径，因此 **广度优先搜索（BFS）** 是最佳选择。

#### 1. 初始化

- 使用队列 `queue` 存储每一步的坐标 `(i, j)` 和步数 `step`。
- 创建一个二维数组 `visited` 来记录每个坐标是否已经访问过。

#### 2. 定义方向

骑士有 8 种移动方式：

`directions = [     (-2, -1), (-2, 1), (2, -1), (2, 1),     (-1, -2), (-1, 2), (1, -2), (1, 2) ]`

#### 3. 执行 BFS

- 从起点开始，将其加入队列，设步数为 0。
- 每次从队列中取出一个点，尝试 8 个方向的移动：
    - 如果移动后的坐标是目标点，则返回当前步数 +1。
    - 如果移动后的坐标在棋盘范围内且未访问过，则标记为已访问并加入队列。
- 如果队列为空仍未到达目标点，返回 `-1`。

---
Example:
样例
**例1:**
```
输入:
[[0,0,0],
 [0,0,0],
 [0,0,0]]
source = [2, 0] destination = [2, 2] 
输出: 2
解释:
[2,0]->[0,1]->[2,2]
```
**例2:**
```
输入:
[[0,1,0],
 [0,0,1],
 [0,0,0]]
source = [2, 0] destination = [2, 2] 
输出:-1
```



### 代码实现

```python
from collections import deque

DIRECTIONS = [
    (-2, -1), (-2, 1), (-1, 2), (1, 2),
    (2, 1), (2, -1), (1, -2), (-1, -2),
]

class Solution:
    def shortest_path(self, grid, source, destination):
        queue = deque([(source.x, source.y)])
        distance = {(source.x, source.y): 0}

        while queue:
            x, y = queue.popleft()
            if (x, y) == (destination.x, destination.y):
                return distance[(x, y)]
            for dx, dy in DIRECTIONS:
                next_x, next_y = x + dx, y + dy
                if (next_x, next_y) in distance:
                    continue
                if not self.is_valid(next_x, next_y, grid):
                    continue
                distance[(next_x, next_y)] = distance[(x, y)] + 1
                queue.append((next_x, next_y))
        return -1
        
    def is_valid(self, x, y, grid):
        n, m = len(grid), len(grid[0])

        if x < 0 or x >= n or y < 0 or y >= m:
            return False
            
        return not grid[x][y]

```
pass


### 示例输入输出

#### 示例 1

输入：

`n, m = 8, 8 x, y = 0, 0 tx, ty = 7, 7`

#### 解题过程：

1. **初始化**：
    
    - 起点为 `(0, 0)`，目标点为 `(7, 7)`。
    - `queue = deque([(0, 0, 0)])`。
    - `visited` 为一个 8x8 的全 `False` 矩阵，`visited[0][0] = True`。
2. **第 1 步**：
    
    - 当前点 `(0, 0)`，步数为 `0`。
    - 尝试 8 个方向：
        - `(0, 0) + (-2, -1)`：超出范围，跳过。
        - `(0, 0) + (-2, 1)`：超出范围，跳过。
        - `(0, 0) + (2, -1)`：超出范围，跳过。
        - `(0, 0) + (2, 1)`：有效点 `(2, 1)`，标记为已访问并加入队列。
        - 其他类似操作。
    - 更新队列：`queue = deque([(2, 1, 1), (1, 2, 1)])`。
3. **第 2 步**：
    
    - 当前点 `(2, 1)`，步数为 `1`。
    - 尝试 8 个方向：
        - `(2, 1) + (-2, -1)`：超出范围，跳过。
        - `(2, 1) + (1, 2)`：有效点 `(3, 3)`，标记为已访问并加入队列。
        - 其他类似操作。
    - 更新队列：`queue = deque([(1, 2, 1), (3, 3, 2), ...])`。
4. 持续扩展直到找到 `(7, 7)` 为止。
    

#### 输出：

最终返回最短步数为：

`6`

#### 示例 2

输入：

`n, m = 3, 3 x, y = 0, 0 tx, ty = 2, 2`

#### 解题过程：

1. **初始化**：
    
    - 起点为 `(0, 0)`，目标点为 `(2, 2)`。
    - `queue = deque([(0, 0, 0)])`。
    - `visited` 为一个 3x3 的全 `False` 矩阵，`visited[0][0] = True`。
2. **第 1 步**：
    
    - 当前点 `(0, 0)`，步数为 `0`。
    - 尝试 8 个方向：
        - `(0, 0) + (1, 2)`：有效点 `(1, 2)`，标记为已访问并加入队列。
        - `(0, 0) + (2, 1)`：有效点 `(2, 1)`，标记为已访问并加入队列。
    - 更新队列：`queue = deque([(1, 2, 1), (2, 1, 1)])`。
3. **第 2 步**：
    
    - 从 `(1, 2)` 或 `(2, 1)` 都可以到达目标点 `(2, 2)`。
    - 返回步数 `1 + 1 = 2`。

#### 输出：

`2`

---

### 时间复杂度和空间复杂度

1. **时间复杂度**：
    
    - 每个点最多访问一次，棋盘大小为 `n * m`，每次扩展最多 8 个方向。
    - 因此时间复杂度为 `O(n * m)`。
2. **空间复杂度**：
    
    - 队列最多存储所有棋盘点，复杂度为 `O(n * m)`。

---

### 总结

通过 BFS 的逐层扩展和最短路径的特性，能够高效解决骑士的最短路线问题。希望这份详细说明对你有所帮助！