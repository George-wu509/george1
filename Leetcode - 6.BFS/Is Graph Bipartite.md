
### LintCode 1031: Is Graph Bipartite

---

### 问题描述

给定一个无向图 `graph`，图由一个二维数组表示，其中 `graph[i]` 是一个节点 `i` 的邻居列表。判断该图是否为二分图。

**定义：二分图**

- 如果一个图可以将所有节点划分为两个集合，使得集合内的节点之间没有边，则该图是一个二分图。

---

### 解法：BFS（广度优先搜索）

#### 思路

1. **染色法**：
    
    - 使用颜色表示两个集合，例如 `0` 和 `1`。
    - 为一个节点染色后，所有与其相邻的节点必须染成另一种颜色。
    - 如果在染色过程中出现冲突（某个节点的颜色与期望颜色不同），则该图不是二分图。
2. **使用 BFS 遍历图**：
    
    - 选择任意一个未染色的节点作为起点，对整个连通分量进行染色。
    - 每次从队列中取出一个节点，检查它的邻居：
        - 如果邻居未染色，则染成另一种颜色并加入队列。
        - 如果邻居已染色但颜色相同，则说明不是二分图。
    - 遍历所有连通分量，确保图中每个节点都被处理。

Example:
```python
输入: [[1,3], [0,2], [1,3], [0,2]] # graph={1:[1,3],2:[0,2],3:[1,3],4:[0,2]}
输出: true
解释: 
  图看上去长这样：
  0----1
  |    |
  |    |
  3----2
  所以我们可以把图分成以下两部分，并且各自内部没有连线: {0, 2} and {1, 3}.
```

```python
输入: [[1,2,3], [0,2], [0,1,3], [0,2]]
输出: false
解释: 
  图看上去长这样：
  0----1
  | \  |
  |  \ |
  3----2
  我们没有办法将这个点集分为两个独立的子集。（即各自内部没有连线）
```


---

### 代码实现

```python
from collections import deque

class Solution:
    def isBipartite(self, graph):
        n = len(graph)
        colors = [-1] * n  # -1 表示未染色

        # 遍历每个连通分量
        for i in range(n):
            if colors[i] == -1:  # 如果当前节点未染色
                if not self.bfs_check(graph, i, colors):
                    return False
        return True

    def bfs_check(self, graph, start, colors):
        queue = deque([start])
        colors[start] = 0  # 为起点染色为 0

        while queue:
            node = queue.popleft()
            for neighbor in graph[node]:
                if colors[neighbor] == -1:  # 邻居未染色
                    colors[neighbor] = 1 - colors[node]  # 染成相反的颜色
                    queue.append(neighbor)
                elif colors[neighbor] == colors[node]:  # 邻居已染色且颜色相同
                    return False
        return True

```
pass

---

### 示例输入输出

#### 示例 1

**输入**：

`graph = [[1, 3], [0, 2], [1, 3], [0, 2]]`

**运行过程**：

1. **初始化**：
    
    - `colors = [-1, -1, -1, -1]`
2. **处理节点 0**：
    
    - 染色：`colors[0] = 0`
    - 队列：`queue = deque([0])`
3. **遍历节点 0 的邻居**：
    
    - 邻居 `1`：染色为 `1`，加入队列。
    - 邻居 `3`：染色为 `1`，加入队列。
    - 更新：`colors = [0, 1, -1, 1]`
4. **处理节点 1**：
    
    - 邻居 `0`：已染色为 `0`，无冲突。
    - 邻居 `2`：染色为 `0`，加入队列。
    - 更新：`colors = [0, 1, 0, 1]`
5. **处理节点 3**：
    
    - 邻居 `0`：已染色为 `0`，无冲突。
    - 邻居 `2`：已染色为 `0`，无冲突。
6. **处理节点 2**：
    
    - 邻居 `1`：已染色为 `1`，无冲突。
    - 邻居 `3`：已染色为 `1`，无冲突。

**输出**：

`True`

#### 示例 2

**输入**：

`graph = [[1, 2, 3], [0, 2], [0, 1, 3], [0, 2]]`

**运行过程**：

1. **处理节点 0**：
    
    - 邻居 `1`：染色为 `1`。
    - 邻居 `2`：染色为 `1`。
    - 邻居 `3`：染色为 `1`。
2. **处理节点 1**：
    
    - 邻居 `0`：已染色为 `0`，无冲突。
    - 邻居 `2`：已染色为 `1`，**冲突**。

**输出**：

`False`

---

### 时间和空间复杂度分析

#### 时间复杂度

1. **BFS 遍历**：
    - 每条边和每个节点最多访问一次。
    - 总复杂度为 `O(V + E)`，其中 `V` 是节点数，`E` 是边数。

#### 空间复杂度

1. **存储颜色**：
    - 需要 `O(V)` 的空间。
2. **队列**：
    - 最多存储 `V` 个节点，复杂度为 `O(V)`。

总空间复杂度为 **`O(V)`**。

---

### 其他解法简述

#### 1. DFS（深度优先搜索）

- 使用递归实现染色法，与 BFS 类似。
- 在递归过程中检查邻居是否有冲突。
- 时间复杂度和空间复杂度与 BFS 相同，但可能受到递归深度限制。

#### 2. 并查集（Union-Find）

- 使用并查集判断图中是否存在奇数环：
    - 如果某个节点与其邻居在同一个集合中，则不是二分图。
- 实现复杂度略高，但适合需要动态连通性问题的场景。

---

### 总结

- **BFS 和 DFS** 是判断二分图的常用方法，代码简单且直观。
- 时间复杂度和空间复杂度均为 **`O(V + E)`**，适合中小规模图。
- **并查集** 提供了一种更灵活的实现方式，但实现复杂度略高。

