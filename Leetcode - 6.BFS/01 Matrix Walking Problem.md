
### LintCode 1446: 01矩阵走路问题

---

### 问题描述

在一个 `n x m` 的二维网格 `grid` 中，每个格子可以是：

- `0`：表示可以通行的路。
- `1`：表示障碍物，可以被破坏一次。

从左上角 `(0, 0)` 出发，到右下角 `(n-1, m-1)`，问最少需要多少步才能到达。如果无法到达，返回 `-1`。

---

### 解法：BFS（广度优先搜索）

#### 思路

1. **多状态 BFS**：
    
    - 每个位置 `(x, y)` 有两种状态：
        1. 没有破坏过障碍物。
        2. 破坏过一次障碍物。
    - 使用三维数组 `visit[x][y][i]` 记录是否访问过位置 `(x, y)`，其中 `i` 表示状态：
        - `i = 0` 表示未破坏过障碍物。
        - `i = 1` 表示已经破坏过障碍物。
2. **状态初始化**：
    
    - 如果起点 `(0, 0)` 是 `0`，从未破坏障碍物状态开始搜索。
    - 如果起点 `(0, 0)` 是 `1`，直接从破坏一次障碍物状态开始搜索。
3. **BFS 搜索过程**：
    
    - 每轮 BFS 尝试向上下左右四个方向移动。
    - 如果移动到空地 `0`，直接加入队列。
    - 如果移动到障碍物 `1`，且当前状态未破坏过障碍物（`i = 0`），则破坏障碍物后继续搜索。
    - 标记访问过的状态，避免重复搜索。
4. **终止条件**：
    
    - 如果到达终点 `(n-1, m-1)`，返回当前步数。
    - 如果队列为空，且未到达终点，返回 `-1`。

---
Example:
**样例 1：**
```
输入：a = [[0,1,0,0,0],[0,0,0,1,0],[1,1,0,1,0],[1,1,1,1,0]] 
输出：7
解释：将（0,1）处的 `1` 变成 `0`，最短路径如下：
 (0,0)->(0,1)->(0,2)->(0,3)->(0,4)->(1,4)->(2,4)->(3,4) 其他长度为 `7` 的方案还有很多，这里不一一列举。
```
**样例 2：**
```
输入：a = [[0,1,1],[1,1,0],[1,1,0]]
输出：-1 
解释：不管把哪个 `1` 变成 `0`，都没有可行的路径。
```


### 代码实现

```python
class Node:
    def __init__(self, x=0, y=0, broken=0, steps=0):
        self.x = x  # 当前所在行
        self.y = y  # 当前所在列
        self.broken = broken  # 是否已经破坏过障碍物
        self.steps = steps  # 当前走的步数

class Solution:
    """
    @param grid: The grid
    @return: Return the steps you need at least
    """
    def get_best_road(self, grid):
        # 定义四个方向
        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
        n, m = len(grid), len(grid[0])

        # 访问状态：visit[x][y][i] 表示是否访问过 (x, y) 状态 i
        visit = [[[0 for _ in range(2)] for _ in range(m)] for _ in range(n)]

        # 初始化队列
        queue = []
        if grid[0][0] == 0:
            start_node = Node(0, 0, 0, 0)
            visit[0][0][0] = 1
        else:
            start_node = Node(0, 0, 1, 0)
        visit[0][0][1] = 1
        queue.append(start_node)

        # BFS 遍历
        while queue:
            current = queue.pop(0)

            # 如果到达终点，返回步数
            if current.x == n - 1 and current.y == m - 1:
                return current.steps

            # 尝试移动到四个方向
            for dx, dy in directions:
                new_x, new_y = current.x + dx, current.y + dy

                # 检查是否越界
                if 0 <= new_x < n and 0 <= new_y < m:
                    if grid[new_x][new_y] == 0 and visit[new_x][new_y][current.broken] == 0:
                        # 如果是空地，直接移动
                        visit[new_x][new_y][current.broken] = 1
                        queue.append(Node(new_x, new_y, current.broken, current.steps + 1))
                    elif grid[new_x][new_y] == 1 and current.broken == 0 and visit[new_x][new_y][1] == 0:
                        # 如果是障碍物且未破坏过
                        visit[new_x][new_y][1] = 1
                        queue.append(Node(new_x, new_y, 1, current.steps + 1))

        # 无法到达终点
        return -1

```
pass

### 示例输入输出

#### 输入

`grid = [[0, 1, 0, 0, 0],         [0, 0, 0, 1, 0],         [1, 1, 0, 1, 0],         [1, 1, 1, 1, 0]]`

#### 输出

`7`

#### 运行过程

1. **初始化**：
    
    - 起点 `(0, 0)` 是 `0`，状态为未破坏障碍物。
    - 队列：`queue = [Node(0, 0, 0, 0)]`。
2. **第一轮 BFS**：
    
    - 当前节点：`(0, 0)`。
    - 尝试移动：
        - 移动到 `(0, 1)`，破坏障碍物。
        - 移动到 `(1, 0)`，直接移动。
    - 更新队列：`queue = [Node(0, 1, 1, 1), Node(1, 0, 0, 1)]`。
3. **第二轮 BFS**：
    
    - 当前节点：`(0, 1)` 和 `(1, 0)`。
    - 更新队列：`queue = [Node(1, 0, 0, 2), Node(0, 2, 1, 2)]`。
4. **多轮 BFS**：
    
    - 持续重复上述过程，直到到达终点 `(3, 4)`。

---

### 时间和空间复杂度分析

#### 时间复杂度

1. **节点访问**：
    
    - 每个位置有两种状态，最多访问 `2 * n * m` 次。
2. **BFS 遍历**：
    
    - 每次尝试 4 个方向，总复杂度为 `O(4 * 2 * n * m)`。

总时间复杂度为 **`O(n * m)`**。

#### 空间复杂度

1. **队列**：
    
    - 队列最多存储 `O(2 * n * m)` 个节点。
2. **访问数组**：
    
    - 记录每个位置的访问状态，复杂度为 `O(2 * n * m)`。

总空间复杂度为 **`O(n * m)`**。

---

### 其他解法简述

#### 1. 动态规划（DP）

- 使用 `dp[x][y][k]` 表示到达 `(x, y)` 状态 `k` 的最小步数。
- 转移方程：
    
    python
    
    複製程式碼
    
    `dp[x][y][k] = min(dp[prev_x][prev_y][k] + 1, dp[prev_x][prev_y][k - 1] + 1)`
    
- 时间复杂度较高，适用于明确步数的场景。

#### 2. 双向 BFS

- 同时从起点 `(0, 0)` 和终点 `(n-1, m-1)` 开始搜索。
- 两侧搜索相遇时停止，减少搜索空间。

---

### 总结

- **BFS 解法**直观高效，适合求解最短路径问题。
- 时间复杂度为 **`O(n * m)`**，空间复杂度为 **`O(n * m)`**。
- **双向 BFS** 和 **动态规划** 是等价替代方案，适用于更复杂的场景。