
### LintCode 1446: 01矩阵走路问题

---

### 问题描述
给定一个大小为 `n*m` 的 `01` 矩阵 `grid` ，`1` 是墙，`0` 是路，你现在可以把 `grid` 中的一个 `1` 变成 `0`，请问从左上角走到右下角是否有路可走？如果有路可走，最少要走多少步？

Example:
**样例 1：**
```python
输入：a = [
[0,1,0,0,0],
[0,0,0,1,0],
[1,1,0,1,0],
[1,1,1,1,0]] 
输出：7
解释：将（0,1）处的 `1` 变成 `0`，最短路径如下：
 (0,0)->(0,1)->(0,2)->(0,3)->(0,4)->(1,4)->(2,4)->(3,4) 其他长度为 `7` 的方案还有很多，这里不一一列举。
```
**样例 2：**
```python
输入：a = [[0,1,1],[1,1,0],[1,1,0]]
输出：-1 
解释：不管把哪个 `1` 变成 `0`，都没有可行的路径。
```

---

### 解法：BFS（广度优先搜索）

#### 思路

1. **多状态 BFS**：
    
    - 每个位置 `(x, y)` 有两种状态：
        1. 没有破坏过障碍物。
        2. 破坏过一次障碍物。
    - 使用三维数组 `visit[x][y][i]` 记录是否访问过位置 `(x, y)`，其中 `i` 表示状态：
        - `i = 0` 表示未破坏过障碍物。
        - `i = 1` 表示已经破坏过障碍物。
        [ [ [0, 0], [0, 0], [0, 0], [0, 0], [0, 0] ], 
		[ [0, 0], [0, 0], [0, 0], [0, 0], [0, 0] ], 
		[ [0, 0], [0, 0], [0, 0], [0, 0], [0, 0] ], 
		[ [0, 0], [0, 0], [0, 0], [0, 0], [0, 0] ]]
2. **状态初始化**：
    
    - 如果起点 `(0, 0)` 是 `0`，从未破坏障碍物状态开始搜索。
    - 如果起点 `(0, 0)` 是 `1`，直接从破坏一次障碍物状态开始搜索。
3. **BFS 搜索过程**：
    
    - 每轮 BFS 尝试向上下左右四个方向移动。
    - 如果移动到空地 `0`，直接加入队列。
    - 如果移动到障碍物 `1`，且当前状态未破坏过障碍物（`i = 0`），则破坏障碍物后继续搜索。
    - 标记访问过的状态，避免重复搜索。
4. **终止条件**：
    
    - 如果到达终点 `(n-1, m-1)`，返回当前步数。
    - 如果队列为空，且未到达终点，返回 `-1`。

### 代码实现

```python
from collections import deque
class node:
	def __init__(self, a = 0, b = 0, i = 0, s = 0):
		self.x = a
		self.y = b
		self.i = i
		self.step = s
class Solution:
    """
    @param grid: The gird
    @return: Return the steps you need at least
    """
    def get_best_road(self, grid):
        # Write your code here
        direction = [[1,0],[-1,0],[0,1],[0,-1]]
        n = len(grid)
        m = len(grid[0])
        # print(n,m)
        visit = [[[0 for i in range(2)] for i in range(m)] for i in range(n)]
        p = []
        if (grid[0][0] == 0):
        	new = node(0,0,0,0)
        	visit[0][0][0] = 1;
        else:
        	new=node(0,0,1,0)
        p.append(new)
        flag = -1;
        visit[0][0][1] = 1;
        cnt = 0
        while cnt < len(p):
        	a = p[cnt]
        	cnt += 1
        	# print(a.x,a.y,a.i,a.step)
        	if a.x == n-1 and a.y == m-1:
        		flag = a.step
        		break
        	else:
        		for i in range(0,4):
        			new_x = a.x + direction[i][0]
        			new_y = a.y + direction[i][1]
        			if  new_x <= n-1 and new_x >= 0 and new_y <= m-1 and new_y >= 0:
        				if grid[new_x][new_y] == 0 and visit[new_x][new_y][a.i] == 0:
        					visit[new_x][new_y][a.i]=1
        					visit[new_x][new_y][1]=1
        					p.append(node(new_x , new_y , a.i , a.step+1 ))
        				if grid[new_x][new_y] == 1 and a.i == 0 and visit[new_x][new_y][1] == 0:
        					visit[new_x][new_y][1] = 1
        					p.append(node(new_x , new_y,1 , a.step+1))
        return flag


```
pass
解釋:
step1  建立visit matrix, 除了x, y還有是否破壞障礙物.  
step2  從初始位置開始用BFS, 如果有遇到障礙則在這一輪BFS移除障礙, 而且其他障礙不能再移除. 
step3  比較這些BFS的選最短路徑

### 示例输入输出

#### 输入

`grid = [[0, 1, 0, 0, 0],         [0, 0, 0, 1, 0],         [1, 1, 0, 1, 0],         [1, 1, 1, 1, 0]]`

#### 输出

`7`

#### 运行过程

1. **初始化**：
    
    - 起点 `(0, 0)` 是 `0`，状态为未破坏障碍物。
    - 队列：`queue = [Node(0, 0, 0, 0)]`。
2. **第一轮 BFS**：
    
    - 当前节点：`(0, 0)`。
    - 尝试移动：
        - 移动到 `(0, 1)`，破坏障碍物。
        - 移动到 `(1, 0)`，直接移动。
    - 更新队列：`queue = [Node(0, 1, 1, 1), Node(1, 0, 0, 1)]`。
3. **第二轮 BFS**：
    
    - 当前节点：`(0, 1)` 和 `(1, 0)`。
    - 更新队列：`queue = [Node(1, 0, 0, 2), Node(0, 2, 1, 2)]`。
4. **多轮 BFS**：
    
    - 持续重复上述过程，直到到达终点 `(3, 4)`。

---

### 时间和空间复杂度分析

#### 时间复杂度

1. **节点访问**：
    
    - 每个位置有两种状态，最多访问 `2 * n * m` 次。
2. **BFS 遍历**：
    
    - 每次尝试 4 个方向，总复杂度为 `O(4 * 2 * n * m)`。

总时间复杂度为 **`O(n * m)`**。

#### 空间复杂度

1. **队列**：
    
    - 队列最多存储 `O(2 * n * m)` 个节点。
2. **访问数组**：
    
    - 记录每个位置的访问状态，复杂度为 `O(2 * n * m)`。

总空间复杂度为 **`O(n * m)`**。

---

### 其他解法简述

#### 1. 动态规划（DP）

- 使用 `dp[x][y][k]` 表示到达 `(x, y)` 状态 `k` 的最小步数。
- 转移方程：
    
    python
    
    複製程式碼
    
    `dp[x][y][k] = min(dp[prev_x][prev_y][k] + 1, dp[prev_x][prev_y][k - 1] + 1)`
    
- 时间复杂度较高，适用于明确步数的场景。

#### 2. 双向 BFS

- 同时从起点 `(0, 0)` 和终点 `(n-1, m-1)` 开始搜索。
- 两侧搜索相遇时停止，减少搜索空间。

---

### 总结

- **BFS 解法**直观高效，适合求解最短路径问题。
- 时间复杂度为 **`O(n * m)`**，空间复杂度为 **`O(n * m)`**。
- **双向 BFS** 和 **动态规划** 是等价替代方案，适用于更复杂的场景。