
![[Pasted image 20240914170344.png]]
![[Pasted image 20240914170438.png]]

6 BDS中同一個節點不需要重複進入隊列, 如果圖中有環則可能節點重複進入隊列

7 最短路徑問題 簡單圖用BFS, 複雜圖(一般面試不考)用SPFA, Floyd, Dijkstra, bellman-ford

8 最長路徑問題: 圖可以分層 - DP動態規劃, 圖不能分層 - DFS深度優先搜索
分层的意思是：路径有一定方向性，不能绕圈, 第i层的点只能走到第i+1层不能回到底 i-1 层

9 能用BFS 的一定不要用DFS（除非面试官特别要求）

10 矩阵坐标变换数组

11 二叉樹BFS vs 圖的BFS有甚麼區別

12 使用宽度优先搜索找所有方案 - 一个方案=一条路径, 求所有方案=求所有路径

BFS 善于解决求连通块问题, 把路径看做点，把路径的变化关系看做点的连接关系

这样就把找所有路径问题变成了找所有连通点的问题

![[Pasted image 20240914170532.png]]
双向宽度优先搜索代码模板
![[Pasted image 20240914170553.png]]

这样就把找所有路径问题变成了找所有连通点的问题

## **Lintcode模板 - 宽度优先搜索 BFS**

## **使用条件**

- 拓扑排序（100%）
- 出现连通块的关键词（100%）
- 分层遍历（100%）
- 简单图最短路径（100%）
- 给定一个变换规则，从初始状态变到终止状态最少几步（100%）

## **复杂度**

- 时间复杂度：_O_(_n_+_m_)
    - `n` 是点数，`m` 是边数
- 空间复杂度：_O_(_n_)

**代码模板**
![[Pasted image 20240914170627.png]]
拓扑排序
![[Pasted image 20240914170711.png]]


以下是整理的 BFS（广度优先搜索）相关题目表格，包含题目编号、题目名称、题目简述、样例和解法五个栏位：

| **题目编号**            | **题目名称 (英文/中文)**                                   | **题目简述 (中文)**                                                                           | **样例**                                                                                                                                                                                                                    | **解法**                                                                                                          |
| ------------------- | -------------------------------------------------- | --------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------- |
| 137<br>**<br>(m)    | 克隆图 [[Clone Graph]]                                | 给定一个无向图，返回其深度克隆后的新图。                                                                    | 输入:<br>{1,2,4#2,1<br>,4#4,1,2}<br>输出: <br>{1,2,4#2,1<br>,4#4,1,2}                                                                                                                                                         | 使用哈希表记录已访问节点，结合 BFS 克隆节点及其邻接点。                                                                                  |
| 120<br>**<br>(h)    | 单词接龙 [[Word Ladder]]                               | 给出两个单词（start和end）和一个字典，找出从start到end的最短转换序列，输出最短序列的长度。                                   | 输入：<br>start = "hit"<br>end = "cog"<br>dict =<br>["hot","dot","dog"<br>,"lot","log"]<br>输出： 5                                                                                                                             | 使用 BFS 搜索单词转换序列，记录每个单词的访问深度。                                                                                    |
| 121<br>*<br>(h)<br> | 单词接龙 II [[Word Ladder II]]                         | 给出两个单词（start和end）和一个字典，找出所有从start到end的最短转换序列。                                           | 输入：<br>start = "a"<br>end = "c"<br>dict =<br>["a","b","c"]<br>输出：<br>[["a","c"]]                                                                                                                                          | 使用 BFS 搜索所有可能路径，结合回溯生成所有最短转换序列。                                                                                 |
| 433<br>**<br>(e)    | 岛屿的个数 [[Number of Islands]]                        | 给定一个二维网格，计算其中岛屿的数量。                                                                     | 输入：<br>[<br>  [1,1,0,0,0],<br>  [0,1,0,0,1],<br>  [0,0,0,1,1],<br>  [0,0,0,0,0],<br>  [0,0,0,0,1]<br>]<br>输出：<br>3                                                                                                        | 使用 BFS 遍历每个岛屿，将相邻陆地标记为已访问。                                                                                      |
| 1080<br><br>(e)     | [[Max Area of Island]] (最大岛屿面积)                    | 找到二维网格中最大的岛屿面积。                                                                         | 输入: grid = <br>[ [0, 0, 1, 0],  <br>[1, 1, 1, 0],[0, 1, 0, 0] ]<br>输出:  5                                                                                                                                                 | 使用 DFS 或 BFS 遍历岛屿，累计连通的 1 的数量。                                                                                  |
| 611<br>**<br>(m)    | 骑士的最短路线 [[Knight Shortest Path]]                   | 在棋盘上从起点移动到终点，返回骑士所需的最小步数。                                                               | 输入:<br>[ [0,0,0],<br> [0,0,0],<br> [0,0,0] ]<br>source = [2, 0] <br>destination <br>= [2, 2] <br>输出: 2                                                                                                                    | 使用 BFS 搜索骑士的合法移动路径，记录访问状态以避免重复。                                                                                 |
| 630<br>*<br>(m)     | 骑士的最短路径 II [[Knight Shortest Path II]]             | 限制骑士只能向前或向后跳，找到最小步数。                                                                    | 输入:[<br>[0,0,0,0],<br>[0,0,0,0],<br>[0,0,0,0] ]<br>输出:<br>3                                                                                                                                                               | 使用 BFS 搜索路径，并限制合法移动方向。                                                                                          |
| 127<br><br>(m)      | [[Topological Sorting]] (拓扑排序)                     | 给定有向无环图，返回其拓扑排序结果。                                                                      | 输入:  graph =<br> [ [1,2], [], <br>[3], [] ]  <br>输出: [0, 1, 2, 3]                                                                                                                                                         | 使用入度表和队列，逐步移除入度为 0 的节点完成排序。                                                                                     |
| 615<br>**<br>(m)    | 课程表 [[Course Schedule\|Course Schedule]]           | 现在你总共有 n 门课需要选，记为 0 到 n - 1.<br>一些课程在修之前需要先修另外的一些课程，判断是否可能完成所有课程？                       | 输入: n = 4,<br> prerequisites = <br>[ [1,0],[2,0],[3,1],[3,2] ] <br>输出: True                                                                                                                                               | 使用 BFS 实现**拓扑排序**，检查图是否存在环路。                                                                                    |
| 616<br>*<br>(m)     | 课程表 II [[Course Schedule II]]                      | 判断是否可以完成所有课程，并返回完成课程的顺序。你只要返回一种就可以了。                                                    | 输入: n = 4,<br> prerequisites = <br>[ [1,0],[2,0],[3,1],[3,2] ] <br>输出: [0,1,2,3] or <br>[0,2,1,3]                                                                                                                         | 使用 BFS 实现**拓扑排序**，记录节点的入度，依次完成课程。                                                                               |
| 815<br><br>(h)      | 课程表 IV [[Course Schedule IV]]                      | 判断是否可以完成所有课程，并返回完成课程的顺序。返回你可以得到所有课程的不同方法的数量。                                            | 输入:  <br>numCourses = 4, prerequisites = [[0,1],[1,2],[2,3]], queries = [[0,3],[3,0]]  <br>输出: [true,false]                                                                                                               | 使用 BFS 遍历课程依赖图，记录每门课程的可达性。**拓扑排序**                                                                              |
| 892<br>**<br>(h)    | 外星人字典 [[Alien Dictionary]]                         | 给定一个外星语言单词列表，返回其字母的字典顺序。                                                                | 输入：<br>["wrt","wrf","er"<br>,"ett","rftt"]<br>输出："wertf"                                                                                                                                                                  | 构建有向图表示字母顺序，使用 BFS 获取**拓扑排序**结果。                                                                                |
| 605<br>*<br>(m)     | 序列重构 [[Sequence Reconstruction]]                   | 判断是否可以通过给定子序列唯一确定原序列。                                                                   | 输入:<br>org = [1,2,3], <br>seqs = [ [1,2],[1,3] ]<br>输出: false                                                                                                                                                             | 使用 BFS 结合**拓扑排序**检查唯一序列。                                                                                        |
| 573<br>*<br>(h)     | 邮局的建立 II [[Build Post Office II]]                  | 给出一个二维的网格，每一格可以代表墙 2 ，房子 1，以及空 0 (用数字0,1,2来表示)，在网格中找到一个位置去建立邮局，使得所有的房子到邮局的距离和是最小的       | 输入：[<br>[1,0,2,0,1],<br>[0,0,0,0,0],<br>[0,0,1,0,0] ]<br>输出：4                                                                                                                                                             | 使用 BFS 计算每个空地到所有房屋的距离和，返回最小值。                                                                                   |
| 803<br><br>(h)<br>  | [[Shortest Distance from All Buildings]]建筑物之间的最短距离 | 给定一个二维网格，找出一个空单元格，使得从该单元格到所有建筑物的距离之和最小，并返回该距离。                                          | 输入: `[[1,0,2,0,1],[0,0,0,0,0],[0,0,1,0,0]]` 输出: `7`                                                                                                                                                                       | 使用广度优先搜索（BFS）从每个建筑物开始，计算到其他空单元格的距离，将这些距离累加到一个矩阵中，同时记录每个空单元格可访问的建筑物数量。最后遍历矩阵，找到可访问所有建筑物且总距离最小的单元格。               |
| 1428<br>**<br>(m)   | 钥匙和房间 [[Keys and Rooms]]                           | 判断是否可以使用钥匙打开所有房间。                                                                       | 输入:  <br>rooms = [ [1],[2],[3],[] ]  <br>输出: true                                                                                                                                                                         | 使用 BFS 搜索所有可以访问的房间，检查是否访问了所有房间。                                                                                 |
| 794<br>*<br>(h)     | 滑动拼图 II [[Sliding Puzzle II]]                      | 解决一个 2x3 拼图，返回最少的移动次数。                                                                  | 输入:  <br>board = [[1,2,3],[4,0,5]]  <br>输出: 1                                                                                                                                                                             | 使用 BFS 记录每一步的状态和路径，寻找最短解法。                                                                                      |
| 950<br>*<br>(h)     | 滑动拼图 III [[Sliding Puzzle III]]                    | 给定一个 3x3 拼图，找出完成拼图的最少步骤，或判断是否无解。<br>finish =[<br>[ 1,2,3 ],<br>[ 4,5,6 ],<br>[ 7,8,0 ]] | 输入：<br>matrix =[<br>[1,2,3],<br>[4,0,6],<br>[7,5,8] ]<br>输出：<br>YES<br>                                                                                                                                                   | 使用 BFS 搜索状态空间，结合哈希表记录已访问状态避免重复。                                                                                 |
| 789<br>*<br>(h)     | 迷宫 III [[The Maze III]]                            | 给定一个迷宫和小球的起点，找到小球到达终点的最短路径。                                                             | 输入:  <br>maze = [ [0,0,1],[0,0,0],[1,0,0] ], start = [0,0], destination = [2,2]  <br>输出: 4                                                                                                                                | 使用 BFS 搜索所有可能路径，记录路径长度并选择最短路径。                                                                                  |
| 1828<br>*<br>(h)    | 湖面逃跑 [[Lake Escape]]                               | 给定一个湖泊网格，判断是否可以从起点逃到目标点，并返回最短路径。 踏进冰面，他会朝同一方向滑行，直到撞上另一个雪堆。 冰面上也有他必须避开的危险的洞。             | 输入:<br>size=7<br>[ [0,0,0,0,0,0,0],<br>[0,0,-1,0,0,0,0],<br>[0,0,1,-1,0,-1,0],<br>[-1,0,1,0,0,0,0],<br>[0,1,1,0,0,1,0],<br>[-1,0,-1,0,-1,0,0],<br>[0,0,0,0,0,0,0] ]<br>size=7<br>start=[4,1]<br>end=[3,2]<br>输出: <br>true | 使用 BFS 遍历湖泊网格，记录每一步的状态和路径。                                                                                      |
| 1565<br><br>(m)     | 飞行棋I [[Modern Ludo I]]                             | 模拟一个飞行棋游戏，找到从起点到终点的最小步数。                                                                | 输入:  <br>n = 15, connections = [ [2,10],[7,14] ]  <br>输出: 4                                                                                                                                                               | 使用广度优先搜索 (BFS) 建模为图的最短路径问题，动态更新步数。                                                                              |
| 598<br>*<br>(m)     | 僵尸矩阵 [[Zombie in Matrix]]                          | 给定一个二维网格，找到将所有人类转化为僵尸所需的最短时间。                                                           | 输入:<br>grid = [<br>[0,1,0],<br>[1,0,0],<br>[0,0,0] ]<br>输出: 2                                                                                                                                                             | 使用 BFS 模拟传播过程，记录时间步数。**多源 BFS**                                                                                 |
| 3726<br><br>(m)     | [[Rotting Oranges]]腐烂的橘子                           | 给定一个二维网格，其中每个单元格可以是 0（空单元格）、1（新鲜橘子）或 2（腐烂橘子）。找出让所有橘子腐烂所需的最少时间。                          | 输入: [<br>[2,1,1],<br>[1,1,0],<br>[0,1,1]<br>] <br>输出: 4                                                                                                                                                                   | 使用队列存储所有初始的腐烂橘子位置，执行多源广度优先搜索（BFS）。每次从队列中取出一个腐烂橘子，标记相邻的新鲜橘子为腐烂，并将其加入队列，同时更新时间计数。若 BFS 结束后仍存在新鲜橘子，返回 -1，否则返回时间计数。 |
| 1446<br><br>(m)     | [[01 Matrix Walking Problem]] 01矩阵走路问题             | 给定一个由 0 和 1 组成的矩阵，返回一个矩阵，其中每个单元格的值是其到最近的 0 的距离。                                         | 输入: `[[0,0,0],[0,1,0],[1,1,1]]` 输出: `[[0,0,0],[0,1,0],[1,2,1]]`                                                                                                                                                           | 使用广度优先搜索（BFS），从所有值为 0 的单元格开始，将其周围的单元格加入队列，更新这些单元格的距离值并标记为已访问。每次从队列中取出一个单元格，继续更新其相邻单元格，直到队列为空。**多源 BFS**         |
| 974<br><br>(m)      | [[01 Matrix]] 01 矩阵                                | 给定一个由 0 和 1 组成的矩阵，返回一个矩阵，其中每个单元格的值是其到最近的 0 的距离。                                         | 输入: <br>[ [0,0,0],<br>[0,1,0],<br>[1,1,1] ] <br>输出: <br>[ [0,0,0],<br>[0,1,0],<br>[1,2,1] ]                                                                                                                               | 使用广度优先搜索（BFS），从所有值为 0 的单元格开始，将其周围的单元格加入队列，更新这些单元格的距离值并标记为已访问。每次从队列中取出一个单元格，继续更新其相邻单元格，直到队列为空。                   |






