
### LintCode 950: 滑动拼图 III

---

### 问题描述

给定一个 `3x3` 的滑动拼图矩阵，其中包含数字 `1` 到 `8` 和一个空格（用 `0` 表示）。判断是否可以通过若干次合法移动将矩阵变为目标状态：

複製程式碼

`目标状态： 123 456 780`

合法移动是指将 `0` 上下左右移动至相邻位置。

---

### 解法：BFS（广度优先搜索）

#### 思路

1. **问题转化**：
    
    - 将 `3x3` 矩阵转化为一个字符串表示的状态，例如矩阵 `[[1,2,3],[4,0,6],[7,5,8]]` 转化为字符串 `'123406758'`。
    - 每次移动即为字符串中两个字符的交换。
2. **状态表示与目标**：
    
    - 初始状态为输入矩阵的字符串形式。
    - 目标状态为字符串 `'123456780'`。
3. **广度优先搜索（BFS）**：
    
    - 使用队列存储当前状态，按层次展开每一步的可能移动。
    - 每次移动后检查是否达到目标状态。
    - 使用 `visited` 集合记录已访问状态，避免重复计算。
4. **终止条件**：
    
    - 如果某一步状态等于目标状态，返回 `'YES'`。
    - 如果队列为空且未找到目标状态，返回 `'NO'`。

---
Example:
**样例 1:**
```
给出 matrix =[[1,2,3],[4,0,6],[7,5,8]]
返回`"YES"`。

解释：
先把5与空格交换，然后8与空格交换即可。
```
**样例 2:**
```
给出 matrix =[[1,2,3],[4,5,6],[7,0,8]]
返回`"YES"`。

解释：
只需要将8与空格交换一下位置即可。
```

### 代码实现
```python
from collections import deque
from typing import List

class Solution:
    """
    @param matrix: The 3*3 matrix
    @return: The answer
    """
    def jigsawPuzzle(self, matrix: List[List[int]]) -> str:
        # 将矩阵转为字符串
        start = ''.join([''.join(map(str, row)) for row in matrix])
        target = '123456780'
        
        # BFS 初始化
        queue = deque([start])
        visited = set([start])
        
        # 方向数组，用于控制 0 的移动
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        
        while queue:
            current = queue.popleft()
            
            # 检查是否到达目标状态
            if current == target:
                return 'YES'
            
            # 找到 0 的位置
            zero_index = current.index('0')
            zero_row, zero_col = zero_index // 3, zero_index % 3
            
            # 尝试所有可能的移动
            for dr, dc in directions:
                new_row, new_col = zero_row + dr, zero_col + dc
                
                # 检查新位置是否有效
                if 0 <= new_row < 3 and 0 <= new_col < 3:
                    # 生成新的状态
                    new_index = new_row * 3 + new_col
                    new_state = list(current)
                    new_state[zero_index], new_state[new_index] = new_state[new_index], new_state[zero_index]
                    new_state = ''.join(new_state)
                    
                    # 如果新状态未访问过，加入队列
                    if new_state not in visited:
                        visited.add(new_state)
                        queue.append(new_state)
        
        return 'NO'

```
pass

### 示例输入输出

#### 输入

python

複製程式碼

`matrix = [[1, 2, 3], [4, 0, 6], [7, 5, 8]]`

#### 运行过程

1. **初始状态**：
    
    - `start = '123406758'`
    - `target = '123456780'`
    - `queue = deque(['123406758'])`
    - `visited = {'123406758'}`
2. **第一轮 BFS**：
    
    - 当前状态：`'123406758'`。
    - `0` 的位置：`4`（第 1 行第 1 列）。
    - 尝试移动：
        - 向右：生成 `'123460758'`。
        - 向左：生成 `'123046758'`。
        - 向下：生成 `'123456708'`。
        - 向上：生成 `'103426758'`。
    - 更新队列和访问记录：
        - `queue = deque(['123460758', '123046758', '123456708', '103426758'])`
        - `visited = {'123406758', '123460758', '123046758', '123456708', '103426758'}`。
3. **第二轮 BFS**：
    
    - 当前状态：`'123460758'`，未到达目标。
    - 依次对队列中的状态重复上述过程。
4. **终止条件**：
    
    - 某一轮生成的状态为目标 `'123456780'`。

#### 输出

python

複製程式碼

`'YES'`

---

### 时间和空间复杂度分析

#### 时间复杂度

1. **状态总数**：
    
    - 拼图的状态数为 `9! = 362,880`，但实际可达状态可能更少。
2. **每个状态的操作**：
    
    - 最多有 4 个移动方向，每次移动需要 `O(9)` 时间生成新状态。

总时间复杂度为 **`O(9 * 9!)`**。

#### 空间复杂度

1. **队列**：
    
    - 队列存储的最大状态数为所有可达状态，即 `O(9!)`。
2. **访问记录**：
    
    - 使用 `visited` 集合存储所有访问过的状态，空间复杂度为 `O(9!)`。

总空间复杂度为 **`O(9!)`**。

---

### 其他解法简述

#### 1. 双向 BFS

- 同时从初始状态和目标状态进行搜索。
- 两侧搜索相遇时即找到解法。
- 时间复杂度减半，适合状态数较大的问题。

#### 2. A* 搜索

- 使用启发式函数（如曼哈顿距离）优化搜索顺序。
- 优先搜索最有可能达到目标状态的路径。
- 实现复杂度较高，但在实际运行中更高效。

---

### 总结

- **BFS 解法**适合中小规模问题，易于实现且具有较高的正确性。
- 时间复杂度和空间复杂度均为 **`O(9!)`**，适合 3x3 拼图问题。
- **双向 BFS** 和 **A*** 提供了更高效的替代方案，适用于更复杂的拼图问题。