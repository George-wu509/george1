
### LintCode 3726: 腐烂的橘子

---

### 问题描述

在一个 `m x n` 的网格 `grid` 中，每个格子可能是以下之一：

- `0`：表示空格。
- `1`：表示新鲜橘子。
- `2`：表示腐烂的橘子。

每分钟，腐烂橘子可以将其上下左右相邻的新鲜橘子感染成为腐烂橘子。问最少需要多少分钟可以让所有新鲜橘子都腐烂，如果无法让所有新鲜橘子腐烂，返回 `-1`。

---

### 解法：BFS（广度优先搜索）

#### 思路

1. **初始化**：
    
    - 遍历整个网格，将所有腐烂橘子的位置加入队列 `q`。
    - 记录网格中所有新鲜橘子的总数 `cnt`。
2. **BFS 遍历**：
    
    - 每轮 BFS 表示经过一分钟。
    - 从队列中取出所有腐烂橘子，尝试感染其上下左右四个方向的新鲜橘子。
    - 如果某个新鲜橘子被感染，加入队列，并减少新鲜橘子的计数 `cnt`。
3. **终止条件**：
    
    - 如果队列为空，且仍然存在新鲜橘子（`cnt > 0`），返回 `-1`。
    - 否则，返回所需的分钟数。

---
Example:
样例 1：
```
输入：
grid = [
[2, 1, 1], 
[1, 0, 0], 
[0, 2, 1]
]
输出：
2
```
样例 2：
```
输入：
grid = [
[2, 1, 1], 
[1, 1, 0], 
[1, 0, 1]
]
输出：
-1
解释：
右下角的橘子不会腐烂
```
样例 3：
```
输入：
grid = [
[0, 0, 2], 
[0, 2, 0], 
[2, 0, 0]
]
输出：
0
解释：
开始时网格中的橘子已经全部腐烂
```


### 代码实现

```python
from typing import List
import collections

class Solution:
    def rotting_oranges(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        q = collections.deque()
        cnt = 0  # 新鲜橘子的计数

        # 初始化队列和新鲜橘子计数
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 2:
                    q.append((i, j))  # 腐烂橘子位置加入队列
                elif grid[i][j] == 1:
                    cnt += 1  # 统计新鲜橘子数量

        res = 0  # 记录经过的分钟数

        # BFS 遍历
        while q and cnt > 0:
            res += 1
            for _ in range(len(q)):
                i, j = q.popleft()
                # 尝试感染四个方向的新鲜橘子
                for a, b in [[0, 1], [0, -1], [1, 0], [-1, 0]]:
                    x, y = i + a, j + b
                    if 0 <= x < m and 0 <= y < n and grid[x][y] == 1:
                        cnt -= 1  # 新鲜橘子数量减少
                        grid[x][y] = 2  # 感染新鲜橘子
                        q.append((x, y))  # 新感染的橘子加入队列

        return res if cnt == 0 else -1  # 如果还有新鲜橘子，返回 -1

```
pass

### 示例输入输出

#### 示例 1

**输入**：

`grid = [     [2, 1, 1],     [1, 1, 0],     [0, 1, 1] ]`

**输出**：

`4`

**运行过程**：

1. **初始化**：
    - 腐烂橘子位置：`q = deque([(0, 0)])`。
    - 新鲜橘子计数：`cnt = 6`。
2. **第一分钟**：
    - 当前队列：`[(0, 0)]`。
    - 感染位置：`(0, 1), (1, 0)`。
    - 更新队列：`q = deque([(0, 1), (1, 0)])`。
    - 更新新鲜橘子计数：`cnt = 4`。
3. **第二分钟**：
    - 当前队列：`[(0, 1), (1, 0)]`。
    - 感染位置：`(0, 2), (1, 1)`。
    - 更新队列：`q = deque([(0, 2), (1, 1)])`。
    - 更新新鲜橘子计数：`cnt = 2`。
4. **第三分钟**：
    - 当前队列：`[(0, 2), (1, 1)]`。
    - 感染位置：`(2, 1)`。
    - 更新队列：`q = deque([(2, 1)])`。
    - 更新新鲜橘子计数：`cnt = 1`。
5. **第四分钟**：
    - 当前队列：`[(2, 1)]`。
    - 感染位置：`(2, 2)`。
    - 更新队列：`q = deque([(2, 2)])`。
    - 更新新鲜橘子计数：`cnt = 0`。
6. **结束**：
    - 返回 `res = 4`。

---

### 时间和空间复杂度分析

#### 时间复杂度

1. **初始化**：
    
    - 遍历整个网格，复杂度为 `O(m * n)`。
2. **BFS 遍历**：
    
    - 每个橘子最多被访问一次，复杂度为 `O(m * n)`。

总时间复杂度为 **`O(m * n)`**。

#### 空间复杂度

1. **队列**：
    
    - 队列中存储所有腐烂橘子，复杂度为 `O(m * n)`。
2. **网格存储**：
    
    - 输入网格直接修改，无额外空间开销。

总空间复杂度为 **`O(m * n)`**。

---

### 其他解法简述

#### 1. 多源 BFS

- 初始化时，将所有腐烂橘子位置同时作为 BFS 的起始点。
- 逻辑与当前解法一致。

#### 2. 动态模拟

- 按分钟模拟网格变化，每轮感染新鲜橘子，直到不再有新增感染。
- 时间复杂度较高，适合理解 BFS 原理但不推荐。

---

### 总结

- **BFS 解法**是解决该问题的最佳选择，时间复杂度为 **`O(m * n)`**，空间复杂度为 **`O(m * n)`**。
- **多源 BFS** 是等价替代方案，代码结构更清晰。