### 
LintCode 1428: **Keys and Rooms**

---

### 问题描述

有一个 `rooms` 数组，其中 `rooms[i]` 是一个列表，表示可以从第 `i` 个房间找到的钥匙的索引。最开始，你在房间 `0`，需要检查是否可以访问所有的房间。

**输入**：

- `rooms` 是一个二维数组。
- `rooms[i]` 是一个列表，表示从第 `i` 个房间可以找到的钥匙。

**输出**：

- 返回 `True`，如果可以访问所有房间。
- 否则，返回 `False`。

Example:
输入: rooms = [ [1],[2],[3],[] ]
输出: true
解释:  
我们从 0 号房间开始，拿到钥匙 1。
之后我们去 1 号房间，拿到钥匙 2。
然后我们去 2 号房间，拿到钥匙 3。
最后我们去了 3 号房间。
由于我们能够进入每个房间，我们返回 true。

---

### 解法：BFS（广度优先搜索）

#### 思路

1. **初始化队列和已访问集合**：
    
    - 使用队列模拟钥匙的传播过程，从房间 `0` 开始。
    - 使用集合记录已访问的房间，避免重复访问。
2. **模拟钥匙传播**：
    
    - 从队列中取出当前房间，标记为已访问。
    - 遍历当前房间中的钥匙，将对应房间加入队列（如果尚未访问）。
3. **检查结果**：
    
    - 如果最终访问的房间数量等于总房间数量，返回 `True`。
    - 否则，返回 `False`。

---

### 代码实现 
```python
from collections import deque

class Solution:
    def canVisitAllRooms(self, rooms):
        visited = set()               # 记录访问过的房间
        queue = deque([0])            # 从房间 0 开始 BFS

        while queue:
            current_room = queue.popleft()
            if current_room not in visited:
                visited.add(current_room)
                for key in rooms[current_room]:  # 遍历当前房间中的钥匙
                    if key not in visited:      # 如果房间尚未访问，加入队列
                        queue.append(key)

        return len(visited) == len(rooms)

```
pass

---

### 示例输入输出

#### 示例 1

**输入**：

python

複製程式碼

`rooms = [[1], [2], [3], []]`

**运行过程**：

1. **初始化**：
    
    - `queue = deque([0])`
    - `visited = set()`
2. **第一步**：
    
    - 当前房间：`0`
    - 房间 0 的钥匙：`[1]`
    - 标记房间 0 已访问，添加钥匙 1。
    - 更新：`queue = deque([1])`，`visited = {0}`
3. **第二步**：
    
    - 当前房间：`1`
    - 房间 1 的钥匙：`[2]`
    - 标记房间 1 已访问，添加钥匙 2。
    - 更新：`queue = deque([2])`，`visited = {0, 1}`
4. **第三步**：
    
    - 当前房间：`2`
    - 房间 2 的钥匙：`[3]`
    - 标记房间 2 已访问，添加钥匙 3。
    - 更新：`queue = deque([3])`，`visited = {0, 1, 2}`
5. **第四步**：
    
    - 当前房间：`3`
    - 房间 3 的钥匙：`[]`
    - 标记房间 3 已访问。
    - 更新：`queue = deque([])`，`visited = {0, 1, 2, 3}`
6. **结果**：
    
    - 已访问房间数量为 `4`，等于总房间数量 `4`，返回 `True`。

**输出**：

python

複製程式碼

`True`

---

#### 示例 2

**输入**：

python

複製程式碼

`rooms = [[1, 3], [3, 0, 1], [2], [0]]`

**运行过程**：

1. **初始化**：
    
    - `queue = deque([0])`
    - `visited = set()`
2. **第一步**：
    
    - 当前房间：`0`
    - 房间 0 的钥匙：`[1, 3]`
    - 标记房间 0 已访问，添加钥匙 1 和 3。
    - 更新：`queue = deque([1, 3])`，`visited = {0}`
3. **第二步**：
    
    - 当前房间：`1`
    - 房间 1 的钥匙：`[3, 0, 1]`
    - 标记房间 1 已访问。
    - 钥匙 3 和 0 已访问或在队列中，不添加。
    - 更新：`queue = deque([3])`，`visited = {0, 1}`
4. **第三步**：
    
    - 当前房间：`3`
    - 房间 3 的钥匙：`[0]`
    - 标记房间 3 已访问。
    - 钥匙 0 已访问，不添加。
    - 更新：`queue = deque([])`，`visited = {0, 1, 3}`
5. **结果**：
    
    - 未访问所有房间，`visited` 长度为 `3`，总房间数量为 `4`，返回 `False`。

**输出**：

python

複製程式碼

`False`

---

### 时间和空间复杂度分析

#### 时间复杂度

1. **初始化**：
    
    - 遍历所有房间，复杂度为 `O(N)`，其中 `N` 是房间总数。
2. **BFS 遍历**：
    
    - 每个房间至多访问一次，遍历所有钥匙，复杂度为 `O(E)`，其中 `E` 是钥匙的总数。

总时间复杂度为 `O(N + E)`。

#### 空间复杂度

1. 队列最多存储所有房间索引，复杂度为 `O(N)`。
2. `visited` 集合需要记录所有房间，复杂度为 `O(N)`。

总空间复杂度为 `O(N)`。

---

### 其他解法简述

#### 1. DFS（深度优先搜索）

使用递归模拟钥匙传播：

- 从房间 `0` 开始递归，访问所有能够访问的房间。
- 最终检查访问的房间数量是否等于总房间数量。

#### 2. 无向图的连通性判定（适用于复杂变种）

将房间和钥匙视为图的节点和边，检查是否所有节点连通。

- 可使用 BFS 或 DFS。
- 时间复杂度与 BFS 解法类似。

---

### 总结

- BFS 是解决该问题的首选方法，使用队列逐层遍历房间并模拟钥匙传播，代码直观且效率高。
- DFS 提供另一种实现方式，但在某些情况下可能更易栈溢出。
- 复杂度均为 `O(N + E)`，适用于较大规模的房间和钥匙情况。