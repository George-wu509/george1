
### LintCode 974: 01矩阵问题

---

### 问题描述

给定一个由 `0` 和 `1` 组成的矩阵 `matrix`，求出一个新的矩阵 `dist`，其中 `dist[i][j]` 表示从位置 `(i, j)` 到最近的 `0` 的距离。  
**注意**：

- 两个相邻格子之间的距离为 `1`。
Example:
例1:
```python
输入:
[[0,0,0],
 [0,0,0],
 [0,0,0],
 [0,0,0],
 [0,0,0]]
输出:
[[0,0,0],
 [0,0,0],
 [0,0,0],
 [0,0,0],
 [0,0,0]]
```
例2:
```python
输入:
[[0,1,0,1,1],
 [1,1,0,0,1],
 [0,0,0,1,0],
 [1,0,1,1,1],
 [1,0,0,0,1]]
输出:
[[0,1,0,1,2],
 [1,1,0,0,1],
 [0,0,0,1,0],
 [1,0,1,1,1],
 [1,0,0,0,1]]
```
解釋:
輸入一個matrix矩陣裡面有包括0跟1. 輸出同樣size的dist矩陣代表到最近0的距離, 如果格子本身是0那距離就是0, 如果是1的就找從這個格子到最近0格子的距離. 舉例(0,4)到(1,3)的距離是2. 

---

### 解法：BFS（多源广度优先搜索）

#### 思路

1. **多源 BFS 的概念**：
    
    - 通常 BFS 以一个源点开始搜索，而多源 BFS 是从多个源点同时开始搜索。
    - 在这个问题中，所有值为 `0` 的位置是源点。
2. **初始化**：
    
    - 创建结果矩阵 `dist`，初始化所有位置为 `0`。
    - 找到矩阵中所有值为 `0` 的位置，并将它们加入队列 `q`。
    - 使用集合 `seen` 记录已访问的位置，避免重复访问。
3. **BFS 搜索**：
    
    - 从队列中取出当前节点 `(i, j)`，尝试向上下左右四个方向扩展。
    - 如果扩展位置 `(ni, nj)` 未被访问，更新其距离为当前节点距离加 `1`，并将其加入队列。
4. **终止条件**：
    
    - 队列为空时，所有位置的最短距离均已计算完成。
5. **返回结果**：
    
    - 返回计算完成的矩阵 `dist`。




### 代码实现

```python
from typing import List
import collections

class Solution:
    def update_matrix(self, matrix: List[List[int]]) -> List[List[int]]:
        m, n = len(matrix), len(matrix[0])
        # 初始化结果矩阵
        dist = [[0] * n for _ in range(m)]
        # 找到所有值为 0 的位置
        zeroes_pos = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == 0]
        # 将所有 0 的位置作为 BFS 起始点
        q = collections.deque(zeroes_pos)
        # 记录已访问的节点
        seen = set(zeroes_pos)

        # 广度优先搜索
        while q:
            i, j = q.popleft()
            # 尝试向四个方向扩展
            for ni, nj in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:
                if 0 <= ni < m and 0 <= nj < n and (ni, nj) not in seen:
                    dist[ni][nj] = dist[i][j] + 1  # 更新距离
                    q.append((ni, nj))  # 将新位置加入队列
                    seen.add((ni, nj))  # 标记新位置为已访问
        
        return dist

```
pass
解釋:
step1  創建跟matrix一樣大小dist矩陣, 也找出所有0格子的位置 (zeroes_pos).  還有seen紀錄已訪問  
step2  從matrix的每個是0的格子開始(多源BFS), 並把zeros_pos加入 deque   
step3  開始BFS, 把0的格子pop出來, 然後檢查這個格子的上下左右, 並更新dist矩陣. 也把這格子加入deque. 

### 示例输入输出

### **示例：BFS 从 `0` 开始计算 `dist[][]`**

---
### **输入矩阵**
```
matrix = [
  [0, 1, 1],
  [1, 1, 1],
  [1, 1, 0]
]
```

---

## **🚀 BFS 逐步执行**

### **初始化**

1. **创建 `dist[][]`，所有 `1` 设为 `∞`，所有 `0` 设为 `0`**
```
dist = [
  [0, ∞, ∞],
  [∞, ∞, ∞],
  [∞, ∞, 0]
]
```

2. **BFS 队列初始化，所有 `0` 入队**

`queue = deque([(0,0), (2,2)])  # (x, y)`

---

### **🔹 BFS 第 1 轮**

#### **队列 `queue`**

`[(0,0), (2,2)]`

#### **处理 `(0,0)`**

- 扩展 `(0,1)`, 更新 `dist[0][1] = 1`
- 扩展 `(1,0)`, 更新 `dist[1][0] = 1`
- **队列状态**

`queue = deque([(2,2), (0,1), (1,0)])`

---

#### **处理 `(2,2)`**

- 扩展 `(2,1)`, 更新 `dist[2,1] = 1`
- 扩展 `(1,2)`, 更新 `dist[1,2] = 1`
- **队列状态**

`queue = deque([(0,1), (1,0), (2,1), (1,2)])`

---

#### **更新 `dist[][]`**
```
[
  [0, 1, ∞],
  [1, ∞, 1],
  [∞, 1, 0]
]
```

---

### **🔹 BFS 第 2 轮**

#### **队列 `queue`**

`[(0,1), (1,0), (2,1), (1,2)]`

#### **处理 `(0,1)`**

- 扩展 `(0,2)`, 更新 `dist[0,2] = 2`
- **队列状态**

`queue = deque([(1,0), (2,1), (1,2), (0,2)])`

---

#### **处理 `(1,0)`**

- 扩展 `(2,0)`, 更新 `dist[2,0] = 2`
- **队列状态**

`queue = deque([(2,1), (1,2), (0,2), (2,0)])`

---

#### **处理 `(2,1)`**

- 不更新 `(2,2)` 因为 `dist[2,2] = 0`
- **队列状态**

`queue = deque([(1,2), (0,2), (2,0)])`

---

#### **处理 `(1,2)`**

- 扩展 `(1,1)`, 更新 `dist[1,1] = 2`
- **队列状态**

`queue = deque([(0,2), (2,0), (1,1)])`

---

#### **更新 `dist[][]`**

```
[
  [0, 1, 2],
  [1, 2, 1],
  [2, 1, 0]
]
```

---

### **🔹 BFS 第 3 轮**

#### **队列 `queue`**

`[(0,2), (2,0), (1,1)]`

#### **处理 `(0,2)`**

- 无可扩展

---

#### **处理 `(2,0)`**

- 无可扩展

---

#### **处理 `(1,1)`**

- 无可扩展

---

#### **队列 `queue` 为空，BFS 结束**

---

## **🎯 最终 `dist[][]`**

```
[
  [0, 1, 2],
  [1, 2, 1],
  [2, 1, 0]
]
```
---

## **✅ 结论**

1. **BFS 逐层扩展，保证最短路径**

---

### 其他解法简述

#### 1. 动态规划

- 两次遍历矩阵：
    1. 从左上到右下更新距离。
    2. 从右下到左上更新距离。
- 时间复杂度为 `O(m * n)`，空间复杂度为 `O(1)`。

#### 2. 双向 BFS

- 同时从所有 `0` 和所有 `1` 的位置开始搜索，找到最短路径。
- 时间复杂度为 `O(m * n)`，实现较复杂。

---

### 总结

- **BFS 解法**是解决该问题的最优选择，适用于求解最短路径问题。
- 时间复杂度为 **`O(m * n)`**，空间复杂度为 **`O(m * n)`**。
- **动态规划** 提供了内存优化的替代方案，适用于需要原地更新的场景。



### **具体举例说明：为什么 BFS 需要从 `0` 开始，而不是从 `1` 开始？**

---

假设有如下 `3×3` 的矩阵：
```
matrix =
[
  [0, 1, 1],
  [1, 1, 1],
  [1, 1, 0]
]

答案: Distance matrix
[   
  [0, 1, 2],   
  [1, 2, 1],   
  [2, 1, 0] 
]
```

### **方法 1：从每个 `1` 开始 BFS（错误方式）**

如果我们错误地从所有 `1` 开始 BFS，每个 `1` 都要自己去找最近的 `0`，如下：

#### **第一轮 BFS（所有 `1` 开始）**

- `(0,1)` **找到** `(0,0)`，更新 `dist[0][1] = 1`
- `(0,2)` **找到** `(0,0)`，更新 `dist[0][2] = 2`
- `(1,0)` **找到** `(0,0)`，更新 `dist[1][0] = 1`
- `(1,1)` **找到** `(0,1)`，更新 `dist[1][1] = 2`
- `(1,2)` **找到** `(0,2)`，更新 `dist[1][2] = 3`
- `(2,0)` **找到** `(1,0)`，更新 `dist[2][0] = 2`
- `(2,1)` **找到** `(1,1)`，更新 `dist[2][1] = 3`
- `(2,2)` **找到** `(2,2)`（原本是 `0`）

**此时的 `dist` 结果：**

`[   [0, 1, 2],   [1, 2, 3],   [2, 3, 0] ]`

---

#### **问题：**

- **计算冗余**：每个 `1` **自己去找 `0`**，有大量重复计算。例如 `(1,1)` 需要经过 `(0,1)` 才到 `(0,0)`，但 `(0,1)` 本身就应该被更新，而不需要 `(1,1)` 重新搜索。
- **无法保证最短路径**：如 `(2,1)` 先找到 `(1,1)`，但其实应该直接去 `(2,2)`。

---

### **方法 2：从所有 `0` 开始 BFS（正确方式）**

#### **第一步：初始化所有 `0`**

我们把 **所有 `0` 作为 BFS 起点**，并初始化 `dist[][]`：

plaintext

複製編輯

`[   [0, ∞, ∞],   [∞, ∞, ∞],   [∞, ∞, 0] ]`

然后，把所有 `0` 加入 BFS 队列：

python

複製編輯

`queue = [(0,0), (2,2)]`

---

#### **第二步：BFS 逐层扩展**

**第一轮扩展 (`step = 1`)**

- 从 `(0,0)` 出发，更新：
    - `(0,1) = 1`
    - `(1,0) = 1`
- 从 `(2,2)` 出发，更新：
    - `(2,1) = 1`
    - `(1,2) = 1`

**更新后的 `dist[][]`：**

plaintext

複製編輯

`[   [0, 1, ∞],   [1, ∞, 1],   [∞, 1, 0] ]`

---

**第二轮扩展 (`step = 2`)**

- 从 `(0,1)` 出发，更新 `(0,2) = 2`
- 从 `(1,0)` 出发，更新 `(2,0) = 2`
- 从 `(1,2)` 出发，更新 `(1,1) = 2`

**更新后的 `dist[][]`：**

plaintext

複製編輯

`[   [0, 1, 2],   [1, 2, 1],   [2, 1, 0] ]`

---

**最终结果**

plaintext

複製編輯

`[   [0, 1, 2],   [1, 2, 1],   [2, 1, 0] ]`

---

### **方法 2 比方法 1 更好的原因**

|**方法**|**问题**|**计算效率**|**保证最短路径**|
|---|---|---|---|
|**从 `1` 开始 BFS（错误方法）**|每个 `1` 自己找 `0`，计算冗余|**O(nm) ~ O(n²m²)**（可能搜索多个方向）|❌ 不能保证|
|**从 `0` 开始 BFS（正确方法）**|`0` 逐层扩展 `1`，无冗余计算|**O(nm)**（每个点只访问一次）|✅ 保证最短|

---

### **结论**

✅ **应该从所有 `0` 开始 BFS**，因为：

1. **避免重复计算**，每个 `1` 只需要从最近的 `0` 更新，而不是自己去找 `0`。
2. **保证最短路径**，每个 `1` 只会在 **被 BFS 访问的第一次更新**，后续不会被更远的 `0` 影响路径长度。
3. **时间复杂度最优** `O(nm)`，每个单元格只入队出队一次，避免指数级计算。

🚀 **BFS 从 `0` 开始，是 `01 矩阵` 最优解！**