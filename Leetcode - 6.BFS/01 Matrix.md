
### LintCode 974: 01矩阵问题

---

### 问题描述

给定一个由 `0` 和 `1` 组成的矩阵 `matrix`，求出一个新的矩阵 `dist`，其中 `dist[i][j]` 表示从位置 `(i, j)` 到最近的 `0` 的距离。  
**注意**：

- 两个相邻格子之间的距离为 `1`。

---

### 解法：BFS（多源广度优先搜索）

#### 思路

1. **多源 BFS 的概念**：
    
    - 通常 BFS 以一个源点开始搜索，而多源 BFS 是从多个源点同时开始搜索。
    - 在这个问题中，所有值为 `0` 的位置是源点。
2. **初始化**：
    
    - 创建结果矩阵 `dist`，初始化所有位置为 `0`。
    - 找到矩阵中所有值为 `0` 的位置，并将它们加入队列 `q`。
    - 使用集合 `seen` 记录已访问的位置，避免重复访问。
3. **BFS 搜索**：
    
    - 从队列中取出当前节点 `(i, j)`，尝试向上下左右四个方向扩展。
    - 如果扩展位置 `(ni, nj)` 未被访问，更新其距离为当前节点距离加 `1`，并将其加入队列。
4. **终止条件**：
    
    - 队列为空时，所有位置的最短距离均已计算完成。
5. **返回结果**：
    
    - 返回计算完成的矩阵 `dist`。

---
Example:
例1:
```
输入:
[[0,0,0],
 [0,0,0],
 [0,0,0],
 [0,0,0],
 [0,0,0]]
输出:
[[0,0,0],
 [0,0,0],
 [0,0,0],
 [0,0,0],
 [0,0,0]]
```
例2:
```
输入:
[[0,1,0,1,1],
 [1,1,0,0,1],
 [0,0,0,1,0],
 [1,0,1,1,1],
 [1,0,0,0,1]]
输出:
[[0,1,0,1,2],
 [1,1,0,0,1],
 [0,0,0,1,0],
 [1,0,1,1,1],
 [1,0,0,0,1]]
```


### 代码实现

```python
from typing import List
import collections

class Solution:
    def update_matrix(self, matrix: List[List[int]]) -> List[List[int]]:
        m, n = len(matrix), len(matrix[0])
        # 初始化结果矩阵
        dist = [[0] * n for _ in range(m)]
        # 找到所有值为 0 的位置
        zeroes_pos = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == 0]
        # 将所有 0 的位置作为 BFS 起始点
        q = collections.deque(zeroes_pos)
        # 记录已访问的节点
        seen = set(zeroes_pos)

        # 广度优先搜索
        while q:
            i, j = q.popleft()
            # 尝试向四个方向扩展
            for ni, nj in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:
                if 0 <= ni < m and 0 <= nj < n and (ni, nj) not in seen:
                    dist[ni][nj] = dist[i][j] + 1  # 更新距离
                    q.append((ni, nj))  # 将新位置加入队列
                    seen.add((ni, nj))  # 标记新位置为已访问
        
        return dist

```
pass

### 示例输入输出

#### 输入

`matrix = [     [0, 0, 0],     [0, 1, 0],     [1, 1, 1] ]`

#### 输出

`[     [0, 0, 0],     [0, 1, 0],     [1, 2, 1] ]`

#### 运行过程

1. **初始化**：
    
    - `zeroes_pos = [(0, 0), (0, 1), (0, 2), (1, 0), (1, 2)]`
    - `q = deque([(0, 0), (0, 1), (0, 2), (1, 0), (1, 2)])`
    - `dist = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]`
    - `seen = {(0, 0), (0, 1), (0, 2), (1, 0), (1, 2)}`
2. **第一轮 BFS**：
    
    - 当前节点：`(0, 0)`。
        
    - 尝试扩展：
        
        - `(1, 0)` 已访问，跳过。
        - `(0, 1)` 已访问，跳过。
        - `(-1, 0)` 越界，跳过。
        - `(0, -1)` 越界，跳过。
    - 更新队列：`q = deque([(0, 1), (0, 2), (1, 0), (1, 2)])`
        
3. **多轮 BFS**：
    
    - 持续从队列中取出节点，向四个方向扩展。
    - 遇到未访问的节点，更新其距离并加入队列。
4. **最终结果**：
    
    - `dist = [[0, 0, 0], [0, 1, 0], [1, 2, 1]]`

---

### 时间和空间复杂度分析

#### 时间复杂度

1. **初始化**：
    
    - 遍历矩阵找到所有 `0` 的位置，复杂度为 `O(m * n)`。
2. **BFS 遍历**：
    
    - 每个位置最多访问一次，复杂度为 `O(m * n)`。

总时间复杂度为 **`O(m * n)`**。

#### 空间复杂度

1. **队列**：
    
    - 最多存储所有位置，空间复杂度为 `O(m * n)`。
2. **结果矩阵**：
    
    - 结果矩阵 `dist`，空间复杂度为 `O(m * n)`。

总空间复杂度为 **`O(m * n)`**。

---

### 其他解法简述

#### 1. 动态规划

- 两次遍历矩阵：
    1. 从左上到右下更新距离。
    2. 从右下到左上更新距离。
- 时间复杂度为 `O(m * n)`，空间复杂度为 `O(1)`。

#### 2. 双向 BFS

- 同时从所有 `0` 和所有 `1` 的位置开始搜索，找到最短路径。
- 时间复杂度为 `O(m * n)`，实现较复杂。

---

### 总结

- **BFS 解法**是解决该问题的最优选择，适用于求解最短路径问题。
- 时间复杂度为 **`O(m * n)`**，空间复杂度为 **`O(m * n)`**。
- **动态规划** 提供了内存优化的替代方案，适用于需要原地更新的场景。