
### LintCode 513: Perfect Squares

---

### 问题描述

给定一个正整数 `n`，找到最少的完全平方数（如 `1, 4, 9, ...`）之和等于 `n`。

---

### 解法：数学解法（基于四平方和定理）

#### 思路

根据 **拉格朗日四平方和定理**，每个正整数都可以表示为最多 4 个完全平方数的和。结合数学性质，以下规则可用于快速判断最少需要多少个完全平方数：

1. **如果 `n` 是完全平方数，则答案为 1**：
    
    - 检查 `n` 是否可以被写成一个完全平方数。
2. **如果 `n` 满足 `n = 4^k * (8m + 7)`，则答案为 4**：
    
    - 根据四平方和定理，这种形式的数字需要 4 个完全平方数。
3. **如果 `n` 可以表示为两个完全平方数的和，则答案为 2**：
    
    - 遍历所有可能的第一个完全平方数 `i^2`，检查 `n - i^2` 是否是一个完全平方数。
4. **其他情况则需要 3 个完全平方数**：
    
    - 根据拉格朗日定理，未满足上述条件的数必然可以由 3 个完全平方数表示。

Example:
样例 1:
输入: 12
输出: 3
解释: 4 + 4 + 4

样例 2:
输入: 13
输出: 2
解释: 4 + 9

---

### 代码实现
```python
class Solution:
    def numSquares(self, n):
        def is_perfect_square(x):
            """检查是否是完全平方数"""
            y = int(x ** 0.5)
            return y * y == x

        def check_answer4(x):
            """检查是否满足 4^k * (8m + 7) 形式"""
            while x % 4 == 0:
                x //= 4
            return x % 8 == 7

        # 检查是否是完全平方数
        if is_perfect_square(n):
            return 1

        # 检查是否满足需要 4 个完全平方数的条件
        if check_answer4(n):
            return 4

        # 检查是否可以用 2 个完全平方数表示
        for i in range(1, int(n ** 0.5) + 1):
            j = n - i * i
            if is_perfect_square(j):
                return 2

        # 其他情况返回 3
        return 3

```
pass

---

### 示例输入输出

#### 示例 1

**输入**：

python

複製程式碼

`n = 12`

**运行过程**：

1. 检查 `n` 是否是完全平方数：`12` 不是。
2. 检查 `n` 是否满足 `4^k * (8m + 7)`：
    - 将 `n` 简化：`12 % 4 == 0 -> n = 12 / 4 = 3`。
    - 检查 `3 % 8 == 7`：不满足。
3. 检查是否可以由两个完全平方数表示：
    - `1^2 + 3^2 = 1 + 9 = 12`，满足条件。
4. 返回答案：`3`。

**输出**：

python

複製程式碼

`3`

---

#### 示例 2

**输入**：

python

複製程式碼

`n = 13`

**运行过程**：

1. 检查 `n` 是否是完全平方数：`13` 不是。
2. 检查 `n` 是否满足 `4^k * (8m + 7)`：不满足。
3. 检查是否可以由两个完全平方数表示：
    - `2^2 + 3^2 = 4 + 9 = 13`，满足条件。
4. 返回答案：`2`。

**输出**：

python

複製程式碼

`2`

---

### 时间和空间复杂度分析

#### 时间复杂度

1. **检查完全平方数**：
    
    - `is_perfect_square` 调用一次，复杂度为 `O(√n)`。
2. **检查 `4^k * (8m + 7)`**：
    
    - 每次将 `n` 除以 `4`，最多执行 `O(log(n))` 次。
3. **检查是否可以由两个完全平方数表示**：
    
    - 遍历所有可能的 `i`，最多执行 `O(√n)` 次。
    - 每次调用 `is_perfect_square`，复杂度为 `O(√n)`。

总时间复杂度为 **`O(√n * √n) = O(n)`**。

#### 空间复杂度

- 使用常数额外空间，复杂度为 **`O(1)`**。

---

### 其他解法简述

#### 1. 动态规划

- 定义 `dp[i]` 为整数 `i` 的最少完全平方数个数。
- 状态转移方程：`dp[i] = min(dp[i - square] + 1)`，其中 `square` 是小于等于 `i` 的完全平方数。
- 时间复杂度为 `O(n * √n)`，空间复杂度为 `O(n)`。

#### 2. BFS（广度优先搜索）

- 将问题视为图的最短路径问题，节点为当前剩余值，边为减去一个完全平方数后的状态。
- 时间复杂度为 `O(n * √n)`，空间复杂度为 `O(n)`。

---

### 总结

- **数学解法**基于拉格朗日四平方和定理，效率最高，适合需要快速判断的场景。
- **动态规划**和 **BFS** 提供了灵活的解法，适合需要逐步求解的场景。
- 数学解法的时间复杂度为 **`O(n)`**，且空间复杂度为 **`O(1)`**，是最优选择。