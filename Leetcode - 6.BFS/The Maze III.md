
### LintCode 789: **迷宫 III** (The Maze III)

---

### 问题描述

给定一个二维网格迷宫 `maze`，其中：

- `0` 表示空地。
- `1` 表示墙。

起始点 `ball` 位于 `maze` 的某个位置，目标点 `hole` 也位于某个位置。球可以沿上下左右方向滚动，直到碰到墙或边界，才会停下。

**任务**： 找出使球到达洞口的最短距离的路径。如果存在多条最短路径，则返回字典序最小的路径。路径用方向字符表示：

- `'u'`：上
- `'d'`：下
- `'l'`：左
- `'r'`：右

如果无法到达洞口，返回字符串 `"impossible"`。

Example:
样例 1:
输入:
[ [0,0,0,0,0],[1,1,0,0,1],[0,0,0,0,0],[0,1,0,0,1],[0,1,0,0,0] ]
[4,3]
[0,1]
输出:
"lul"

样例 2:
输入:
[ [0,0,0,0,0],[1,1,0,0,1],[0,0,0,0,0],[0,1,0,0,1],[0,1,0,0,0] ]
[0,0]
[1,1]
输出:
"impossible"



---

### 解法：BFS（广度优先搜索 + 队列）

#### 思路

1. **BFS 搜索**：
    
    - 使用队列进行层次遍历，记录每个位置的最短距离及对应路径。
    - 对于每个位置，尝试四个方向滚动球，直到碰到墙或边界。
2. **记录状态**：
    
    - 使用 `distance` 字典记录每个位置的最短距离。
    - 使用 `path` 字典记录从起点到当前点的路径。
3. **终止条件**：
    
    - 当球滚动到洞口时，更新最短距离和路径。
    - 如果队列为空仍未到达洞口，返回 `"impossible"`。
4. **优先字典序路径**：
    
    - BFS 天然按层级遍历，当路径长度相同时，可以通过对方向按字典序排序确保最优解。

---
Example:
**样例 1:**
```
输入:
[[0,0,0,0,0],[1,1,0,0,1],[0,0,0,0,0],[0,1,0,0,1],[0,1,0,0,0]]
[4,3]
[0,1]

输出:
"lul"
```
**样例 2:**
```
输入:
[[0,0,0,0,0],[1,1,0,0,1],[0,0,0,0,0],[0,1,0,0,1],[0,1,0,0,0]]
[0,0]
[1,1]
输出:
"impossible"
```

### 代码实现

```python
from collections import deque

class Solution:
    def find_shortest_way(self, maze, ball, hole):
        rows, cols = len(maze), len(maze[0])
        directions = [(-1, 0, 'u'), (1, 0, 'd'), (0, -1, 'l'), (0, 1, 'r')]
        queue = deque([(ball[0], ball[1], 0, "")])  # (x, y, 当前距离, 当前路径)
        visited = {}

        def roll(x, y, dx, dy):
            steps = 0
            while 0 <= x + dx < rows and 0 <= y + dy < cols and maze[x + dx][y + dy] == 0:
                x += dx
                y += dy
                steps += 1
                if [x, y] == hole:  # 滚到洞口停止
                    break
            return x, y, steps

        while queue:
            x, y, dist, path = queue.popleft()

            if (x, y) in visited and (dist > visited[(x, y)][0] or (dist == visited[(x, y)][0] and path >= visited[(x, y)][1])):
                continue

            visited[(x, y)] = (dist, path)

            for dx, dy, direction in directions:
                nx, ny, steps = roll(x, y, dx, dy)
                new_dist = dist + steps
                new_path = path + direction
                if (nx, ny) not in visited or new_dist < visited[(nx, ny)][0] or (new_dist == visited[(nx, ny)][0] and new_path < visited[(nx, ny)][1]):
                    queue.append((nx, ny, new_dist, new_path))

        if tuple(hole) in visited:
            return visited[tuple(hole)][1]
        return "impossible"

```
pass

### 示例输入输出

#### 示例 1
```python
maze = [
    [0, 0, 0, 0, 0],
    [1, 1, 0, 0, 1],
    [0, 0, 0, 0, 0],
    [0, 1, 0, 0, 1],
    [0, 1, 0, 0, 0]
]
ball = [4, 3]
hole = [0, 1]

```

**运行过程**：

1. **初始化**：
    
    - `queue = deque([(4, 3, 0, "")])`
    - `visited = {}`
2. **第一步**：
    
    - 当前状态：`(4, 3, 0, "")`
    - 尝试四个方向：
        - 向上（`u`）：到达 `(2, 3)`，距离 `2`，路径 `"u"`。
        - 向下（`d`）：碰到墙，不移动。
        - 向左（`l`）：到达 `(4, 0)`，距离 `3`，路径 `"l"`。
        - 向右（`r`）：到达 `(4, 4)`，距离 `1`，路径 `"r"`。
    - 更新队列：`queue = deque([(2, 3, 2, "u"), (4, 0, 3, "l"), (4, 4, 1, "r")])`
3. **第二步**：
    
    - 当前状态：`(2, 3, 2, "u")`
    - 尝试四个方向：
        - 向上（`u`）：到达 `(0, 3)`，距离 `4`，路径 `"uu"`。
        - 向下（`d`）：回到 `(4, 3)`，跳过。
        - 向左（`l`）：到达 `(2, 0)`，距离 `5`，路径 `"ul"`。
        - 向右（`r`）：到达 `(2, 4)`，距离 `3`，路径 `"ur"`。
    - 更新队列：`queue = deque([(4, 0, 3, "l"), (4, 4, 1, "r"), (0, 3, 4, "uu"), (2, 0, 5, "ul"), (2, 4, 3, "ur")])`
4. **第三步**：
    
    - 当前状态：`(4, 0, 3, "l")`
    - 尝试四个方向，未更新更短距离。
5. **找到洞口**：
    
    - 当到达 `(0, 1)` 时，路径为 `"lu"`。

**输出**：

`"lu"`

---

### 时间和空间复杂度分析

#### 时间复杂度

1. **滚动计算**：
    
    - 每个位置最多尝试 4 个方向。
    - 每次滚动的步数最多为 `R + C`。
2. **搜索状态空间**：
    
    - 最多访问 `R * C` 个位置。

总时间复杂度为 **`O(R * C * (R + C))`**。

#### 空间复杂度

1. 队列存储所有待处理状态，最坏情况下为 `O(R * C)`。
2. 访问记录需要 `O(R * C)`。

总空间复杂度为 **`O(R * C)`**。

---

### 其他解法简述

#### 1. 双向 BFS

- 从起点和洞口同时进行 BFS。
- 搜索空间减半，时间效率更高。

#### 2. 优先级队列（Dijkstra 算法）

- 使用优先级队列，每次扩展距离最短的状态。
- 适合需要最短路径问题的优化。

---

### 总结

- BFS 是解决迷宫 III 的基础方法，直观易实现，适合理解问题的初学者。
- 双向 BFS 和 Dijkstra 在特定场景下更高效，但实现复杂度更高。
- 本问题的复杂度为 **`O(R * C * (R + C))`**，适合小规模迷宫的解法。

