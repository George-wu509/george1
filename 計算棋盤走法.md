
如果有7x7的棋盤. 從 x,y = (0,0)的位置要走到(6,6)的位置, 只能走往右跟往上兩個方向走一步, 要怎麼計算有幾種走法?

## 計算棋盤走法數：遞迴與動態規劃

要計算從 (0,0) 走到 (6,6) 在 7times7 棋盤上，只能往右或往上走，有幾種走法，這是一個典型的組合數學問題。最適合的解法是使用遞迴或動態規劃。

### 思路解釋

想像你現在在棋盤上的任意一點 $ (x,y) $。為了到達終點 $ (6,6) $，你只能從 $ (x-1, y) $（往右走一步）或 $ (x, y-1) $（往上走一步）抵達當前位置。

- **基本情況 (Base Cases):**
    
    - 如果你在最左邊一列 $ (0, y) $，要走到任何 $ (0, y') $，只能一直往上走，所以只有 **1 種**走法。
        
    - 如果你在最下面一列 $ (x, 0) $，要走到任何 $ (x', 0) $，只能一直往右走，所以也只有 **1 種**走法。
        
    - 如果你在起點 $ (0,0) $，只有 **1 種**走法，就是從 (0,0) 自己開始。
        
- **遞迴關係 (Recursive Relation):** 對於棋盤上任何非邊緣的位置 $ (x,y) $，到達該點的走法數等於到達其左邊一點 $(x-1, y)$ 的走法數加上到達其下方一點 $(x, y-1)$ 的走法數。 也就是說：$ Ways(x, y) = Ways(x-1, y) + Ways(x, y-1) $。
    

這個問題其實等同於從起點到終點，你需要走 **6 步往右**和 **6 步往上**，總共 **12 步**。這12步中，有6步是往右，6步是往上，你可以任意安排這些步數的順序。這就是一個組合問題，可以用 **二項式係數** 來解決：從總步數中選擇往右或往上的步數。

因此，走法數為 binom總步數往右步數 或 $ \binom{總步數}{往上步數} $。 在本例中，總步數是 (6−0)+(6−0)=12 步。 往右步數是 6 步，往上步數也是 6 步。 所以走法數為 $ \binom{12}{6} $。

binom126=frac126(12−6)=frac1266=frac12times11times10times9times8times76times5times4times3times2times1=924

### Python 程式碼

我會提供兩種 Python 實現方式：**動態規劃 (迭代法)** 和 **數學公式 (二項式係數)**。動態規劃的方法更直觀地體現了上述的遞迴思路，而數學公式則更高效。

#### 1. 動態規劃 (迭代法)

這種方法模擬了棋盤的填充過程。我們建立一個二維陣列 (或列表的列表) 來儲存到達每個位置的走法數。

Python

```
def count_paths_dp(rows, cols):
    """
    使用動態規劃計算從 (0,0) 到 (rows-1, cols-1) 的走法數。
    棋盤大小為 rows x cols。
    只能往右或往上走。
    """
    # 初始化一個 (rows) x (cols) 的網格來儲存走法數
    # dp[i][j] 表示從 (0,0) 到 (i,j) 的走法數
    dp = [[0 for _ in range(cols)] for _ in range(rows)]

    # 初始化第一行和第一列
    # 到達第一行任何位置只有一種走法（一直往右）
    for c in range(cols):
        dp[0][c] = 1
    # 到達第一列任何位置只有一種走法（一直往上）
    for r in range(rows):
        dp[r][0] = 1

    # 填充 DP 表格
    # 從 (1,1) 開始，因為第一行和第一列已經初始化
    for r in range(1, rows):
        for c in range(1, cols):
            dp[r][c] = dp[r-1][c] + dp[r][c-1]

    # 最終結果是到達目標位置 (rows-1, cols-1) 的走法數
    return dp[rows-1][cols-1]

# 棋盤是 7x7，所以目標位置是 (6,6)
# 在我們的函數中，rows 和 cols 代表棋盤的維度，即 7
rows = 7
cols = 7
num_paths_dp = count_paths_dp(rows, cols)
print(f"使用動態規劃計算，從 (0,0) 到 ({rows-1},{cols-1}) 的走法數為: {num_paths_dp}")

```

---

#### 2. 數學公式 (二項式係數)

這種方法直接應用組合數學的公式，需要計算階乘。

Python

```
import math

def count_paths_math(target_x, target_y):
    """
    使用數學公式 (二項式係數) 計算從 (0,0) 到 (target_x, target_y) 的走法數。
    只能往右或往上走。
    """
    # 總共需要走的步數 = 往右的步數 + 往上的步數
    total_steps = target_x + target_y
    # 選擇往右的步數（也可以選擇往上的步數，結果一樣）
    steps_right = target_x

    # 計算 C(n, k) = n! / (k! * (n-k)!)
    # math.comb(n, k) 是 Python 3.8+ 提供的計算組合數的函數
    # 如果版本較舊，需要手動實現階乘計算
    try:
        return math.comb(total_steps, steps_right)
    except AttributeError:
        # 如果 math.comb 不存在 (Python < 3.8)，則手動計算
        return math.factorial(total_steps) // (math.factorial(steps_right) * math.factorial(total_steps - steps_right))

# 目標位置是 (6,6)
target_x = 6
target_y = 6
num_paths_math = count_paths_math(target_x, target_y)
print(f"使用數學公式計算，從 (0,0) 到 ({target_x},{target_y}) 的走法數為: {num_paths_math}")

```

---

這兩種方法都會得到相同的結果：**924** 種走法。數學公式的方法在計算上更為高效，而動態規劃則更直觀地展示了問題的遞迴結構。