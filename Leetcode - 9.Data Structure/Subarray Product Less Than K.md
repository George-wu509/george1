Lintcode 1075
给定一个正整数数组`nums`。  
输出连续的子数组个数，每个子数组中元素的乘积小于`k`。

```python
"""
样例 1:
	输入:  nums = [10, 5, 2, 6], k = 100
	输出:  8
	
	解释:
	这8个子段是: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6].
	[10, 5, 2] 没有严格小于100所以不算。

	
解释 2:
	输入: nums = [5,10,2], k = 10
	输出:  2
	
	解释:
	只有 [5] 和 [2].
```


```python

    def num_subarray_product_less_than_k(self, nums: List[int], k: int) -> int:
        ans, prod, i = 0, 1, 0
        for j, num in enumerate(nums):
            prod *= num
            while i <= j and prod >= k:
                prod //= nums[i]
                i += 1
            ans += j - i + 1
        return ans
```
pass

# **LintCode 1075 - Subarray Product Less Than K（子数组乘积小于 K）**

## **题目解析**

给定一个正整数数组 `nums` 和一个整数 `k`，要求 **计算所有子数组，使得其乘积小于 `k` 的个数**。

### **关键点**

1. **子数组（Subarray）是连续的**，即不能随意选择数组中的元素。
2. **子数组乘积需要小于 `k`**，如何高效计算所有符合条件的子数组？
3. **暴力解法 `O(n²)` 太慢，需要优化**。

---

## **解法解析**

### **思路**

本题采用 **滑动窗口（Sliding Window）+ 乘积维护** 来优化计算：

4. **使用双指针 `i` 和 `j`**：
    - `j` **扩展窗口**，不断增加 `nums[j]` 计算当前子数组的乘积 `prod`。
    - **如果 `prod >= k`**，移动左指针 `i` **缩小窗口**，直到 `prod < k`。
5. **窗口大小贡献子数组个数**：
    - **当 `i` 移动到 `j` 位置时，窗口 `[i, j]` 内的所有子数组都是有效的**。
    - 贡献 **`j - i + 1`** 个子数组。
6. **遍历 `nums` 计算所有可能的窗口**。

---

### **解法步骤**

7. **初始化变量**：
    
    - `prod = 1`（当前窗口内的乘积）
    - `i = 0`（左指针）
    - `ans = 0`（结果）
8. **遍历 `nums`**：
    
    - 计算 `prod *= nums[j]`
    - **若 `prod >= k`**，移动 `i`，更新 `prod`
    - **计算当前窗口 `[i, j]` 内的子数组个数** `ans += j - i + 1`
9. **返回 `ans` 作为最终答案**
    

---

## **具体举例**

假设 `nums = [10, 5, 2, 6]`，`k = 100`。

|`j`|`num[j]`|`prod`|`i` 移动|`子数组个数`|`ans` 累加|
|---|---|---|---|---|---|
|0|10|`10`|不动|`[10]` → `1`|`1`|
|1|5|`10*5=50`|不动|`[10,5], [5]` → `2`|`3`|
|2|2|`50*2=100`|`i=1`，`prod=100/10=10`|`[5,2], [2]` → `2`|`5`|
|3|6|`10*6=60`|不动|`[5,2,6], [2,6], [6]` → `3`|`8`|

最终答案 `ans = 8`。

所有有效子数组：

css

複製編輯

`[10]、[10,5]、[5]、[5,2]、[2]、[5,2,6]、[2,6]、[6]`

---

## **时间与空间复杂度分析**

### **时间复杂度**

- `j` **遍历 `nums`**：O(n)
- **`i` 只向前移动**，每个元素最多被移除一次：O(n)
- **总时间复杂度：O(n)**

### **空间复杂度**

- 只使用了常数变量 `prod, i, ans`，**O(1)**。

---

## **其他解法**

### **1. 暴力解法（O(n²)）**

- **思路**：
    - 遍历所有子数组，计算乘积并判断是否小于 `k`。
- **时间复杂度**：O(n²)
- **空间复杂度**：O(1)
- **适用情况**：`n` **非常小（≤1000）**。

### **2. 二分法（O(n log n)）**

- **思路**：
    - 对于每个 `j`，二分搜索最小的 `i` 使得 `prod[i:j] < k`。
- **时间复杂度**：O(n log n)
- **空间复杂度**：O(1)
- **适用情况**：**需要更快的查询窗口起点**。

---

## **LintCode 相关题目**

这类问题通常涉及 **滑动窗口、前缀和、子数组求解**，以下是相似题目：

|**题号**|**题目名称**|**难度**|**核心技术**|
|---|---|---|---|
|**LintCode 1075**|Subarray Product Less Than K|⭐⭐⭐|**滑动窗口 + 乘积**|
|**LintCode 604**|Window Sum|⭐⭐|**滑动窗口 + 前缀和**|
|**LintCode 911**|Maximum Size Subarray Sum Equals k|⭐⭐⭐|**滑动窗口 + 哈希表**|
|**LintCode 1380**|Subarray Sum Equals K|⭐⭐⭐|**前缀和 + 哈希表**|
|**LintCode 604**|Two Sum - Less than K|⭐⭐|**双指针 + 排序**|
|**LintCode 1915**|Number of Submatrices That Sum to Target|⭐⭐⭐⭐|**前缀和 + 动态规划**|

---

## **总结**

10. **最佳解法**：滑动窗口 `O(n)`，适用于 **正整数数组**。
11. **次优解法**：二分法 `O(n log n)`，适用于 **较大数据范围**。
12. **暴力解法 `O(n²)` 仅适用于小规模数据**。