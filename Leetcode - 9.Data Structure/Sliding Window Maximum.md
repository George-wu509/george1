Lintcode 362
给出一个可能包含重复的整数数组，和一个大小为 _k_ 的滑动窗口, 从左到右在数组中滑动这个窗口，找到数组中每个窗口内的最大值。

### **LintCode 362 - 滑动窗口的最大值 解法詳細步驟**

---

### **題目分析**

給定一個數組 `nums` 和一個窗口大小 `k`，要求在數組中找到每個滑動窗口中的最大值。窗口從數組左端開始，向右滑動，直到數組的右端。

---

### **解法核心思路**

使用**雙端隊列（deque）**實現滑動窗口的最大值查找：

1. 隊列中存儲數組的索引，而非值。
2. 隊列中的元素按遞減順序排列，隊首始終是窗口的最大值索引。
3. 隨著窗口滑動：
    - 當隊首索引不再在窗口範圍內時，從隊列中移除。
    - 當隊尾的元素小於新進入窗口的元素時，從隊列中移除隊尾，直到保持遞減順序。

---

### **解法步驟**

#### **1. 初始化**

- **特殊情況處理**：
    - 如果 `nums` 為空或 `k` 為 0，直接返回空列表。
- 定義變量：
    - `dq`：雙端隊列，用於存儲窗口內元素的索引。
    - `result`：存儲滑動窗口的最大值結果。

---

#### **2. 前置初始化窗口**

- 遍歷前 `k-1` 個元素，將它們的索引加入雙端隊列。
- 在此過程中，通過 `push` 函數維護隊列中的遞減順序。

---

#### **3. 滑動窗口處理**

- 遍歷數組從第 `k-1` 個元素開始，對每個新進入窗口的元素進行以下操作：
    1. 調用 `push` 函數維護隊列遞減順序。
    2. 將當前窗口的最大值（隊首元素對應的數值）加入 `result`。
    3. 如果隊首索引不再屬於當前窗口，從隊首移除元素。

---

#### **4. 返回結果**

- 最終返回 `result`，即每個滑動窗口的最大值列表。

Example:
```python
输入:
[1,2,7,7,8]
3
输出:
[7,7,8]

解释：
最开始，窗口的状态如下：`[|1, 2 ,7| ,7 , 8]`, 最大值为 `7`;
然后窗口向右移动一位：`[1, |2, 7, 7|, 8]`, 最大值为 `7`;
最后窗口再向右移动一位：`[1, 2, |7, 7, 8|]`, 最大值为 `8`.
```
```python
输入:
[1,2,3,1,2,3]
5
输出:
[3,3]

解释:
最开始，窗口的状态如下： `[|1,2,3,1,2 | ,3]` , 最大值为`3`;
然后窗口向右移动一位.`[1, |2,3,1,2,3]`, 最大值为 `3`;
```


```python
    def max_sliding_window(self, nums: List[int], k: int) -> List[int]:
        if not nums or not k:
            return []
            
        dq = deque([])
        
        for i in range(k - 1):
            self.push(dq, nums, i)
        
        result = []
        for i in range(k - 1, len(nums)):
            self.push(dq, nums, i)
            result.append(nums[dq[0]])
            if dq[0] == i - k + 1:
                dq.popleft()
                
        return result
            
    def push(self, dq, nums, i):
        while dq and nums[dq[-1]] < nums[i]:
            dq.pop()
        dq.append(i)
```

---

### **`push` 函數詳細解釋**

- 功能：將索引 `i` 添加到雙端隊列中，同時保持隊列中的元素遞減。
- 實現：
    - 當隊尾元素小於當前元素時，從隊列尾部彈出，直到保持隊列遞減順序。

---

### **具體舉例**

#### 輸入：

`nums = [1, 2, 7, 7, 8] k = 3`

#### 步驟詳解：

1. **初始化：**
    
    - `dq = deque([])`
    - `result = []`
2. **前置窗口初始化：**
    
    - 遍歷 `i = 0, 1`：
        - 當 `i = 0`：
            - 調用 `push`，`dq = [0]`。
        - 當 `i = 1`：
            - 調用 `push`，`dq = [1]`（`1` 大於 `nums[0]`，移除 `0`）。
3. **滑動窗口處理：**
    
    - 遍歷 `i = 2, 3, 4`：
        1. 當 `i = 2`：
            - 調用 `push`，`dq = [2]`（`7` 大於 `nums[1]`，移除 `1`）。
            - 將 `nums[dq[0]] = 7` 加入 `result` -> `result = [7]`。
        2. 當 `i = 3`：
            - 調用 `push`，`dq = [2, 3]`（`7` 等於 `nums[2]`，保留 `2`）。
            - 將 `nums[dq[0]] = 7` 加入 `result` -> `result = [7, 7]`。
        3. 當 `i = 4`：
            - 調用 `push`，`dq = [4]`（`8` 大於 `nums[3]`，移除 `3` 和 `2`）。
            - 將 `nums[dq[0]] = 8` 加入 `result` -> `result = [7, 7, 8]`。
4. **返回結果：**
    
    - `result = [7, 7, 8]`

---

### **時間與空間複雜度分析**

1. **時間複雜度：**
    
    - 每個元素最多進入和彈出隊列一次，因此總時間複雜度為 O(n)O(n)O(n)，其中 nnn 為數組長度。
2. **空間複雜度：**
    
    - 雙端隊列的最大長度為窗口大小 kkk，因此空間複雜度為 O(k)O(k)O(k)。

---

### **其他解法簡述**

1. **暴力法：**
    
    - 對每個窗口遍歷所有元素找最大值。
    - **時間複雜度：** O(n⋅k)O(n \cdot k)O(n⋅k)（不適合大數據）。
2. **分塊法（線段樹）：**
    
    - 將數組分塊並預處理塊內最大值，用動態範圍查詢獲取窗口最大值。
    - **時間複雜度：** O(n+q)O(n + q)O(n+q)，其中 qqq 是查詢次數。
3. **優先隊列法：**
    
    - 使用最大堆維護當前窗口的最大值。
    - **時間複雜度：** O(nlog⁡k)O(n \log k)O(nlogk)。