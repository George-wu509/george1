
LintCode 126
给出一个没有重复数字的整数数组，在此数组上建立最大树，其定义如下：

- 根是数组中最大的数
- 左子树和右子树元素分别是被父节点元素切分开的子数组中的最大值

利用给定的数组构造最大树。


---

### **題目分析**

**最大树**是一種二叉樹，其構造規則為：

1. 每個節點的值是該子樹中所有數字的最大值。
2. 每個節點的左子樹包含小於該節點值且最近出現在左側的數字。
3. 每個節點的右子樹包含小於該節點值且最近出現在右側的數字。

目標是對輸入數組構造這樣一棵二叉樹。

---

### **解法核心思路**

利用 **單調遞減棧** 快速定位左右子樹的父節點，避免暴力搜索：

1. 從左到右掃描數組。
2. 使用棧追蹤尚未分配父節點的數字。
3. 當遇到更大的數字時，彈出棧頂，並構建該數字的左右子樹。

---

### **解法步驟**

#### **1. 初始化**

- 如果輸入數組為空，直接返回 `None`。
- 將輸入數組每個元素轉換為 `TreeNode`，並附加一個值為 `sys.maxsize` 的虛擬節點，以簡化構建過程。

#### **2. 構建最大樹**

- 初始化一個空棧 `stack`，用於存儲數組的索引。
- 遍歷 `A + [sys.maxsize]` 的每個元素（包含虛擬節點）：
    1. 如果棧頂的值小於當前元素，彈出棧頂索引並構建子樹：
        - 棧頂節點作為當前節點的左子樹或右子樹。
        - 根據棧中剩餘的元素判斷棧頂節點應該掛到左邊還是右邊。
    2. 將當前索引壓入棧中。

#### **3. 返回結果**

- 虛擬節點的左子節點即為整棵樹的根節點。

Example:
**样例 1：**

输入：
```python
A = [2, 5, 6, 0, 3, 1]
```
输出：
```python
{6,5,3,2,#,0,1}
```
解释：
此数组构造的最大树是：
```python
        6
       / \
      5   3
     /   / \
    2   0   1
```

输入：
```python
A = [6,4,20]
```
输出：
```python
{20,6,#,#,4}
```
解释：
此数组构造的最大树是：
```python
     20
     / 
    6
     \
      4
```

---
```python
    def maxTree(self, A):
        if not A:
            return None
            
        nodes = [TreeNode(num) for num in A + [sys.maxsize]]
        stack = []
        for index, num in enumerate(A + [sys.maxsize]):
            while stack and A[stack[-1]] < num:
                top = stack.pop()
                left = A[stack[-1]] if stack else sys.maxsize
                if left < num:
                    nodes[stack[-1]].right = nodes[top]
                else:
                    nodes[index].left = nodes[top]
            
            stack.append(index)

        # sys.maxsize 's left child is the maximum number
        return nodes[-1].left
```
pass

### **具體例子**

#### 輸入：

`A = [3, 2, 1, 6, 0, 5]`

#### 步驟詳解：

1. **初始化：**
    
    - `nodes = [TreeNode(3), TreeNode(2), TreeNode(1), TreeNode(6), TreeNode(0), TreeNode(5), TreeNode(sys.maxsize)]`
    - `stack = []`
2. **遍歷數組：**
    

| 當前元素 num    | 棧操作  | 子樹構建                       | 棧狀態     |
| ----------- | ---- | -------------------------- | ------- |
| 333         | 壓入棧  | 無                          | [0]     |
| 222         | 壓入棧  | 無                          | [0,1]   |
| 111         | 壓入棧  | 無                          | [0,1,2] |
| 666         | 彈出 2 | 節點 1為節點 2 的右子樹             | [0,1]   |
|             | 彈出 1 | 節點 2 為節點 6 的左子樹            | [0]     |
|             | 彈出 0 | 節點 3 為節點 6 的左子樹            | []      |
|             | 壓入 3 | 無                          | [3      |
| 000         | 壓入棧  | 無                          | [3,4]   |
| 555         | 彈出 4 | 節點 0 為節點 5 的左子樹            | [3]     |
|             | 壓入 5 | 無                          | [3,5]   |
| sys.maxsize | 彈出 5 | 節點 555 為節點 sys.maxsiz的左子樹  | [3]     |
|             | 彈出 3 | 節點 666 為節點 sys.maxsize的左子樹 | []      |
|             | 壓入 6 | 無                          | [6      |

3. **最終結果：**
    - sys.maxsize 的左子節點為樹的根節點：
        
```markdown
          6
        /   \
       3     5
        \    /
         2  0
          \
           1

```
        

---

### **時間與空間複雜度分析**

1. **時間複雜度：**
    
    - 每個元素最多進入和彈出棧一次，因此遍歷的總時間為 O(n)O(n)O(n)。
2. **空間複雜度：**
    
    - 單調棧的最大深度為 O(n)O(n)O(n)（在所有元素遞減時）。
    - `nodes` 列表的大小為 O(n)O(n)O(n)。
    - 總空間複雜度為 O(n)O(n)O(n)。

---

### **其他解法簡述**

1. **遞歸分治法：**
    
    - 尋找當前數組的最大值作為根節點，將最大值左邊和右邊的子數組分別構建左右子樹。
    - 時間複雜度：最壞情況 O(n2)O(n^2)O(n2)（當數組接近有序時）。
2. **改進分治法（使用索引樹）：**
    
    - 預處理每段範圍內的最大值索引，避免每次重複搜索。
    - 時間複雜度：O(nlog⁡n)O(n \log n)O(nlogn)。

---

這種基於單調棧的解法在時間和空間上表現最好，且結構清晰。