
lintcode 1060
给定一个每日`temperatures`的列表，产生一个列表，对于输入的每天，告诉我们你要等多少天才能够等到一个更高的温度。如果没有可能的未来日期，输出0作为替代。

比如，给定列表 `temperatures = [73, 74, 75, 71, 69, 72, 76, 73]`，你的输出应该是`[1, 1, 4, 2, 1, 1, 0, 0]`

### LintCode 1060: 每日温度（Daily Temperatures）

---

#### **问题描述**

给定一个数组 `temperatures`，表示每日温度，返回一个数组 `answer`，其中 `answer[i]` 是在第 `i` 天之后才会有更高的温度的等待天数。如果在未来没有更高的温度，请在该位置填 `0`。

**输入：**

`temperatures = [73, 74, 75, 71, 69, 72, 76, 73]`

**输出：**

`[1, 1, 4, 2, 1, 1, 0, 0]`

---
Example:
```python
样例 1:
	输入:  temperatures = [73, 74, 75, 71, 69, 72, 76, 73]
	输出:  [1, 1, 4, 2, 1, 1, 0, 0]
	
	解释:
	找到每个数字后面第一个大于自己的数字，输出两者的距离。

	
样例 2:
	输入: temperatures = [50, 40, 39, 30]
	输出:  [0,0,0,0]
```

#### **代码概览**
```python
def dailyTemperatures(temperatures):
    n = len(temperatures)
    result = [0] * n
    stack = []

    for i, temp in enumerate(temperatures):
        while stack and temperatures[stack[-1]] < temp:
            index = stack.pop()
            result[index] = i - index
        stack.append(i)

    return result

```
pass


---

### **解法核心思路**

该解法使用了 **单调栈**，旨在快速找到每个位置之后的第一个更高温度的天数。

---

#### **解法步骤**

1. **初始化：**
    - `n`：温度数组的长度。
    - `result`：结果数组，初始化为全零，长度为 `n`。
    - `stack`：存储索引的单调递减栈（栈中的索引对应的温度是从高到低排序的）。
    
1. **遍历温度数组：**
    - 遍历每个温度和对应的索引 `(i, temp)`。
    - 检查当前温度 `temp` 是否比栈顶索引对应的温度高：
        - 如果是，则弹出栈顶索引 `index`，表示找到更高温度：
            - 计算距离：`result[index] = i - index`。
        - 重复此过程，直到栈为空或栈顶索引对应的温度不小于当前温度。
    - 将当前索引 `i` 压入栈。
    
1. **返回结果：**
    - 遍历结束后，`result` 中的所有值即为每个位置需要等待的天数。

---

#### **时间复杂度**

- 每个索引最多进栈和出栈一次，时间复杂度为 O(n)。
- 空间复杂度为 O(n)，用于存储栈。

---

### **逐步解析**

#### **输入：**

`temperatures = [73, 74, 75, 71, 69, 72, 76, 73]`

---

#### **初始化：**

`n = 8 result = [0, 0, 0, 0, 0, 0, 0, 0] stack = []`

---

#### **遍历温度数组：**

##### **第 1 步：索引 0，温度 73**

- 栈为空，直接将索引 `0` 压入栈。
- **更新：**

    `stack = [0] result = [0, 0, 0, 0, 0, 0, 0, 0]`
    

---

##### **第 2 步：索引 1，温度 74**

- 当前温度 `74` > 栈顶索引对应的温度 `73`：
    - 弹出栈顶索引 `0`，计算距离：`1 - 0 = 1`。
    - 更新 `result[0] = 1`。
- 将索引 `1` 压入栈。
- **更新：**

    `stack = [1] result = [1, 0, 0, 0, 0, 0, 0, 0]`
    

---

##### **第 3 步：索引 2，温度 75**

- 当前温度 `75` > 栈顶索引对应的温度 `74`：
    - 弹出栈顶索引 `1`，计算距离：`2 - 1 = 1`。
    - 更新 `result[1] = 1`。
- 将索引 `2` 压入栈。
- **更新：**

    `stack = [2] result = [1, 1, 0, 0, 0, 0, 0, 0]`
    

---

##### **第 4 步：索引 3，温度 71**

- 当前温度 `71` <= 栈顶索引对应的温度 `75`：
    - 将索引 `3` 压入栈。
- **更新：**

    `stack = [2, 3] result = [1, 1, 0, 0, 0, 0, 0, 0]`
    

---

##### **第 5 步：索引 4，温度 69**

- 当前温度 `69` <= 栈顶索引对应的温度 `71`：
    - 将索引 `4` 压入栈。
- **更新：**

    `stack = [2, 3, 4] result = [1, 1, 0, 0, 0, 0, 0, 0]`
    

---

##### **第 6 步：索引 5，温度 72**

- 当前温度 `72` > 栈顶索引对应的温度 `69`：
    - 弹出栈顶索引 `4`，计算距离：`5 - 4 = 1`。
    - 更新 `result[4] = 1`。
- 当前温度 `72` > 新的栈顶索引对应的温度 `71`：
    - 弹出栈顶索引 `3`，计算距离：`5 - 3 = 2`。
    - 更新 `result[3] = 2`。
- 将索引 `5` 压入栈。
- **更新：**

    `stack = [2, 5] result = [1, 1, 0, 2, 1, 0, 0, 0]`
    

---

##### **第 7 步：索引 6，温度 76**

- 当前温度 `76` > 栈顶索引对应的温度 `72`：
    - 弹出栈顶索引 `5`，计算距离：`6 - 5 = 1`。
    - 更新 `result[5] = 1`。
- 当前温度 `76` > 新的栈顶索引对应的温度 `75`：
    - 弹出栈顶索引 `2`，计算距离：`6 - 2 = 4`。
    - 更新 `result[2] = 4`。
- 将索引 `6` 压入栈。
- **更新：**

    `stack = [6] result = [1, 1, 4, 2, 1, 1, 0, 0]`
    

---

##### **第 8 步：索引 7，温度 73**

- 当前温度 `73` <= 栈顶索引对应的温度 `76`：
    - 将索引 `7` 压入栈。
- **更新：**

    `stack = [6, 7] result = [1, 1, 4, 2, 1, 1, 0, 0]`
    

---

#### **最终结果：**

`result = [1, 1, 4, 2, 1, 1, 0, 0]`

---

### **代码运行示例**

`# 测试 temperatures = [73, 74, 75, 71, 69, 72, 76, 73] print(dailyTemperatures(temperatures)) # 输出: [1, 1, 4, 2, 1, 1, 0, 0]`

---

### **关键点总结**

1. **单调栈的特性：**
    
    - 栈中的索引对应的温度是单调递减的。
    - 栈顶索引是当前未找到更高温度的最近天数。
2. **栈的作用：**
    
    - 加速找到当前温度的下一个更高温度。
    - 当遇到更高温度时，通过弹栈可以快速更新结果。
3. **时间复杂度：**
    
    - 每个索引最多入栈和出栈一次，时间复杂度为 O(n)O(n)O(n)。
4. **空间复杂度：**
    
    - 使用了额外的栈存储索引，空间复杂度为 O(n)O(n)O(n)。