Lintcode 103
给定一个链表，如果链表中存在环，则返回到链表中环的起始节点，如果没有环，返回`null`。

**样例 1：**
输入：
```python
"""
null，no cycle
```
输出：
```python
"""
no cycle
```
解释：
链表为空，所以没有环存在。

**样例 2：**
输入：
```python
"""
-21->10->4->5，tail connects to node index 1
```
输出：
```python
"""
10
```
解释：
最后一个节点5指向下标为1的节点，也就是10，所以环的入口为10。


```python
def detectCycle(self, head):
	if head == None or head.next == None:
		return None
	slow = fast = head  		#初始化快指针和慢指针
	while fast and fast.next:	
		slow = slow.next
		fast = fast.next.next
		if fast == slow:		#快慢指针相遇
			break
	if slow == fast:
		slow = head				#从头移动慢指针
		while slow != fast:
			slow = slow.next
			fast = fast.next
		return slow				#两指针相遇处即为环的入口
	return None
```
pass


## **LintCode 103: Linked List Cycle II**

### **解法分析**

本題要求找到 **單向鏈表** **環的起始節點**（若無環則返回 `None`）。

- **與 LintCode 102（判斷是否有環）不同**，這題需要 **找到環的入口節點**。

#### **範例**
```python
輸入：
1 → 2 → 3 → 4 → 5 → 6
          ↑         ↓
          9 ← 8 ← 7
          
輸出：
節點 3（環的入口）

```

---

### **解法思路**

此解法 **基於快慢指針（Floyd’s Cycle Detection Algorithm）**：

1. **使用快慢指針檢測是否有環**
    
    - `slow`（慢指針）每次移動 1 步。
    - `fast`（快指針）每次移動 2 步。
    - 若 `fast == slow`，則說明鏈表有環，並且 **相遇點在環內**。
2. **從頭開始移動 `slow` 指針**
    
    - **重置 `slow` 到 `head`**，並將 `fast` 留在相遇點。
    - 兩指針 **每次都前進 1 步**，當 `slow == fast` 時，相遇點即為 **環的起點**。

---

### **數學推導**

假設：

- **鏈表起點到環的入口距離為 `a`**。
- **環的入口到相遇點距離為 `b`**。
- **相遇點繞回環入口的距離為 `c`**。

則：

- **快指針 `fast` 走的距離 = 2 倍的 `slow` 走的距離**
- 即： a+b+c+b=2(a+b)a + b + c + b = 2(a + b)a+b+c+b=2(a+b) a=ca = ca=c **即從 `head` 到環入口的距離 `a`，等於從 `相遇點` 再走 `c` 步到環入口的距離**。  
    **這就是為什麼 `slow` 和 `fast` 相遇後，再從 `head` 和 `相遇點` 各走一步，最終會在環的入口相遇！**

---

### **變數表**

|變數名稱|角色|作用|初始值|變化過程|
|---|---|---|---|---|
|`head`|鏈表頭|指向鏈表的第一個節點|`head`|不變|
|`slow`|慢指針|每次前進 1 步|`head`|遍歷至 `fast` 相遇|
|`fast`|快指針|每次前進 2 步|`head`|遍歷至 `slow` 相遇|
|`a`|入口距離|`head` 到環入口的距離|`未知`|走 `a` 步可到達|
|`b`|入口到相遇點距離|環入口到相遇點|`未知`|走 `b` 步可到相遇點|
|`c`|環長度 - b|相遇點到環入口的距離|`未知`|走 `c` 步回到入口|

---

### **時間與空間複雜度分析**

#### **時間複雜度：O(n)**

- **第一階段（找環）：O(n)**
    - `fast` 每次前進 2 步，`slow` 每次前進 1 步，最多 **遍歷整個鏈表一次**。
- **第二階段（找入口）：O(n)**
    - `slow` 和 `fast` 重新從不同位置開始，每次前進 1 步，最多 **遍歷環一次**。
- **總計 O(n) + O(n) = O(n)**。

#### **空間複雜度：O(1)**

- **只使用兩個額外指針 (`slow`, `fast`)**，不需要額外的數據結構，因此空間複雜度為 **O(1)**。

---

### **其他解法**

1. **使用哈希表（O(n) 時間, O(n) 空間）**
    
    - 使用 `set()` 記錄訪問過的節點，當發現重複節點時，即為環的入口。
2. **修改 `next` 指針法（O(n) 時間, O(1) 空間，破壞結構）**
    
    - 遍歷鏈表時，將 `next` 指針改為 `None`，當 `next` 為 `None` 時即為環的入口。

---

### **結論**

- **最優解為快慢指針法**，因為它只需 **O(n) 時間, O(1) 空間**。
- 若允許 **O(n) 空間**，可以使用 **哈希表** 記錄訪問過的節點，但這不是最優解。