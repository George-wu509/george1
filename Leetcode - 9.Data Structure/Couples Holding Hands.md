Lintcode 1043
`N`对夫妇坐在`2N`个排成一排的座位上. 现求最小的交换数量，使每对夫妇并坐一起，他们可以手牵着手。

一次交换可选择**任何**两个人交换座位。

人和座位由从`0`到`2N-1`的整数表示，夫妻按顺序编号，第一对是`(0,1)`，第二对是`(2,3)`，以此类推，最后一对是`(2N-2,2N-1)`。

初始座位由`row [i]`给出，表示坐在第`i`座位的人的编号。


**样例 1:**
```python
"""
输入: row = [0, 2, 1, 3]
输出: 1

解释: 只需交换row[1]的人和row[2]的人即可.
```
**样例 2:**
```python
"""
输入: row = [3, 2, 0, 1]
输出: 0

解释: 每一对夫妇已经并坐一起.
```


```python
from typing import (
    List,
)

class Solution:
    class UnionFind:
        def __init__(self, n):
            self.parent = [i for i in range(n)]
            self.count = n

        def getCount(self):
            return self.count

        def find(self, x):
            while x != self.parent[x]:
                self.parent[x] = self.parent[self.parent[x]]
                x = self.parent[x]
            return x

        def uni(self, x, y):
          rootX = self.find(x)
          rootY = self.find(y)
          if rootX == rootY:
              return
          self.parent[rootX] = rootY
          self.count -= 1

    def min_swaps_couples(self, row: List[int]) -> int:
        length = len(row)
        N = length // 2
        unionFind = self.UnionFind(N)
        for i in range(0, length, 2):
            unionFind.uni(row[i] // 2, row[i + 1] // 2)
        return N - unionFind.getCount()
```
pass


# **LintCode 1043: Couples Holding Hands 解法詳細解析**

## **問題描述**

在一排長度為 `2N` 的座位上，有 `N` 對情侶（`2N` 個人），他們以**隨機順序**就座。

- `row[i]` 代表座位 `i` 上坐著的人的**編號**，這些人從 `0` 到 `2N-1`。
- `0` 和 `1` 是一對，`2` 和 `3` 是一對，以此類推。

我們的目標是**讓所有情侶都坐在一起**，並找出最少的**交換次數**（每次只能交換相鄰兩個人）。

---

## **解法分析**

這個問題的關鍵點在於：

1. **每對情侶的編號關係**：
    
    - 情侶的編號 `p` 和 `q` 滿足： $(p, q) = (2k, 2k+1) \quad \text{或} \quad (2k+1, 2k)$
    - 例如：情侶 `(0,1)`, `(2,3)`, `(4,5)`…。
2. **建模為** **環（cycle）問題**
    
    - 每兩個座位視為**一個節點**，我們的目標是讓**所有情侶屬於同一個集合**（並查集的概念）。
    - 這樣，我們就能將問題轉化為 **「聯通塊內的最小交換數」**。

# **解题思路与方法**

「首尾相连」这件事情可以使用 **并查集** 表示，将输入数组相邻位置的两个 **编号** 在并查集中进行合并。编写代码基于了下面的事实：

如果一对情侣恰好坐在了一起，并且坐在了成组的座位上，其中一个下标一定是偶数，另一个一定是奇数，并且「偶数的值 + 1 = 奇数的值」。例如编号数对 `[2, 3]`、`[9, 8]`，这些数对的特点是除以 22（下取整）得到的数相等。

要求出「最少交换次数」。假设一共有 NN 对情侣，逻辑上连在了一起的情侣（包括坐错位置和坐对位置的情况）分别有 N1,N2,⋯ ,NnN1​,N2​,⋯,Nn​ 对，这里 nn 是并查集里连通分量的个数，并且 N1+N2+⋯Nn=NN1​+N2​+⋯Nn​=N。把逻辑上连在一起的情侣拆开，每一个连通分量至少须要 N1−1,N2−1,⋯ ,Nn−1N1​−1,N2​−1,⋯,Nn​−1 次。

这种规律对于初始的时候已经坐在一起的情侣同样成立，因为已经坐在一起的情侣在并查集里成为一个连通分量，无须交换，此时 1−1=01−1=0。综上所述，让所有的情侣都能牵手至少须要交换的次数为

(N1−1)+(N2−1)+⋯+(Nn−1)=(N1+N2+⋯+Nn)−n=N−n(N1​−1)+(N2​−1)+⋯+(Nn​−1)=(N1​+N2​+⋯+Nn​)−n=N−n

故「至少交换的次数 = 所有情侣的对数 - 并查集里连通分量的个数」。

---

## **解法步驟**

### **Step 1: 將座位對應到情侶對的索引**

`N = length // 2`

- 每兩個座位為一組，總共 `N` 組。

---

### **Step 2: 使用並查集合併錯誤的情侶**

```python
for i in range(0, length, 2):
    unionFind.uni(row[i] // 2, row[i + 1] // 2)
```

- **將 `row[i]` 和 `row[i+1]` 分別映射到 `N` 組的索引**：

    `row[i] // 2, row[i + 1] // 2`
    
    - 例如：`row = [0, 2, 1, 3]`
        - `0 // 2 = 0`
        - `2 // 2 = 1`
        - `1 // 2 = 0`
        - `3 // 2 = 1`
    - 所以 `[(0,1), (0,1)]`，最終會被合併。

---

### **Step 3: 計算最少交換次數**

`return N - unionFind.getCount()`

- `N` 是總共的**座位組數**。
- `unionFind.getCount()` 是**目前的聯通塊數量**（錯誤連接的情侶數量）。
- **最少交換次數 = `N - 聯通塊數`**。

---

## **舉例解析**

### **Example 1**

`row = [0, 2, 1, 3]`

- `N = 2`（兩對情侶）
    
- **座位分配**：
  
    `座位:    [0, 2, 1, 3] 目標:    [0, 1, 2, 3]`
    
- **合併關係**：

    `0 和 2 屬於不同的情侶組，合併 (0,1) 1 和 3 屬於不同的情侶組，合併 (0,1)`
    
    - 只需 `1` 次交換 `(2,1) → (1,2)`
- **最終輸出**
    

`1`

---

### **Example 2**

`row = [3, 2, 0, 1]`

- `N = 2`
    
- **座位分配**
    
    `座位:    [3, 2, 0, 1] 目標:    [0, 1, 2, 3]`
    
- **合併關係**：

    `3 和 2 屬於不同的情侶組，合併 (1,0) 0 和 1 屬於不同的情侶組，合併 (1,0)`
    
    - 只需 `1` 次交換 `(3,2) → (2,3)`
- **最終輸出**
    
`1`

---

## **時間與空間複雜度分析**

|步驟|時間複雜度|
|---|---|
|**Step 1: 初始化並查集**|`O(N)`|
|**Step 2: 遍歷 `row` 並合併集合**|`O(N α(N))`（`α(N)` 為阿克曼函數，近似 `O(1)`)|
|**Step 3: 計算最少交換數**|`O(1)`|
|**總計**|`O(N)`|

**空間複雜度**

- `O(N)`（存儲 `parent[]` 和 `rank[]`）

這個算法比**暴力模擬交換 (`O(N^2)`)** 快很多，適合大規模輸入。

---

## **其他解法（不需代碼）**

### **1. 直接模擬交換**

- **遍歷 `row`，對每對座位進行** **貪心交換**，直到所有情侶配對完成。
- **時間複雜度 `O(N^2)`**，因為可能需要遍歷 `row` 多次。

### **2. DFS/BFS 連通性檢查**

- **視 `N` 組座位為圖的節點**，構建一個無向圖。
- **使用 BFS/DFS 找出所有連通分量，計算最少交換次數**。
- **時間複雜度 `O(N)`，但 DFS/BFS 需要額外訪問記錄**。

---

## **總結**

### **最佳解法：並查集（Union-Find）**

- **時間 `O(N)`，空間 `O(N)`**
- **利用並查集高效處理座位組合**
- **最少交換次數 = `N - 連通塊數`**

### **其他解法**

1. **暴力交換 (`O(N^2)`)**：逐個交換直至匹配正確。
2. **DFS/BFS (`O(N)`)**：將問題轉換為圖的連通分量。

### **為何選擇並查集？**

- **合併錯誤的情侶組最快**
- **計算交換數最快**
- **適用於大規模數據（N ≫ 1000）**

這道題的本質是 **連通分量問題**，**並查集是最佳解法**，因為它能夠**快速合併與查找錯誤組合**，並且擁有**接近 `O(1)` 的時間複雜度** 🚀。

  

O

搜尋