
### **LintCode 1860 - The Number of 0-submatrices 解法詳細步驟**

---

### **題目分析**

目標是找出一個矩陣中所有只包含 `0` 的子矩陣數量。這是一個經典的動態規劃與單調棧結合的問題，問題的核心在於如何快速計算每一行作為底部的子矩陣數量。

---

### **解法核心思路**

該解法基於以下觀察：

1. 將問題分解為「以每一行作為底部的矩形數量」。
2. 使用一個高度數組 `H` 記錄每列的高度，對於每一行更新高度。
3. 使用單調遞增棧，快速計算每列作為矩形右邊界時的矩形數量。

---

### **解法步驟**

#### **1. 初始化**

- 定義變量：
    - `H`：高度數組，長度為矩陣列數 + 1（額外一列作為哨兵）。
    - `stack`：單調遞增棧，存儲 `(矩形數量, 列索引)`。
    - `total`：統計矩陣中所有子矩陣的總數。
- 遍歷每一行，逐行計算。

---

#### **2. 遍歷矩陣的每一行**

- 對於矩陣的每一行：
    1. **更新高度數組 `H`：**
        - 如果當前單元格值為 `1`，將對應列的高度 `H[j]` 設為 `0`，並重置棧為初始狀態。
        - 如果值為 `0`，將對應列的高度 `H[j]` 增加 1。
    2. **計算當前行的矩形數量：**
        - 使用單調棧來計算以當前列 `j` 為右邊界的矩形數量。
        - 每次當 `H[j]` 小於等於棧頂高度時，彈出棧頂元素，並計算以該列為矩形高度的子矩形數量。
        - 最後將當前矩形數量與列索引壓入棧。

---

#### **3. 累計結果**

- 每次更新矩形數量時，將其累加到 `total` 中。

Example:
```python
输入：
matrix = [[0, 1, 1], [1, 1, 1], [1, 0, 1]]
输出：
2
解释：
对于矩阵matrix，
[[0, 1, 1], 
 [1, 1, 1], 
 [1, 0, 1]]
1 * 1的方格包括（2个）：
*11  011
111  111
101, 1*1
所以0子矩阵有2个
```

```python
输入：
matrix = [[0, 1, 1], [1, 1, 0], [1, 1, 0]]
输出：
4
解释：
对于矩阵matrix，
[[0, 1, 1], 
 [1, 1, 0], 
 [1, 1, 0]]
1 * 1的方格包括（3个）：
*11  011  011
111  11*  110
110, 110, 11*
2 * 1的方格包括（1个）：
111
11*
11*
所以0子矩阵有4个
```

```python
    def countSubmatrix(self, matrix):
        n = len(matrix[0])
    
        total, H = 0, [0] * (n+1)
        for row in matrix:
            stack = [(0, -1)]
            for j in range(n):
                if row[j] == 1:
                    H[j], stack = 0, [(0, j)]
                    continue
                
                H[j] += 1
                while H[stack[-1][1]] >= H[j]:
                    stack.pop()
                
                s = H[j] * (j - stack[-1][1]) + stack[-1][0]
                total += s
                
                stack.append((s, j))
        return total
```
pass

### **具體例子**

#### 輸入：

`matrix = [     [0, 0, 1],     [0, 0, 1],     [1, 0, 0] ]`

#### 步驟詳解：

1. **初始化：**
    
    - `n = 3`（列數）
    - `H = [0, 0, 0, 0]`（高度數組，額外一列哨兵）
    - `total = 0`
2. **第一行 `[0, 0, 1]`：**
    
    - 更新 `H`：`H = [1, 1, 0, 0]`
    - 單調棧操作：
        - 初始化 `stack = [(0, -1)]`
        - 第 0 列：矩形數量為 `1`，累加到 `total` -> `total = 1`。
        - 第 1 列：矩形數量為 `1 + 1 = 2`，累加到 `total` -> `total = 3`。
        - 第 2 列：`H[2] = 0`，重置棧。
3. **第二行 `[0, 0, 1]`：**
    
    - 更新 `H`：`H = [2, 2, 0, 0]`
    - 單調棧操作：
        - 第 0 列：矩形數量為 `2`，累加到 `total` -> `total = 5`。
        - 第 1 列：矩形數量為 `2 + 2 = 4`，累加到 `total` -> `total = 9`。
        - 第 2 列：`H[2] = 0`，重置棧。
4. **第三行 `[1, 0, 0]`：**
    
    - 更新 `H`：`H = [0, 3, 1, 0]`
    - 單調棧操作：
        - 第 0 列：`H[0] = 0`，重置棧。
        - 第 1 列：矩形數量為 `3`，累加到 `total` -> `total = 12`。
        - 第 2 列：矩形數量為 `1`，累加到 `total` -> `total = 13`。

---

#### **最終結果：**

總共有 `13` 個全 `0` 的子矩陣。

---

### **時間與空間複雜度分析**

1. **時間複雜度：**
    
    - 外層遍歷每一行：`O(m)`，其中 `m` 為矩陣行數。
    - 每行內部遍歷每列，且每列進入棧和彈出棧一次：`O(n)`，其中 `n` 為列數。
    - 總時間複雜度為 O(m×n)O(m \times n)O(m×n)。
2. **空間複雜度：**
    
    - 高度數組 `H` 的大小為 O(n)O(n)O(n)。
    - 單調棧的空間大小為 O(n)O(n)O(n)。
    - 總空間複雜度為 O(n)O(n)O(n)。

---

### **其他解法簡述**

1. **暴力法：**
    
    - 枚舉每個左上角和右下角，檢查是否為全 `0` 的矩形。
    - 時間複雜度：O((m×n)2)O((m \times n)^2)O((m×n)2)，不適用於大數據。
2. **動態規劃：**
    
    - 使用一個三維 DP 數組記錄以每個位置為右下角的矩形數量。
    - 時間複雜度：O(m×n2)O(m \times n^2)O(m×n2)。

這種基於單調棧的方法是效率最高且易於理解的解法。

4o