Lintcode 1201
给定一个环形数组（最后一个元素的下一个元素是数组的第一个元素），为每个元素打印下一个更大的元素。 数字x的下一个更大的数是数组中下一个遍历顺序中出现的第一个更大的数字，这意味着您可以循环搜索以查找其下一个更大的数字。 如果它不存在，则为此数字输出-1。


例1:
```python
"""
输入: [1,2,1]
输出: [2,-1,2]
解释：第一个1的下一个更大的数字是2;
数字2找不到下一个更大的数字;
第二个1的下一个更大的数字需要循环搜索，答案也是2。
```
例2:
```python
"""
输入: [1]
输出: [-1]
解释：
数字1找不到下一个更大的数字
```


```python
def next_greater_elements(self, nums: List[int]) -> List[int]:
	n = len(nums)
	ret = [-1] * n
	stk = list()

	for i in range(n * 2 - 1):
		while stk and nums[stk[-1]] < nums[i % n]:
			ret[stk.pop()] = nums[i % n]
		stk.append(i % n)
	
	return ret
```
pass


### **LintCode 1201 - Next Greater Element II**

#### **解法分析**

本題與 **LintCode 1206 (Next Greater Element I)** 類似，但有 **循環數組 (Circular Array)** 的特性，意思是：

- 若 `nums[i]` 在 `nums[i+1:]` 找不到 Next Greater Element，則需要 **從 `nums[0]` 開始繼續找**。

由於數組是循環的，我們不能單純地線性遍歷，而是 **將數組視為兩倍長度的線性數組來處理**。

---

#### **解法步驟**

1. **擴展循環陣列的索引範圍**
    
    - 雖然 `nums` 是循環數組，但我們可以透過 **遍歷 `2n-1` 次** 來模擬環狀特性：
        - `nums[i % n]` 來處理超過 `n` 長度的索引，確保索引回到頭部。
        - `i` 從 `0` 到 `2n-1`，確保每個元素都可以找到 Next Greater Element。
2. **使用單調遞減棧來維護 Next Greater Element**
    
    - 我們使用 **單調遞減棧 `stk`** 來記錄索引：
        - 若當前數 `nums[i % n]` 大於 `stk` 棧頂的數字，則 `stk` 棧頂的索引找到 Next Greater Element，將結果記錄在 `ret[stk.pop()]`。
        - 將 `i % n` 入棧。
3. **處理結果**
    
    - `ret` 陣列初始值設為 `-1`，如果某個數找不到 Next Greater Element，則直接返回 `-1`。

---

### **變數說明**

|變數名稱|說明|
|---|---|
|`nums`|原始數組|
|`n`|`nums` 的長度|
|`ret`|存儲每個元素的 Next Greater Element，預設為 `-1`|
|`stk`|單調遞減棧，存儲索引，幫助找到 Next Greater Element|

---

### **範例**

#### **輸入**

python

複製編輯

`nums = [1, 2, 1]`

#### **處理流程**

4. **初始狀態**
    
    ini
    
    複製編輯
    
    `n = 3 ret = [-1, -1, -1] stk = []`
    
5. **遍歷 `2n-1` 次 (i = 0 ~ 4)：**
    
    - `i = 0`: `nums[0] = 1`
        - `stk` 為空，直接入棧。
        - `stk = [0]`
    - `i = 1`: `nums[1] = 2`
        - `nums[1] > nums[stk[-1]] (1)`，更新 `ret[0] = 2`，彈出 `stk[-1]`
        - `stk = []`
        - 入棧 `stk = [1]`
    - `i = 2`: `nums[2] = 1`
        - `stk` 為空，直接入棧。
        - `stk = [1, 2]`
    - `i = 3 (對應` nums[0] = 1`)`
        - `nums[0] = 1` 不大於 `stk[-1] = nums[2] = 1`，跳過。
    - `i = 4 (對應` nums[1] = 2`)`
        - `nums[1] > nums[stk[-1]] = 1`，更新 `ret[2] = 2`
        - `stk = [1]`
6. **最終結果**
    
    ini
    
    複製編輯
    
    `ret = [2, -1, 2]`
    

#### **輸出**

python

複製編輯

`[2, -1, 2]`

---

### **時間與空間複雜度分析**

#### **時間複雜度**

- 每個元素最多進棧一次，出棧一次，因此時間複雜度為 **O(N)**。
- 遍歷 `2N-1` 次仍為 **O(N)**。
- **最終時間複雜度：O(N)**。

#### **空間複雜度**

- 結果數組 `ret` 需要 **O(N)**。
- 單調棧 `stk` 最多存儲 `N` 個元素，為 **O(N)**。
- **最終空間複雜度：O(N)**。

---

### **其他解法想法**

7. **暴力解法 (O(N²))**
    
    - 針對 `nums[i]`，依序往右找下一個較大的數，若找不到則回到 `nums[0]` 開始找，直到回到 `nums[i]` 結束。
    - **時間複雜度 O(N²)**，不適用於大數據。
8. **雙倍數組 + 單調棧 (O(N))**
    
    - 先把 `nums` 複製一次成 `nums + nums`，然後用 **單調棧** 處理 **前半部分** 的結果。
    - **時間複雜度 O(N)**，但空間需求變大。
9. **Deque 雙端隊列 (O(N))**
    
    - 直接維護一個遞減的雙端隊列來存索引，類似單調棧。
    - **時間複雜度 O(N)**。

---

### **總結**

- **最優解法：單調遞減棧 + 模擬循環數組 (O(N) 時間, O(N) 空間)。**
- **如果數據量小，可以使用暴力解法 (O(N²))。**