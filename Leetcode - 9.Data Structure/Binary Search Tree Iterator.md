Lintcode 86
设计实现一个带有下列属性的二叉查找树的迭代器：  
next()返回BST中下一个最小的元素

- 元素按照递增的顺序被访问（比如中序遍历）
- `next()`和`hasNext()`的询问操作要求**均摊**时间复杂度是O(1)O(1)

### **LintCode 86 - 二叉查找树迭代器 解法詳細解釋**

---

### **題目分析**

設計一個迭代器來遍歷二叉搜索樹（BST），使得：

1. `hasNext()`：返回是否還有下一個節點。
2. `next()`：返回當前節點並移動到下一個節點。
3. 遍歷順序必須為 **中序遍歷**（左->根->右）。

---

### **解法核心思路**

**利用單調棧模擬中序遍歷：**

1. 中序遍歷過程中，每次先走到左子樹的最底部，依次將左子樹節點壓入棧。
2. 當左子樹遍歷完成後，處理根節點並移動到右子樹。
3. 使用棧保存未完全遍歷的節點，可以實現按需遍歷，而不是一次性將整棵樹展開。

---

### **解法步驟**

#### **1. 初始化構造函數**

- 輸入 `root`，初始化棧 `stack`。
- 模擬中序遍歷，從根節點開始將左子樹的所有節點依次壓入棧，直到沒有左子節點為止。
- 棧頂始終保存當前中序遍歷的最小節點。

#### **2. `hasNext()` 方法**

- 檢查棧是否為空：
    - 如果棧非空，說明還有節點未遍歷，返回 `True`。
    - 否則返回 `False`。

#### **3. `_next()` 方法**

- 彈出棧頂節點 `node`，這是當前中序遍歷的節點。
- 如果 `node` 有右子樹：
    1. 將右子樹節點作為根，模擬中序遍歷，依次壓入右子樹的左子節點到棧中。
- 如果 `node` 沒有右子樹：
    1. 繼續從棧中彈出節點，直到找到尚未處理右子樹的節點。
- 返回 `node`。

Example:
**样例 1：**
输入：
```
tree = {10,1,11,#,6,#,12}
```
输出：
```
[1,6,10,11,12]
```
解释：
二叉查找树如下 :  
10  
/   \  
1     11  
\       \  
6       12  
可以返回二叉查找树的中序遍历 [1,6,10,11,12]
**样例 2：**
输入：
```
tree = {2,1,3}
```
输出：
```
[1,2,3]
```
解释：
二叉查找树如下 :  
2  
/   \  
1       3  
可以返回二叉查找树的中序遍历 [1,2,3]

```python
class BSTIterator:
    """
    @param: root: The root of binary tree.
    """
    def __init__(self, root):
        self.stack = []
        while root != None:
            self.stack.append(root)
            root = root.left

    """
    @return: True if there has next node, or false
    """
    def hasNext(self):
        return len(self.stack) > 0

    """
    @return: return next node
    """
    def _next(self):
        node = self.stack[-1]
        if node.right is not None:
            n = node.right
            while n != None:
                self.stack.append(n)
                n = n.left
        else:
            n = self.stack.pop()
            while self.stack and self.stack[-1].right == n:
                n = self.stack.pop()
        
        return node
```
pass

### **具體舉例**

#### 輸入：

`root = [7, 3, 15, null, null, 9, 20]`

**對應的二叉搜索樹：**

```markdown
        7
      /   \
     3     15
          /   \
         9     20

```
#### 遍歷步驟：

1. **初始化 `BSTIterator(root)`：**
    
    - `stack = []`
    - 將左子樹節點壓入棧：`stack = [7, 3]`
2. **第一次調用 `_next()`：**
    
    - 彈出 `3`，因為 `3` 沒有右子樹，棧保持不變。
    - 返回 `3`。
    - `stack = [7]`
3. **第二次調用 `_next()`：**
    
    - 彈出 `7`，因為 `7` 有右子樹，處理右子樹：
        - 壓入右子樹的左子節點：`stack = [15, 9]`
    - 返回 `7`。
4. **第三次調用 `_next()`：**
    
    - 彈出 `9`，因為 `9` 沒有右子樹，棧保持不變。
    - 返回 `9`。
    - `stack = [15]`
5. **第四次調用 `_next()`：**
    
    - 彈出 `15`，因為 `15` 有右子樹，處理右子樹：
        - 壓入右子樹的左子節點：`stack = [20]`
    - 返回 `15`。
6. **第五次調用 `_next()`：**
    
    - 彈出 `20`，因為 `20` 沒有右子樹，棧保持不變。
    - 返回 `20`。
    - `stack = []`
7. **調用 `hasNext()`：**
    
    - 棧為空，返回 `False`。

---

### **時間與空間複雜度分析**

1. **時間複雜度：**
    
    - `hasNext()`：O(1)O(1)O(1)，因為只需檢查棧是否為空。
    - `_next()`：平均為 O(1)O(1)O(1)，最壞情況為 O(h)O(h)O(h)，其中 hhh 為樹的高度。
        - 每個節點最多進入和彈出棧一次，因此總遍歷時間為 O(n)O(n)O(n)，分攤到每個節點約為 O(1)O(1)O(1)。
2. **空間複雜度：**
    
    - 棧的最大深度為樹的高度 O(h)O(h)O(h)，因此空間複雜度為 O(h)O(h)O(h)。

---

### **其他解法簡述**

1. **一次性展開法：**
    
    - 使用遞歸或迭代將整棵樹展開為一個有序數組，然後依次返回元素。
    - **時間複雜度**：初始化 O(n)O(n)O(n)，`hasNext()` 和 `next()` 為 O(1)O(1)O(1)。
    - **空間複雜度**：O(n)O(n)O(n)。
2. **遞歸生成器法：**
    
    - 使用 Python 的生成器實現懶加載的中序遍歷。
    - **時間複雜度**：與棧方法相同，總計 O(n)O(n)O(n)。
    - **空間複雜度**：生成器的遞歸深度為 O(h)O(h)O(h)。

這種基於棧的解法是一種優化的實現，能夠在平均時間 O(1)O(1)O(1) 的情況下實現中序遍歷，非常高效且直觀。

