
LintCode 1297題目是「Count of Smaller Numbers After Self」，即對於一個數組，計算每個元素右側比它小的數的個數。以下用 **單調棧（monotonic stack）** 方法來解釋，並舉例說明。

---

### **題目分析**

給定一個數組 `nums`，我們需要返回一個數組 `counts`，其中 `counts[i]` 表示 `nums[i]` 右邊比它小的數字的個數。

---

### **解法思路：單調棧**

單調棧是一種特殊的棧結構，適合用於處理與序列順序相關的問題。在這個問題中，我們從右向左掃描數組，使用單調棧來保持一個 **遞增序列**，並計算比當前元素小的數字個數。

**步驟如下：**

1. **初始化：**
    
    - 建立一個空的棧 `stack`，用於存儲已處理的元素。
    - 建立一個與 `nums` 大小相同的數組 `counts`，用於存儲結果。
2. **從右向左遍歷數組 `nums`：**
    
    - 對於當前元素 `nums[i]`，在棧中找到比它小的數字個數，這可以通過二分搜索快速找到。
    - 將當前元素插入到棧中，並保持棧的遞增順序（棧頂最小）。
3. **如何找到比當前元素小的數字個數？**
    
    - 單調棧中，棧頂到棧底的數字是遞增的。
    - 當前元素插入棧前，棧中所有比它小的元素的個數等於該元素在棧中的插入位置。
    - 使用二分搜索來確定插入位置，從而提高效率。
4. **返回結果：**
    
    - 最終得到的 `counts` 即為結果。

---
Example:
**样例1**
```plain
输入: [5, 2, 6, 1]
输出: [2, 1, 1, 0]
说明:
5的右侧有2个元素比它小 (2 and 1).
2的右侧有1个元素比它小 (1).
6的右侧有1个元素比它小 (1).
1的右侧有0个元素比它小.
```
**样例2**
```plain
输入: [1, 2, 3, 4]
输出: [0, 0, 0, 0]
```

### **具體實現**

以下是 Python 的具體代碼，配合中文註釋逐步講解：

```python
from bisect import bisect_left

def count_smaller(nums):
    stack = []  # 用於存儲單調遞增序列
    counts = [0] * len(nums)  # 初始化結果數組

    # 從右向左遍歷數組
    for i in range(len(nums) - 1, -1, -1):
        # 找到當前元素應插入的位置
        position = bisect_left(stack, nums[i])
        # 插入位置就是比當前元素小的數字個數
        counts[i] = position
        # 將當前元素插入棧中，並保持棧的有序性
        stack.insert(position, nums[i])
    
    return counts
```
pass

---

### **具體例子**

#### 範例輸入：

`nums = [5, 2, 6, 1]`

#### 運行步驟：

- 初始化：
    
    - `stack = []`
    - `counts = [0, 0, 0, 0]`
- **從右向左遍歷：**
    
    1. **處理 `nums[3] = 1`：**
        
        - `stack = []`，`1` 應插入棧中第 `0` 個位置。
        - 更新 `counts[3] = 0`。
        - 插入後：`stack = [1]`
    2. **處理 `nums[2] = 6`：**
        
        - `stack = [1]`，`6` 應插入棧中第 `1` 個位置。
        - 更新 `counts[2] = 1`。
        - 插入後：`stack = [1, 6]`
    3. **處理 `nums[1] = 2`：**
        
        - `stack = [1, 6]`，`2` 應插入棧中第 `1` 個位置。
        - 更新 `counts[1] = 1`。
        - 插入後：`stack = [1, 2, 6]`
    4. **處理 `nums[0] = 5`：**
        
        - `stack = [1, 2, 6]`，`5` 應插入棧中第 `2` 個位置。
        - 更新 `counts[0] = 2`。
        - 插入後：`stack = [1, 2, 5, 6]`
- **最終結果：**

    `counts = [2, 1, 1, 0]`
    

---

### **時間複雜度分析**

- **遍歷數組：** O(n)
- **二分搜索插入位置：** O(log⁡n)
- **總複雜度：** O(nlog⁡n)

---

### **總結**

這種單調棧解法利用了棧的有序性和二分搜索特性，能夠高效地計算每個元素右側比它小的數字個數，非常適合處理這類問題。