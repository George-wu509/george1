
lintcode 983

### 棒球游戏题目 (LintCode)

#### 题目编号：1096

**题目描述：** 你需要根据给定的操作数组计算棒球比赛的得分。比赛规则如下：

1. 每次操作是一个整数，表示本轮获得的积分。
2. "+" 表示本轮的积分是前两轮积分的总和。
3. "D" 表示本轮的积分是前一轮积分的两倍。
4. "C" 表示前一轮的积分无效，需要移除。
5. 最后得分是所有轮次积分的总和。

操作数组保证是有效的，即每个操作都符合上述规则。

---

#### 示例：

**输入：**  
ops = ["5", "-2", "4", "C", "D", "9", "+", "+"]

**输出：**  
27

**解释：**

1. 第 1 轮：得 5 分，总分为 [5]。
2. 第 2 轮：得 -2 分，总分为 [5, -2]。
3. 第 3 轮：得 4 分，总分为 [5, -2, 4]。
4. 第 4 轮：取消上一轮得分，总分为 [5, -2]。
5. 第 5 轮：得分为上一轮的两倍，即 -4，总分为 [5, -2, -4]。
6. 第 6 轮：得分为 9，总分为 [5, -2, -4, 9]。
7. 第 7 轮：得分为前两轮之和，即 -4 + 9 = 5，总分为 [5, -2, -4, 9, 5]。
8. 第 8 轮：得分为前两轮之和，即 9 + 5 = 14，总分为 [5, -2, -4, 9, 5, 14]。

最终得分为：5 + (-2) + (-4) + 9 + 5 + 14 = 27。

---

### 解法：使用栈

使用栈是因为栈可以非常方便地实现增删操作，同时保留前面轮次的得分。

---

#### 步骤详解：

1. **初始化一个栈：**  
    栈 `stack` 用来保存每轮的得分，初始为空。
    
2. **遍历操作数组：**  
    遍历数组中的每个操作，根据操作类型执行不同的逻辑：
    
    - **整数：** 直接将该轮的得分压入栈。
    - **"C"：** 表示无效前一轮的得分，从栈中弹出上一个得分。
    - **"D"：** 表示当前轮的得分是前一轮的两倍，将 `2 * stack[-1]` 压入栈。
    - **"+"：** 表示当前轮的得分是前两轮的总和，将 `stack[-1] + stack[-2]` 压入栈。
3. **累加总得分：**  
    遍历结束后，栈中的所有元素即为有效得分，计算它们的总和。
    

---

#### Python 代码实现：

```python
def calPoints(ops):
    stack = []  # 初始化一个栈

    for op in ops:
        if op == "C":
            # 移除上一个得分
            stack.pop()
        elif op == "D":
            # 当前得分是前一个得分的两倍
            stack.append(2 * stack[-1])
        elif op == "+":
            # 当前得分是前两个得分的和
            stack.append(stack[-1] + stack[-2])
        else:
            # 将整数得分压入栈
            stack.append(int(op))

    # 计算总得分
    return sum(stack)

# 测试
ops = ["5", "-2", "4", "C", "D", "9", "+", "+"]
print(calPoints(ops))  # 输出: 27

```

---

#### 代码运行过程：

- **操作："5"**  
    `stack = [5]`  
    得分：5
- **操作："-2"**  
    `stack = [5, -2]`  
    得分：5, -2
- **操作："4"**  
    `stack = [5, -2, 4]`  
    得分：5, -2, 4
- **操作："C"**  
    `stack = [5, -2]`  
    撤销上一轮得分 4
- **操作："D"**  
    `stack = [5, -2, -4]`  
    本轮得分是前一轮的两倍，即 -4
- **操作："9"**  
    `stack = [5, -2, -4, 9]`  
    得分：9
- **操作："+"**  
    `stack = [5, -2, -4, 9, 5]`  
    本轮得分是前两轮之和：-4 + 9 = 5
- **操作："+"**  
    `stack = [5, -2, -4, 9, 5, 14]`  
    本轮得分是前两轮之和：9 + 5 = 14

**最终结果：** `5 + (-2) + (-4) + 9 + 5 + 14 = 27`

---

#### 时间和空间复杂度分析：

- **时间复杂度：**  
    遍历操作数组一次，操作栈的增删操作是 O(1)O(1)O(1)，总时间复杂度为 O(n)O(n)O(n)。
    
- **空间复杂度：**  
    栈的最大空间为操作数组的长度，空间复杂度为 O(n)O(n)O(n)。
    

---

### 总结：

栈是解决此类问题的最佳选择，因为它可以高效地完成增删操作，且可以保存历史得分，方便实现“回退”操作和“前两轮得分”的计算。