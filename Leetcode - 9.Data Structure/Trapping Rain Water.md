
leetcode 363
给出 _n_ 个非负整数，代表一张X轴上每个区域宽度为 `1` 的海拔图, 计算这个海拔图最多能接住多少（面积）雨水。

### LintCode 363: Trapping Rain Water （接雨水）

---

#### **问题描述**

给定一个非负整数数组 `heights`，每个元素代表一个宽度为 1 的柱子的高度，计算这些柱子之间能接住的雨水总量。

---

#### **示例**

**输入：**

`heights = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]`

**输出：**
`6`

**解释：** 在索引 2 和 3 之间可以接住 1 单位的雨水，在索引 5 和 7 之间可以接住 5 单位的雨水，总共接住 6 单位的雨水。

![[Pasted image 20250217131448.png]]

---

### **解法：使用单调栈**

#### **核心思路**

利用 **单调递减栈**，以空间换时间，通过一次遍历快速计算出能够接住的雨水量。

1. **单调栈的特性：**
    
    - 栈中存储的是柱子的索引，柱子高度是单调递减的。
    - 当遇到一个高度大于栈顶高度的柱子时，说明可以形成一个凹槽用于接水。
2. **雨水的计算：**
    
    - 当栈中有两个柱子，且栈顶柱子高度小于当前柱子时，可以计算栈顶柱子与栈中下一个柱子之间的雨水。
    - 雨水的宽度：`当前柱子索引 - 栈中第二高柱子的索引 - 1`。
    - 雨水的高度：`min(当前柱子高度, 栈中第二高柱子高度) - 栈顶柱子高度`。

---

### **算法步骤**

1. **初始化：**
    
    - 一个空栈 `stack` 存储柱子的索引。
    - 一个变量 `water` 初始化为 `0`，表示总接水量。
2. **遍历数组：**
    
    - 对于每个柱子 `heights[i]`：
        - 如果当前柱子的高度大于栈顶柱子的高度，弹出栈顶元素，尝试计算雨水量。
            - 如果栈为空，则没有凹槽，跳过当前柱子。
            - 否则，计算雨水的宽度和高度，并累加到 `water`。
        - 将当前柱子索引 `i` 压入栈。
3. **返回结果：**
    
    - 遍历完成后，`water` 即为总雨水量。

---

Example:
**样例 1:**
```python
输入: [0,1,0]
输出: 0
```
**样例 2:**
```python
输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6
```


### **Python 实现代码**

```python
def trap_rain_water(heights):
    stack = []
    water = 0

    for i, h in enumerate(heights):
        while stack and heights[stack[-1]] < h:
            top = stack.pop()
            if not stack:
                break
            width = i - stack[-1] - 1
            height = min(h, heights[stack[-1]]) - heights[top]
            water += width * height
        stack.append(i)

    return water

# 测试
heights = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]
print(trap(heights))  # 输出: 6

```
pass

### **逐步解析**

#### **输入：**

`heights = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]`

#### **初始化：**

`stack = [] water = 0`

---

#### **遍历数组：**

##### **索引 0，柱子高度 0：**

- 栈为空，直接将索引 0 入栈。
- **更新：**

    `stack = [0]`
    

---

##### **索引 1，柱子高度 1：**

- 当前柱子高度 `1` > 栈顶柱子高度 `0`：
    - 弹出栈顶索引 `0`。
    - 栈为空，无法接水。
- 将索引 1 入栈。
- **更新：**

    `stack = [1]`
    

---

##### **索引 2，柱子高度 0：**

- 当前柱子高度 `0` <= 栈顶柱子高度 `1`，直接将索引 2 入栈。
- **更新：**

    `stack = [1, 2]`
    

---

##### **索引 3，柱子高度 2：**

- 当前柱子高度 `2` > 栈顶柱子高度 `0`：
    - 弹出栈顶索引 `2`。
    - 栈顶新的高度为 `1`：
        - 宽度：`3 - 1 - 1 = 1`
        - 高度：`min(2, 1) - 0 = 1`
        - 接水量：`1 * 1 = 1`
        - 累加到 `water`。
- 当前柱子高度 `2` > 栈顶柱子高度 `1`：
    - 弹出栈顶索引 `1`。
    - 栈为空，无法接水。
- 将索引 3 入栈。
- **更新：**

    `stack = [3] water = 1`
    

---

##### **索引 4，柱子高度 1：**

- 当前柱子高度 `1` <= 栈顶柱子高度 `2`，直接将索引 4 入栈。
- **更新：**

    `stack = [3, 4]`
    

---

##### **索引 5，柱子高度 0：**

- 当前柱子高度 `0` <= 栈顶柱子高度 `1`，直接将索引 5 入栈。
- **更新：**

    `stack = [3, 4, 5]`
    

---

##### **索引 6，柱子高度 1：**

- 当前柱子高度 `1` > 栈顶柱子高度 `0`：
    - 弹出栈顶索引 `5`。
    - 栈顶新的高度为 `1`：
        - 宽度：`6 - 4 - 1 = 1`
        - 高度：`min(1, 1) - 0 = 1`
        - 接水量：`1 * 1 = 1`
        - 累加到 `water`。
- 将索引 6 入栈。
- **更新：**

    `stack = [3, 4, 6] water = 2`
    

---

##### **索引 7，柱子高度 3：**

- 当前柱子高度 `3` > 栈顶柱子高度 `1`：
    - 弹出栈顶索引 `6`。
    - 栈顶新的高度为 `1`：
        - 宽度：`7 - 4 - 1 = 2`
        - 高度：`min(3, 1) - 1 = 0`（无雨水）。
- 当前柱子高度 `3` > 栈顶柱子高度 `2`：
    - 弹出栈顶索引 `4`。
    - 栈顶新的高度为 `2`：
        - 宽度：`7 - 3 - 1 = 3`
        - 高度：`min(3, 2) - 1 = 1`
        - 接水量：`3 * 1 = 3`
        - 累加到 `water`。
- 当前柱子高度 `3` > 栈顶柱子高度 `2`：
    - 弹出栈顶索引 `3`。
    - 栈为空，无法接水。
- 将索引 7 入栈。
- **更新：**

    `stack = [7] water = 6`
    

---

##### **索引 8 至索引 11：**

- 按同样逻辑处理，最后无法形成新的雨水接水。

---

#### **最终结果：**

`water = 6`

---

### 
### **总结**

1. **单调栈的使用：**
    
    - 栈中存储柱子索引，栈内高度单调递减。
    - 每次弹出栈顶时，计算柱子之间能接住的雨水。
2. **时间复杂度：**
    
    - 每个索引最多入栈和出栈一次，时间复杂度为 O(n)O(n)O(n)。
3. **空间复杂度：**
    
    - 栈的空间复杂度为 O(n)O(n)O(n)。