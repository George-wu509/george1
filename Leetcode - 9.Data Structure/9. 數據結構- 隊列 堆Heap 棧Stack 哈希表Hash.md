
<1>-----------------------------------------------------------------——————-
**數組 (Array)**

前綴和數組 (PreSum)

字符串 (String)


<2>-----------------------------------------------------------------——————- 
**链表 (linked list):** Method: **next**

可以用head.**next** (python 要先加class ListNode)

L=1->2->3

L.head = 1 —> L.next=2, L.next.next=3

**雙向链表 (Doubly linked list) [2]:** Method: next, pre

可用head.**next** and head.**pre**, 也有tail


<3>-----------------------------------------------------------------——————- 
**隊列 (queue): 先進先出 [3][5]:** Method: **put, get**

from queue import Queue

queue = Queue_bylist() queue.put(12) queue.put(34) —> queue = [12,34] queue.get() —> 12

queue.pop() —> queue = [34]

**單調隊列 (Monotone queue)**

**雙向隊列 (deque / double-ended queue) [4][5]:** Method: **append, appendleft, pop, popleft**

d = collections.deque()

d.append(1)

d.appendleft(2)

d.append(3) —> d = [2,1,3]

d.popleft() —> d=[1,3]

d.pop() —> d=[1]


<4>-----------------------------------------------------------------——————- **
栈 (Stack): 後進先出[7]:** Method: **push, pop**

(python 要先加created class Stack)

S = Stack() S.push(12) S.push(34) —> S = [12,34] S.pop() —> S=[12]

**單調棧 (Monotonic stack)** [16][17][18] 


<5>-----------------------------------------------------------------——————- 
**堆 (Heap) [10]** (python 要先加class TreeNode): Method: **push, pop, top**

完全二叉樹 + 最大堆/最小堆 (每個父節點大於/小於節點), 不是二叉搜尋樹

a = [12, 2, 4, 5, 63, 3, 2]

heapq.heappush(a,123) → a = [12, 2, 4, 5, 63, 3, 2, 123]

b = heapq.heappop(a) → b = 12

HashHeap

<6>-----------------------------------------------------------------——————- 
樹 (Tree) (python 要先加class TreeNode) [9]

**二叉樹 (Binary Tree)**

```
 滿二叉樹 full:  如果除了葉子節點, 其他節點數都是2

 完全二叉樹 complete:  如果除了最後一層節點其它為滿二叉樹, 且最後一層節點依次從左到右

 完美二叉樹 perfect:  每個節點數都是2

 平衡二叉樹 balanced:   左右子树的高度之差<= 1 (AVL tree = 平衡+二叉搜索樹)
```

二叉搜尋樹 (Binary Search Tree)

```
 左子樹所有節點小於根結點, 右子樹所有節點大於根結點
```

圖 (Graph) 二分圖 (Bipartite graph)

<7>-----------------------------------------------------------------——————- **
哈希表 (Hash table)** [11]

```
 Hash table, Hash Map, Hash Set?
```

import heapq

heap=[] heapq.heappush(heap, (array[0], index, 0)) heapq.heappop(heap) val, x, y = heap[0]

**字典樹 (Trie) [12]:**

**並查集 (Union find) [13][14]:**

**樹狀數組 (Binary Indexed Tree):**

**線段樹 (Segment tree):**

**平衡樹 (AVL樹) (Balanced Tree):** 
-----------------------------------------------------------------——————-

class ListNode:

```
 def __ init __ (self, head=0, next=None):

      self.val = val

      self.next = next
```

class TreeNode:

```
def __ init __(self, val):

     self.val = val

     self.left, self.right = None, None
```

-----------------------------------------------------------------——————-

- All: [1]
- Reference:
- [1] 图解！24张图彻底弄懂九大常见数据结构！[https://cloud.tencent.com/developer/article/1634155](https://cloud.tencent.com/developer/article/1634155)
- [2] 一文多图搞懂数据结构的双链表！[https://cloud.tencent.com/developer/article/1511615](https://cloud.tencent.com/developer/article/1511615)
- [3] 队列（Queue）-Python实现 [https://zhuanlan.zhihu.com/p/100887684](https://zhuanlan.zhihu.com/p/100887684)
- [4] python 双端队列：collections.deque 基本方法总结 [https://blog.csdn.net/weixin_37589575/article/details/106630235](https://blog.csdn.net/weixin_37589575/article/details/106630235)
- [5] Python中的Queue和deque [https://zhuanlan.zhihu.com/p/146393319](https://zhuanlan.zhihu.com/p/146393319)
- [6] 5. 資料結構https://docs.python.org/zh-tw/3/tutorial/datastructures.html#data-structures
- [7] 【Python】Stack(堆疊) 資料結構實作 [https://lovedrinkcafe.com/python-stack-data-structure/](https://lovedrinkcafe.com/python-stack-data-structure/)
- [8][探索 5 分鐘] stack 與 heap 的底層概念 [https://nwpie.blogspot.com/2017/05/5-stack-heap.html](https://nwpie.blogspot.com/2017/05/5-stack-heap.html)
- [9] 最全二叉树：完整详解二叉树的遍历以及完全二叉树等6种二叉树 [https://zhuanlan.zhihu.com/p/262268745](https://zhuanlan.zhihu.com/p/262268745)
- [10] python模块之heapq [https://zhuanlan.zhihu.com/p/548036132](https://zhuanlan.zhihu.com/p/548036132)
- [11] 来吧！一文彻底搞定哈希表！[https://zhuanlan.zhihu.com/p/95156642](https://zhuanlan.zhihu.com/p/95156642)
- [12] 浅谈Trie树（字典树）[https://zhuanlan.zhihu.com/p/68447845](https://zhuanlan.zhihu.com/p/68447845)
- [13] 并查集的介绍和优化 [https://zhuanlan.zhihu.com/p/355527736](https://zhuanlan.zhihu.com/p/355527736)
- [14] UnionFind 并查集 [https://zhuanlan.zhihu.com/p/475756414](https://zhuanlan.zhihu.com/p/475756414)
- [15] 单调栈及其应用 [https://zhuanlan.zhihu.com/p/101785785](https://zhuanlan.zhihu.com/p/101785785)
- [16] 【learning】 单调队列与单调栈用法详解 [https://www.cnblogs.com/alphainf/p/8495272.html?fbclid=IwAR2d4crYIqYNbve7W2WfeIK3xNO9ZHObpTwlWvf0q_0SO9V_1JZ-5gaplb8](https://www.cnblogs.com/alphainf/p/8495272.html?fbclid=IwAR2d4crYIqYNbve7W2WfeIK3xNO9ZHObpTwlWvf0q_0SO9V_1JZ-5gaplb8)
- [17] 单调栈一点小心得 | 用最简单的动图和例题解释一下 [https://www.51cto.com/article/675862.html?fbclid=IwAR2Aote1HzhhyJqr5hSvwvw1YNJ1vgaMyz0NXxlLKar1z7c0jicR62GkNqM](https://www.51cto.com/article/675862.html?fbclid=IwAR2Aote1HzhhyJqr5hSvwvw1YNJ1vgaMyz0NXxlLKar1z7c0jicR62GkNqM)
- [18] fucking-algorithm/数据结构系列/单调栈.md [](https://github.com/labuladong/fucking-algorithm/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E5%8D%95%E8%B0%83%E6%A0%88.md)[https://github.com/labuladong/fucking-algorithm/blob/master/数据结构系列/单调栈.md](https://github.com/labuladong/fucking-algorithm/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E5%8D%95%E8%B0%83%E6%A0%88.md)
- [19] 一文读懂扫描线算法 [https://zhuanlan.zhihu.com/p/103616664](https://zhuanlan.zhihu.com/p/103616664)
- [20] 堆(heap) [https://www.digolds.cn/article/00160839101309810dafe4c72b24d0a906021c736a5cdd3000](https://www.digolds.cn/article/00160839101309810dafe4c72b24d0a906021c736a5cdd3000)
- [21] 线段树（segment tree)，看这一篇就够了 [https://blog.csdn.net/Yaokai_AssultMaster/article/details/79599809](https://blog.csdn.net/Yaokai_AssultMaster/article/details/79599809)
- [22] **什么是平衡二叉树（AVL）**[https://zhuanlan.zhihu.com/p/56066942](https://zhuanlan.zhihu.com/p/56066942)

## **Lintcode模板 - 堆 Heap**

## **使用条件**

- 找最大值或者最小值（60%）
- 找第 k 大（ pop k 次 复杂度 O(nlogk) ）（50%）
- 要求 logn 时间对数据进行操作（40%）

## **堆不能解决的问题**

- 查询比某个数大的最小值/最接近的值（平衡排序二叉树 Balanced BST 才可以解决）
- 找某段区间的最大值最小值（线段树 SegmentTree 可以解决）
- O(n)_O_(_n_) 找第 k 大 (使用快排中的 partition 操作)

**代码模板**

带删除特定元素功能的堆
![[Pasted image 20240914171548.png]]

## **Lintcode模板 - 并查集 Union Find**

## **使用条件**

- 需要查询图的连通状况的问题
- 需要支持快速合并两个集合的问题

## **复杂度**

- 时间复杂度 union _O_(1), find _O_(1)
- 空间复杂度 _O_(_n_)

**代码模板**
![[Pasted image 20240914171610.png]]

![[Pasted image 20240914171632.png]]
## **Lintcode模板 - 字典树 Trie**

## **使用条件**

- 需要查询包含某个前缀的单词 / 字符串是否存在
- 字符矩阵中找单词的问题

## **复杂度**

- 时间复杂度：_O_(_L_) 增删查改
- 空间复杂度：_O_(_N_∗_L_) N 是单词书、L 是单词长度
- 
![[Pasted image 20240914171708.png]]![[Pasted image 20240914171728.png]]

## **Lintcode模板 - LRU 缓存**

## **复杂度**

- 时间复杂度：get _O_(1)，set _O_(1)
- 空间复杂度：_O_(_n_)

**代码模板**
![[Pasted image 20240914171800.png]]
![[Pasted image 20240914171826.png]]

