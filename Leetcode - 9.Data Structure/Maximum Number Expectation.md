Lintcode 347
小强得到了长度为n的序列，但他只对非常大的数字感兴趣，因此随机选择这个序列的一个连续子序列，并求这个序列的最大值，请告诉他这个最大值的期望是多少。

解釋:
列出序列 [ 1,2,3 ] 所有的子序列譬如[1], [1,2].....等, 計算所有子序列的最大值, 然後算這些最大值平均 

**样例 1:**
```python
"""
输入: [1, 2, 3]
输出: 2.33
说明: 
一共有六个子区间，分别是 [1], [2], [3], [1, 2], [2, 3], [1, 2, 3]
分别的最大值是 1, 2, 3, 2, 3, 3
每一个最大值出现的概率是1 / 6，
所以最大值期望是 7 / 3,
得到答案: 2.33
```
**样例 2:**
```python
"""
输入: [2, 3, 2]
输出: 2.67
说明: 
一共有六个子区间，分别是 : [2], [3], [2], [2, 3], [3, 2], [2, 3, 2]
分别的最大值是 :2, 3, 2, 3, 3, 3
每一个最大值出现的概率是 1 / 6，
所以最大值期望是 8 / 3,
得到答案 : 2.67
```


```python
def expect_maximum(self, nums: List[int]) -> float:
	dp, stack = [0], []
	for i in range(len(nums)):
		while stack and nums[stack[-1]] <= nums[i]:
			stack.pop(-1)
		length = i - stack[-1] if stack else i + 1
		dp.append(length * nums[i] + dp[i + 1 - length])
		stack.append(i)
	count = len(nums) * (len(nums) + 1) // 2
	return sum(dp) / count
```
pass


### **LintCode 347 - Maximum Number Expectation**

#### **解法分析**

本題的目標是計算數組 `nums` **所有連續子數組的最大值的期望值**。  
具體來說：

- 我們要對所有可能的連續子數組，計算其最大值，然後取平均。

由於暴力解法（列舉所有子數組）會導致 **O(N²) 時間複雜度**，我們改用 **單調棧 + 動態規劃 (Monotonic Stack + DP)** 來高效計算。

---

### **解法思路**

#### **1. 使用單調棧 (Monotonic Stack) 來加速計算子數組最大值的貢獻**

- **對於 `nums[i]`，求 `nums[i]` 在多少個子數組內是最大值**：
    
    - 若 `nums[i]` 是 **區間 [j, i]** 的最大值，則 `nums[i]` 在這個子數組內對期望值有貢獻。
    - 我們希望計算所有這樣的區間數量，然後加總 `nums[i]` 的貢獻。
- **單調棧 (Monotonic Stack)** 幫助我們確定 `nums[i]` 最早出現的位置：
    
    - 若 `nums[i]` 是 **遞增的**，則 `nums[i]` 影響較多的區間數量。
    - 若 `nums[i]` 遇到比它小的數，則代表 `nums[i]` 能貢獻給更長的子數組。

#### **2. 動態規劃 `dp[i]`**

- 定義 `dp[i]` 為 **考慮到 `nums[i]` 之後的最大值貢獻總和**：
    - `dp[i] = length * nums[i] + dp[i + 1 - length]`
    - `length` 是 `nums[i]` 作為最大值時可以影響的區間長度。

#### **3. 計算結果**

- 計算所有 `dp[i]` 值的總和，再除以 **所有可能的子數組數量**：
    - 所有子數組數量 `count = n * (n + 1) / 2`
    - **期望值 = `sum(dp) / count`**

---

### **變數說明**

|變數名稱|說明|
|---|---|
|`nums`|輸入的數組|
|`dp`|存儲考慮到 `nums[i]` 之後的最大值貢獻總和|
|`stack`|單調遞減棧，存儲索引，幫助確定 `nums[i]` 影響的區間長度|
|`length`|`nums[i]` 在多少個子數組內是最大值|
|`count`|總子數組數量|

---

### **範例**

#### **輸入**

python

複製編輯

`nums = [1, 2, 3]`

#### **處理流程**

1. **初始狀態**
    
    ini
    
    複製編輯
    
    `dp = [0] stack = []`
    
2. **遍歷 `nums`**
    
    - `i = 0, nums[0] = 1`
        - `stack` 為空，`length = 1`
        - `dp[1] = 1 * 1 + dp[0] = 1`
        - `stack = [0]`
    - `i = 1, nums[1] = 2`
        - `nums[0] <= nums[1]`，`stack.pop()`
        - `stack` 為空，`length = 2`
        - `dp[2] = 2 * 2 + dp[0] = 4`
        - `stack = [1]`
    - `i = 2, nums[2] = 3`
        - `nums[1] <= nums[2]`，`stack.pop()`
        - `stack` 為空，`length = 3`
        - `dp[3] = 3 * 3 + dp[0] = 9`
        - `stack = [2]`
3. **計算期望值**
    
    bash
    
    複製編輯
    
    `count = 3 * (3 + 1) / 2 = 6 sum(dp) = 1 + 4 + 9 = 14 期望值 = 14 / 6 = 2.33`
    

#### **輸出**

python

複製編輯

`2.33`

---

### **時間與空間複雜度分析**

#### **時間複雜度**

- **單調棧** 保證每個元素最多進棧、出棧一次，時間複雜度為 **O(N)**。
- **遍歷 `nums` 並計算 `dp`** 也為 **O(N)**。
- **計算總和與期望值** 為 **O(N)**。
- **總時間複雜度：O(N)**。

#### **空間複雜度**

- 需要存儲 `dp` 陣列，大小為 **O(N)**。
- 需要 `stack`，最壞情況下存儲 `N` 個元素，大小為 **O(N)**。
- **總空間複雜度：O(N)**。

---

### **其他解法想法**

4. **暴力解法 (O(N²))**
    
    - 枚舉所有子數組並求最大值，再計算平均。
    - **時間複雜度 O(N²)**，適用於 `N` 很小的情況。
5. **動態規劃 (O(N²))**
    
    - 使用 `dp[i][j]` 表示 `nums[i:j]` 的最大值，通過 **遞推計算所有子數組的最大值**。
    - **時間複雜度 O(N²)**。
6. **分治法 (O(N log N))**
    
    - 利用線段樹 **快速查詢區間最大值** 來計算所有子數組的貢獻。
    - **時間複雜度 O(N log N)**。

---

### **總結**

- **最優解法：單調棧 + 動態規劃 (O(N) 時間, O(N) 空間)**
- **若 `N` 很小，可使用暴力解法 (O(N²))**。
- **若 `N` 很大且需要快查區間最大值，可使用線段樹 (O(N log N))**。