Lintcode 285
小Q在周末的时候和他的小伙伴来到大城市逛街，一条步行街上有很多高楼，共有n座高楼排成一行，楼高用arr表示。  
小Q从第一栋一直走到了最后一栋，小Q从来都没有见到这么多的楼，所以他想知道他在每栋楼的位置处能看到多少栋楼呢？（当前面的楼的高度大于等于后面的楼时，后面的楼将被挡住）

```python
"""
输入:[5,3,8,3,2,5]
输出:[3,3,5,4,4,4]
解释:
当小Q处于位置0时，他能看到位置0，1，2的3栋高楼。
当小Q位于位置1时，他能看到位置0，1，2的3栋高楼。
当小Q处于位置2时，他可以向前看到位置0，1处的楼，向后看到位置3,5处的楼，加上第3栋楼，共可看到5栋楼。
当小Q处于位置3时，他能看到位置2，3，4，5的4栋高楼。
当小Q处于位置4时，他能看到位置2，3，4，5的4栋高楼。
当小Q处于位置5时，他能看到位置2，3，4，5的4栋高楼。
```


```python
    def tall_building(self, arr):
        n = len(arr);
        left = [0 for i in range(105000)];
        right = [0 for i in range(105000)];
        left_sum = [0 for i in range(105000)];
        right_sum = [0 for i in range(105000)];
        left[0] = -1;
        for i in range(1, n):
            x = i-1;
            while x > -1 and arr[x] <= arr[i]:
                x = left[x];
            left[i] = x;
        right[n-1] = n;
        for i in range(n-2, -1, -1):
            x = i + 1;
            while x < n and arr[x] <= arr[i]:
                x = right[x];
            right[i] = x;
        for i in range(0, n):
            if left[i] == -1:
                left_sum[i] = 1;
            else:
                left_sum[i] = left_sum[left[i]] + 1;
        for i in range(n-1, -1, -1):
            if right[i] == n:
                right_sum[i] = 1;
            else:
                right_sum[i] = right_sum[right[i]] + 1;
        ans = [0 for i in range(n)]
        for i in range(0,n):
            x = 0;
            if i-1 >= 0:
                x += left_sum[i-1];
            if i+1 < n:
                x += right_sum[i+1];
            ans[i] = x+1;
        return ans;
```
pass


### **LintCode 285 - Tall Building**

#### **解法分析**

本題的目標是對於每棟大樓 `arr[i]`，計算可以看到的**相鄰大樓總數（包含自己）**。  
具體來說：

- **向左看**：找出 `arr[i]` 向左延伸的 **可見大樓數量**。
- **向右看**：找出 `arr[i]` 向右延伸的 **可見大樓數量**。

**規則：**

1. `arr[i]` **只能看到比它矮或相等的樓**，直到遇到 **第一個更高的樓** 或 **邊界** 為止。
2. 若 `arr[i]` 是某範圍內最高的，它可以看到所有比它矮的樓。
3. `arr[i]` 本身也算在可見範圍內，因此結果至少為 `1`。

---

### **解法思路**

**使用單調棧 (Monotonic Stack) 來加速查找左邊與右邊的可見範圍**

4. **計算 `left[i]`**（`arr[i]` **左側可見的第一個比它高的建築索引**）
    
    - 逆序遍歷 `arr`，當 `arr[i]` 左側的樓 `arr[j]`（`j < i`）比 `arr[i]` **矮**，就一直往左查找直到找到比 `arr[i]` 高的樓。
5. **計算 `right[i]`**（`arr[i]` **右側可見的第一個比它高的建築索引**）
    
    - 同樣方法從右向左計算，當 `arr[i]` 右側的樓 `arr[j]`（`j > i`）比 `arr[i]` **矮**，就一直往右查找直到找到比 `arr[i]` 高的樓。
6. **計算 `left_sum[i]`**（`arr[i]` **可以看到的左側建築數量**）
    
    - 若 `arr[i]` 左側沒有比它更高的樓（`left[i] == -1`），則 `left_sum[i] = 1`
    - 否則 `left_sum[i] = left_sum[left[i]] + 1`（遞推計算左側建築數量）
7. **計算 `right_sum[i]`**（`arr[i]` **可以看到的右側建築數量**）
    
    - 若 `arr[i]` 右側沒有比它更高的樓（`right[i] == n`），則 `right_sum[i] = 1`
    - 否則 `right_sum[i] = right_sum[right[i]] + 1`（遞推計算右側建築數量）
8. **計算最終結果 `ans[i]`**
    
    - `ans[i] = left_sum[i-1] + right_sum[i+1] + 1`（包含自己）
    - 若 `i-1 < 0` 或 `i+1 >= n`，則省略該部分。

---

### **變數說明**

|變數名稱|說明|
|---|---|
|`arr`|輸入的建築高度數組|
|`n`|`arr` 的長度|
|`left[i]`|`arr[i]` **左側可見的第一個比它高的建築索引**|
|`right[i]`|`arr[i]` **右側可見的第一個比它高的建築索引**|
|`left_sum[i]`|`arr[i]` **能看到的左側建築數量**|
|`right_sum[i]`|`arr[i]` **能看到的右側建築數量**|
|`ans[i]`|`arr[i]` **可以看到的總建築數量（包含自己）**|

---

### **範例**

#### **輸入**

`arr = [5, 3, 8, 3, 2, 5]`

#### **處理流程**

9. **計算 `left[i]`**
    
    ini
    
    複製編輯
    
    `left = [-1, 0, -1, 2, 3, 2]`
    
    - `arr[0] = 5`，左側無樓，`left[0] = -1`
    - `arr[1] = 3`，左側 `arr[0] = 5`，可見，`left[1] = 0`
    - `arr[2] = 8`，無更高的樓，`left[2] = -1`
    - `arr[3] = 3`，左側 `arr[2] = 8`，可見，`left[3] = 2`
    - `arr[4] = 2`，左側 `arr[3] = 3`，可見，`left[4] = 3`
    - `arr[5] = 5`，左側 `arr[2] = 8`，可見，`left[5] = 2`
10. **計算 `right[i]`**
    
    ini
    
    複製編輯
    
    `right = [2, 2, 6, 5, 5, 6]`
    
    - `arr[0] = 5`，右側 `arr[2] = 8`，可見，`right[0] = 2`
    - `arr[1] = 3`，右側 `arr[2] = 8`，可見，`right[1] = 2`
    - `arr[2] = 8`，無更高的樓，`right[2] = 6`
    - `arr[3] = 3`，右側 `arr[5] = 5`，可見，`right[3] = 5`
    - `arr[4] = 2`，右側 `arr[5] = 5`，可見，`right[4] = 5`
    - `arr[5] = 5`，無更高的樓，`right[5] = 6`
11. **計算 `left_sum[i]`**
    
    ini
    
    複製編輯
    
    `left_sum = [1, 2, 1, 2, 3, 2]`
    
12. **計算 `right_sum[i]`**
    
    ini
    
    複製編輯
    
    `right_sum = [1, 1, 1, 2, 3, 2]`
    
13. **計算 `ans[i]`**
    
    ini
    
    複製編輯
    
    `ans = [1 + 1, 2 + 1, 1 + 1, 2 + 3 + 1, 3 + 2 + 1, 2 + 1] ans = [2, 3, 2, 6, 6, 3]`
    

#### **輸出**

python

複製編輯

`[2, 3, 2, 6, 6, 3]`

---

### **時間與空間複雜度分析**

#### **時間複雜度**

- **計算 `left[i]` 和 `right[i]`** 使用 **單調棧**，每個元素最多進棧、出棧一次 **O(N)**
- **計算 `left_sum[i]` 和 `right_sum[i]`** **O(N)**
- **計算 `ans[i]`** **O(N)**
- **總時間複雜度：O(N)**。

#### **空間複雜度**

- `left`、`right`、`left_sum`、`right_sum`、`ans` 皆為 **O(N)**
- **總空間複雜度：O(N)**。

---

### **其他解法想法**

14. **暴力解法 (O(N²))**
    
    - 對於每個 `arr[i]`，分別向左、向右遍歷找比它大的建築。
    - **時間複雜度 O(N²)**，不適用於大數據。
15. **分治法 (O(N log N))**
    
    - 利用 **線段樹** 來查詢範圍內的最大值，減少重複計算。
    - **時間複雜度 O(N log N)**。

---

### **總結**

- **最優解法：單調棧 + 遞推計算 (O(N) 時間, O(N) 空間)**
- **若 `N` 很小，可使用暴力解法 (O(N²))**
- **若需要頻繁查詢，可考慮線段樹 (O(N log N))**