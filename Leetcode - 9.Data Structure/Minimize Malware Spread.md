Lintcode 1718
在一个节点网络中，当且仅当 `graph[i][j] = 1` 时，每个节点 `i` 会与另一个节点 `j` 直接连接。

一些节点 `initial` 最初被恶意软件感染。只要两个节点直接连接，并且其中至少有一个节点被恶意软件感染，那么这两个节点都将被恶意软件感染。这种恶意软件的传播会一直持续直到没有更多的节点可以被这种方式感染。

假设 `M(initial)` 是在恶意软件停止传播之后，整个网络中被恶意软件感染的最终节点数。

我们可以从初始列表中删除一个节点。如果移除这一节点将最小化 `M(initial)`， 则返回该节点。如果有多个节点满足条件，就返回索引最小的节点。

请注意，如果某个节点已从受感染节点的列表 `initial` 中删除，它以后可能仍然因恶意软件传播而受到感染。


**样例 1：**
```python
"""
输入：graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
输出：0
```
**样例 2：**
```python
"""
输入：graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
输出：0
```
**样例 3：**
```python
"""
输入：graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
输出：1
```


```python
from typing import (
    List,
)

class DSU:
    def __init__(self, N):
        self.p = list(range(N))
        self.sz = [1] * N

    def find(self, x):
        if self.p[x] != x:
            self.p[x] = self.find(self.p[x])
        return self.p[x]

    def union(self, x, y):
        xr = self.find(x)
        yr = self.find(y)
        self.p[xr] = yr
        self.sz[yr] += self.sz[xr]

    def size(self, x):
        return self.sz[self.find(x)]

class Solution:
    """
    @param graph: the node graph
    @param initial: the infected node
    @return: the node index
    """
    def min_malware_spread(self, graph: List[List[int]], initial: List[int]) -> int:
        # write your code here
        dsu = DSU(len(graph))

        for j, row in enumerate(graph):
            for i in range(j):
                if row[i]:
                    dsu.union(i, j)

        count = collections.Counter(dsu.find(u) for u in initial)
        ans = (-1, min(initial))
        for node in initial:
            root = dsu.find(node)
            if count[root] == 1:  # unique color
                if dsu.size(root) > ans[0]:
                    ans = dsu.size(root), node
                elif dsu.size(root) == ans[0] and node < ans[1]:
                    ans = dsu.size(root), node

        return ans[1]
```
pass