Lintcode 166
找到单链表的倒数第n个节点，保证链表中节点的最少数量为n。

```python
"""
样例 1:
	输入: list = 3->2->1->5->null, n = 2
	输出: 1


样例 2:
	输入: list  = 1->2->3->null, n = 3
	输出: 1
```


```python
def nth_to_last(self, head, n):
	if head is None or n < 1:
		return None
	cur = head.next
	while cur is not None:
		cur.pre = head
		cur = cur.next
		head = head.next
	n -= 1
	while n > 0:
		head = head.pre
		n -= 1
	return head
```
pass


## **LintCode 166: Nth to Last Node in List**

### **解法分析**

本題目要求 **找出倒數第 `n` 個節點**，也就是從鏈表尾部往回數 `n` 個節點並返回該節點。

---

### **解法思路**

1. **檢查輸入條件**
    
    - 若 `head` 為 `None`（即空鏈表）或 `n < 1`（無效輸入），則直接返回 `None`。
2. **構建 `pre` 指針**
    
    - 我們遍歷鏈表，**為每個節點額外建立 `pre` 指針**，用來指向前一個節點。
    - 這個步驟相當於構建 **雙向鏈表（Doubly Linked List）**。
3. **倒數 `n`**
    
    - 先將 `n` 減 1，然後利用 `pre` 指針往回移動 `n` 步，即可找到倒數第 `n` 個節點。

---

### **變數表**

|變數名稱|角色|作用|初始值|變化過程|
|---|---|---|---|---|
|`head`|遍歷指標|指向當前節點|`head`|先遍歷整個鏈表構建 `pre`，再倒退 `n` 步|
|`cur`|遍歷指標|構建 `pre` 指針的輔助變數|`head.next`|逐步遍歷到 `None`|
|`n`|計數變數|追蹤倒數 `n`|`n`|每次往回移動 `head` 時減 1|

---

### **時間與空間複雜度分析**

#### **時間複雜度：O(n)**

- **第一輪遍歷**：從頭到尾走一遍，建立 `pre` 指針（O(n)）。
- **第二輪遍歷**：從尾部往回走 `n` 步（O(n)）。
- **總時間複雜度** = **O(n) + O(n) = O(n)**。

#### **空間複雜度：O(1)**

- 只使用額外的變數來存指針，沒有額外的數據結構，因此 **空間複雜度為 O(1)**。

---

### **其他解法**

4. **雙指針法（Two Pointers, O(n) 時間, O(1) 空間）**
    
    - 設置 **快指針（fast）** 和 **慢指針（slow）**，讓快指針先走 `n` 步，然後兩者同步前進，當快指針到 `null` 時，慢指針剛好在倒數第 `n` 個節點。
5. **棧方法（Stack, O(n) 時間, O(n) 空間）**
    
    - 使用 **堆疊（Stack）** 先將所有節點壓入棧中，然後彈出 `n` 次，最後返回彈出的節點。
6. **計算長度（O(n) 時間, O(1) 空間）**
    
    - **先遍歷一次獲取長度** `L`，然後再次遍歷 **前進 L-n 步**，即可找到倒數第 `n` 個節點。

---

### **結論**

- **最佳解法為雙指針法**，因為它只需要一次遍歷（O(n) 時間）且不需要額外空間（O(1)）。
- 本解法雖然有效，但 **使用了 `pre` 指針來回移動，並沒有明顯優勢**，比雙指針法多了一次遍歷，因此不如雙指針法高效。