Lintcode 142
用 O(_1_) 时间检测整数 _n_ 是否是 _2_ 的幂次。

样例

`n=4`，返回 `true`;

`n=5`，返回 `false`.


```python
def check_power_of2(self, n):
	return n > 0 and (n & (n - 1)) == 0
```
pass

## **2. 位運算解法 (`n & (n - 1) == 0`)**

**核心公式**

n 是 2 的冪  ⟺  n>0 且 (n&(n−1))==0n \text{ 是 2 的冪} \iff n > 0 \text{ 且 } (n \& (n - 1)) == 0n 是 2 的冪⟺n>0 且 (n&(n−1))==0

### **為何 `(n & (n - 1)) == 0` 可以判斷 2 的冪？**

- **2 的冪的二進制表示**
    
    - `1`: `0001`
    - `2`: `0010`
    - `4`: `0100`
    - `8`: `1000`
    - **特性：** 只有 **1 個 `1`，其餘皆為 `0`。
- **`n - 1` 會影響 `1` 位**
    
    - `1 (0001) - 1 = 0000`
    - `2 (0010) - 1 = 0001`
    - `4 (0100) - 1 = 0011`
    - `8 (1000) - 1 = 0111`
    - **特性：** `n & (n - 1) == 0` 只對 **2 的冪成立**。

---

## **3. 最佳解法 (Python 位運算)**

python

複製編輯

`def check_power_of2(n):     return n > 0 and (n & (n - 1)) == 0`

### **時間與空間複雜度**

- **時間複雜度：** `O(1)`，因為只需要 **1 次位運算**。
- **空間複雜度：** `O(1)`，沒有額外空間開銷。

---

## **4. 測試範例**

|`n`|二進制|`n - 1`|`(n & (n - 1))`|結果|
|---|---|---|---|---|
|`1`|`0001`|`0000`|`0000`|✅ `True`|
|`2`|`0010`|`0001`|`0000`|✅ `True`|
|`4`|`0100`|`0011`|`0000`|✅ `True`|
|`8`|`1000`|`0111`|`0000`|✅ `True`|
|`3`|`0011`|`0010`|`0010`|❌ `False`|
|`5`|`0101`|`0100`|`0100`|❌ `False`|

---

## **5. 與原解法比較**

|**方法**|**時間複雜度**|**原理**|**是否最優**|
|---|---|---|---|
|**`O(log n)` 左移 (`ans <<= 1`)**|`O(log n)`|逐次檢查 `2^i == n`|❌|
|**`O(1)` 位運算 (`n & (n - 1) == 0`)**|`O(1)`|利用二進制性質|✅|

---

## **6. 總結**

✅ **最佳解法：使用 `(n & (n - 1)) == 0`，時間 `O(1)`，最有效率！** 🚀  
❌ **原解法 (`ans <<= 1`) 是 `O(log n)`，較慢，不建議使用。**




## **LintCode 142: O(1) Check Power of 2 解法分析**

### **解法核心**

本題要求判斷一個整數 `n` 是否是 **2 的冪次方**，即是否存在某個整數 `k` 使得：

$n = 2^k$

例如：

- `1` (2⁰) 是 2 的冪次方。
- `2` (2¹) 是 2 的冪次方。
- `3` 不是 2 的冪次方。
- `4` (2²) 是 2 的冪次方。

---

## **解法步驟**

**位運算 (`Bitwise Operations`)**

- **O(1) 檢查方法**
    - 2 的冪次方數的 **二進制表示中只有一個 `1`**，例如：
```python
1  -> 0001
2  -> 0010
4  -> 0100
8  -> 1000
```
        
    - **可以用 `n & (n - 1) == 0` 來判斷**：
        - `n-1` 會將 `n` 的唯一 `1` 變成 `0`，並將其後所有 `0` 變成 `1`。
        - 這樣 `n & (n-1)` 一定為 `0`，例如：
```python
8  ->  1000
7  ->  0111
8 & 7 -> 0000 (== 0)
```
        - **條件：`n > 0`，否則 `0 & (-1) != 0`。**
    - **時間複雜度 `O(1)`，因為只有一次位運算。**

---

### **變數定義**

|變數名稱|作用|
|---|---|
|`n`|目標數字，判斷是否為 2 的冪次方|
|`ans`|從 `1` 開始，逐步左移 (`<<`) 來生成 `2^k`|
|`i`|迴圈計數器，最多 31 次 (`0~30`)，因為 `2^30 ≈ 10^9`|

---

## **具體範例**

### **範例 1**

`輸入: n = 8`

|迭代步驟|`ans` (`2^i`)|`n == ans`|
|---|---|---|
|`i = 0`|`1` (2⁰)|`8 == 1` → `False`|
|`i = 1`|`2` (2¹)|`8 == 2` → `False`|
|`i = 2`|`4` (2²)|`8 == 4` → `False`|
|`i = 3`|`8` (2³)|`8 == 8` → `True`|
|**輸出：`True`**|||

---

### **範例 2**

text

複製編輯

`輸入: n = 10`

|迭代步驟|`ans` (`2^i`)|`n == ans`|
|---|---|---|
|`i = 0`|`1` (2⁰)|`10 == 1` → `False`|
|`i = 1`|`2` (2¹)|`10 == 2` → `False`|
|`i = 2`|`4` (2²)|`10 == 4` → `False`|
|`i = 3`|`8` (2³)|`10 == 8` → `False`|
|`i = 4`|`16` (2⁴)|`10 == 16` → `False` (已超過 10，結束)|
|**輸出：`False`**|||

---

## **時間與空間複雜度分析**

### **時間複雜度**

1. **位運算 (`O(1)`)**
    - `n & (n - 1) == 0` 只需要一次運算，時間複雜度為 **`O(1)`**。
2. **迴圈 (`O(log n)`)**
    - 若使用 `while` 來檢查是否為 `2^k`，最多需要 `O(log n)` 次計算，因為 `2^30 ≈ 10^9`。
    - 但 `log n` 在 `n ≤ 10^9` 的情況下，最多 30 次，因此也很快。

### **空間複雜度**

- **`O(1)`**，只使用了少量變數 (`ans`, `i`, `n`)。

---

## **其他解法 (不寫 Code)**

1. **位運算 `O(1)`**
    
    - 使用 `n & (n - 1) == 0` 判斷：
        - **`(n & (n - 1)) == 0` 且 `n > 0`**
        - **最快的解法**
2. **遞迴除法 (`O(log n)`)**
    
    - 若 `n % 2 == 0` 則繼續 `n //= 2`，直到 `n == 1`，則是 2 的冪次方。
3. **轉換為二進制字串 (`O(1)`)**
    
    - `bin(n).count('1') == 1` 確保只有一個 `1`。

---

## **總結**

|**解法**|**時間複雜度**|**適用場景**|**優缺點**|
|---|---|---|---|
|**位運算 (`n & (n - 1) == 0`)**|`O(1)`|最快的解法|**O(1)**，適合大數字|
|**迴圈左移 (`O(log n)`)**|`O(log n)`|適合範圍小時|逐步檢查 `2^i`，較慢|
|**遞迴除法 (`O(log n)`)**|`O(log n)`|遞迴友好|適合 `n` 為正整數|
|**轉二進制 (`bin(n).count('1')`)**|`O(1)`|需要 Python 內建函數|適合小數字|

---

### **最佳選擇**

✅ **`O(1)` 位運算 (`n & (n - 1) == 0`) 是最優解**，只需要 **一次運算**，非常高效！

