Lintcode 142
用 O(_1_) 时间检测整数 _n_ 是否是 _2_ 的幂次。

样例

`n=4`，返回 `true`;

`n=5`，返回 `false`.


```python
    def check_power_of2(self, n):
        ans = 1
        for i in range(31):
            if ans == n:
                return True
            ans = ans << 1
 
        return False
```
pass


## **LintCode 142: O(1) Check Power of 2 解法分析**

### **解法核心**

本題要求判斷一個整數 `n` 是否是 **2 的冪次方**，即是否存在某個整數 `k` 使得：

$n = 2^k$

例如：

- `1` (2⁰) 是 2 的冪次方。
- `2` (2¹) 是 2 的冪次方。
- `3` 不是 2 的冪次方。
- `4` (2²) 是 2 的冪次方。

---

## **解法步驟**

**位運算 (`Bitwise Operations`)**

- **O(1) 檢查方法**
    - 2 的冪次方數的 **二進制表示中只有一個 `1`**，例如：
```python
1  -> 0001
2  -> 0010
4  -> 0100
8  -> 1000
```
        
    - **可以用 `n & (n - 1) == 0` 來判斷**：
        - `n-1` 會將 `n` 的唯一 `1` 變成 `0`，並將其後所有 `0` 變成 `1`。
        - 這樣 `n & (n-1)` 一定為 `0`，例如：
```python
8  ->  1000
7  ->  0111
8 & 7 -> 0000 (== 0)
```
        - **條件：`n > 0`，否則 `0 & (-1) != 0`。**
    - **時間複雜度 `O(1)`，因為只有一次位運算。**

---

### **變數定義**

|變數名稱|作用|
|---|---|
|`n`|目標數字，判斷是否為 2 的冪次方|
|`ans`|從 `1` 開始，逐步左移 (`<<`) 來生成 `2^k`|
|`i`|迴圈計數器，最多 31 次 (`0~30`)，因為 `2^30 ≈ 10^9`|

---

## **具體範例**

### **範例 1**

`輸入: n = 8`

|迭代步驟|`ans` (`2^i`)|`n == ans`|
|---|---|---|
|`i = 0`|`1` (2⁰)|`8 == 1` → `False`|
|`i = 1`|`2` (2¹)|`8 == 2` → `False`|
|`i = 2`|`4` (2²)|`8 == 4` → `False`|
|`i = 3`|`8` (2³)|`8 == 8` → `True`|
|**輸出：`True`**|||

---

### **範例 2**

text

複製編輯

`輸入: n = 10`

|迭代步驟|`ans` (`2^i`)|`n == ans`|
|---|---|---|
|`i = 0`|`1` (2⁰)|`10 == 1` → `False`|
|`i = 1`|`2` (2¹)|`10 == 2` → `False`|
|`i = 2`|`4` (2²)|`10 == 4` → `False`|
|`i = 3`|`8` (2³)|`10 == 8` → `False`|
|`i = 4`|`16` (2⁴)|`10 == 16` → `False` (已超過 10，結束)|
|**輸出：`False`**|||

---

## **時間與空間複雜度分析**

### **時間複雜度**

1. **位運算 (`O(1)`)**
    - `n & (n - 1) == 0` 只需要一次運算，時間複雜度為 **`O(1)`**。
2. **迴圈 (`O(log n)`)**
    - 若使用 `while` 來檢查是否為 `2^k`，最多需要 `O(log n)` 次計算，因為 `2^30 ≈ 10^9`。
    - 但 `log n` 在 `n ≤ 10^9` 的情況下，最多 30 次，因此也很快。

### **空間複雜度**

- **`O(1)`**，只使用了少量變數 (`ans`, `i`, `n`)。

---

## **其他解法 (不寫 Code)**

1. **位運算 `O(1)`**
    
    - 使用 `n & (n - 1) == 0` 判斷：
        - **`(n & (n - 1)) == 0` 且 `n > 0`**
        - **最快的解法**
2. **遞迴除法 (`O(log n)`)**
    
    - 若 `n % 2 == 0` 則繼續 `n //= 2`，直到 `n == 1`，則是 2 的冪次方。
3. **轉換為二進制字串 (`O(1)`)**
    
    - `bin(n).count('1') == 1` 確保只有一個 `1`。

---

## **總結**

|**解法**|**時間複雜度**|**適用場景**|**優缺點**|
|---|---|---|---|
|**位運算 (`n & (n - 1) == 0`)**|`O(1)`|最快的解法|**O(1)**，適合大數字|
|**迴圈左移 (`O(log n)`)**|`O(log n)`|適合範圍小時|逐步檢查 `2^i`，較慢|
|**遞迴除法 (`O(log n)`)**|`O(log n)`|遞迴友好|適合 `n` 為正整數|
|**轉二進制 (`bin(n).count('1')`)**|`O(1)`|需要 Python 內建函數|適合小數字|

---

### **最佳選擇**

✅ **`O(1)` 位運算 (`n & (n - 1) == 0`) 是最優解**，只需要 **一次運算**，非常高效！