Lintcode 1628
æœ‰ä¸€æ¡è·¯é•¿ä¸º`L`ï¼Œå®½ä¸º`W`ï¼Œåœ¨è·¯ä¸­æœ‰ä¸€äº›åœ†å½¢éšœç¢ç‰©ï¼ŒåŠå¾„1ï¼Œæœ‰ä¸€è¾†åœ†å½¢çš„è½¦ï¼ŒåŠå¾„2ï¼Œé—®è½¦æ˜¯å¦èƒ½é€šè¿‡è¿™æ¡è·¯ã€‚ä½ å¯ä»¥æŠŠè·¯é¢å½“æˆäºŒç»´åæ ‡ä¸Šçš„ä¸€ä¸ªçŸ©å½¢ï¼Œå››ä¸ªç‚¹ä¸º`(0,0),(0,W),(L,0),(L,W)`,ç°åœ¨ä½ éœ€è¦ä»`x=0`å‡ºå‘ï¼Œåˆ°`x=L`ï¼Œä¸å…è®¸ä¸éšœç¢ç‰©æ¥è§¦,ä¸”è½¦çš„æ‰€æœ‰éƒ¨åˆ†éƒ½åœ¨`y=0`åˆ°`y=W`ä¹‹é—´ï¼Œä¸å…è®¸æ¥è§¦ã€‚


**æ ·ä¾‹ 1:**
```python
"""
è¾“å…¥:
8 8
è¾“å‡º:
yes

è§£é‡Š:
ç»™å‡º`L=8`ï¼Œ`W=8`ï¼Œéšœç¢ç‰©åæ ‡ä¸º`[[1,1],[6,6]]`ã€‚è¿”å›`yes`ã€‚
è½¦çš„åœ†å¿ƒå¯ä»¥ä»ï¼ˆ0,5)åˆ°(2,5)åˆ°(5,2)åˆ°(8,2)ï¼Œæ‰€ä»¥è¿”å›yesã€‚
```
**æ ·ä¾‹ 2:**
```python
"""
è¾“å…¥:
8 6
è¾“å‡º:
no

è§£é‡Š:
ç»™å‡º`L=8`ï¼Œ`W=6`ï¼Œéšœç¢ç‰©åæ ‡ä¸º`[[1,1]]`,è¿”å›`no`ã€‚
ä¸ç®¡å¦‚ä½•é©¾é©¶ï¼Œè½¦æ€»ä¼šä¸éšœç¢ç‰©ç›¸åˆ‡æˆ–è€…ç›¸äº¤ï¼Œè¿™éƒ½æ˜¯ä¸è¢«å…è®¸çš„ã€‚
```


```python
OBSTAClE_MIN_DISTANCE = 6
BOUND_MIN_DISTANCE = 5

class Solution:
    def driving_problem(self, l, w, obstacles):
        from collections import deque
        
        # consider the upper & bottom line y=w, y=0, all obstacles
        # as nodes in a graph, if the car can not pass between two
        # nodes, we connect the two nodes with an edge in the graph.
        # the car can pass the road only if we CANNOT find a path
        # from start node y=w to the end node y=0
        
        queue = deque([(None, w)])
        visited = set([(None, w)])
        while queue:
            x, y = queue.popleft()
            # y <= 5 means (x, y) can connect the end node y=0
            if y <= BOUND_MIN_DISTANCE:
                return "no"
            for obstacle in obstacles:
                if (obstacle[0], obstacle[1]) in visited:
                    continue
                if not self.is_connected(x, y, obstacle[0], obstacle[1]):
                    continue
                queue.append((obstacle[0], obstacle[1]))
                visited.add((obstacle[0], obstacle[1]))
        return "yes"
    
    def is_connected(self, x1, y1, x2, y2):
        if x1 is None:
            return abs(y1 - y2) <= BOUND_MIN_DISTANCE
        # check the distance between (x1, y1) and (x2, y2) <= 6
        # 6 = 2 x (car radius + obstacle radius)
        return abs(x1 - x2) ** 2 + abs(y1 - y2) ** 2 <= OBSTAClE_MIN_DISTANCE ** 2
```
pass


# **LintCode 1628: Driving Problem è§£æ³•è©³ç´°è§£æ**

## **å•é¡Œæè¿°**

æœ‰ä¸€æ¢**å¯¬åº¦ç‚º `w`ã€é•·åº¦ç„¡çª®å¤§**çš„é“è·¯ï¼Œè»Šå­éœ€è¦å¾**èµ·é» `y = w` è¡Œé§›åˆ° `y = 0`**ã€‚é“è·¯ä¸Šæœ‰ä¸€äº›éšœç¤™ç‰© `obstacles`ï¼Œæˆ‘å€‘è¦åˆ¤æ–·è»Šå­**æ˜¯å¦èƒ½å¤ å®‰å…¨é€šé**ã€‚

**æ¢ä»¶é™åˆ¶**

1. è»Šå­èˆ‡éšœç¤™ç‰©éƒ½æ˜¯**åœ“å½¢**çš„ï¼Œ**åŠå¾‘æœªçŸ¥ï¼Œä½†èˆ‡éšœç¤™ç‰©çš„æœ€å°å®‰å…¨è·é›¢æ˜¯ `6`**ã€‚
2. è»Šå­ç„¡æ³•ç©¿è¶Šéšœç¤™ç‰©ï¼Œä¸”è»Šå­èˆ‡é‚Šç•Œ (`y=0` å’Œ `y=w` å…©æ¢ç·š) **å¿…é ˆä¿æŒè‡³å°‘ `5` çš„è·é›¢**ã€‚
3. å¦‚æœéšœç¤™ç‰©ä¹‹é–“çš„è·é›¢å°æ–¼ `6`ï¼Œå‰‡å®ƒå€‘æ˜¯**ç›¸é€£çš„**ã€‚
4. å¦‚æœéšœç¤™ç‰©å½¢æˆä¸€æ¢**å¾ `y=w` åˆ° `y=0` çš„é€£é€šéšœç¤™ç‰©éˆ**ï¼Œå‰‡è»Šå­ç„¡æ³•é€šéã€‚

**ç›®æ¨™** æˆ‘å€‘éœ€è¦åˆ¤æ–·**è»Šå­æ˜¯å¦èƒ½å¤ å¾ `y = w` æˆåŠŸé§›å…¥ `y = 0`**ï¼Œè¼¸å‡º `"yes"` æˆ– `"no"`ã€‚

---

## **è§£æ³•åˆ†æ**

é€™å€‹å•é¡Œçš„**æœ¬è³ª**æ˜¯**åˆ¤æ–·éšœç¤™ç‰©æ˜¯å¦å½¢æˆä¸€æ¢å¾ `y = w` åˆ° `y = 0` çš„å°é–‰è·¯éšœ**ï¼Œå³ï¼š**é€™äº›éšœç¤™ç‰©æ˜¯å¦å½¢æˆäº†ä¸€å€‹é€£é€šå¡Š**ï¼Œä½¿å¾—è»Šå­ç„¡æ³•ç©¿éã€‚

### **é—œéµé»**

1. **å»ºæ¨¡ç‚ºç„¡å‘åœ–**
    
    - æ¯å€‹éšœç¤™ç‰©æ˜¯ä¸€å€‹**ç¯€é»**ï¼Œå¦‚æœå…©å€‹éšœç¤™ç‰©çš„è·é›¢ â‰¤ `6`ï¼Œå‰‡å®ƒå€‘ä¹‹é–“æœ‰ä¸€æ¢é‚Šã€‚
    - `y=w` è¦–ç‚ºä¸€å€‹èµ·é» `start_node`ï¼Œ`y=0` è¦–ç‚ºçµ‚é» `end_node`ã€‚
    - **å¦‚æœå­˜åœ¨ä¸€æ¢é€£æ¥ `start_node` å’Œ `end_node` çš„è·¯å¾‘ï¼Œé‚£éº¼è»Šå­ç„¡æ³•é€šé**ï¼Œè¿”å› `"no"`ã€‚
    - **å¦‚æœ `start_node` ç„¡æ³•èˆ‡ `end_node` é€£æ¥ï¼Œé‚£éº¼è»Šå­å¯ä»¥é€šé**ï¼Œè¿”å› `"yes"`ã€‚
2. **ä½¿ç”¨ BFSï¼ˆBreadth-First Searchï¼‰ æª¢æŸ¥å¯é”æ€§**
    
    - å¾ `y=w`ï¼ˆèµ·é»ï¼‰é–‹å§‹ï¼Œå˜—è©¦éæ­·æ‰€æœ‰éšœç¤™ç‰©ï¼Œæ§‹é€ éšœç¤™ç‰©ä¹‹é–“çš„åœ–ã€‚
    - å¦‚æœèƒ½å¤ é€£æ¥åˆ° `y=0`ï¼ˆçµ‚é»ï¼‰ï¼Œå‰‡è¿”å› `"no"`ã€‚
    - å¦å‰‡ï¼Œè¿”å› `"yes"`ã€‚

---

## **è§£æ³•æ­¥é©Ÿ**

### **Step 1: å»ºç«‹ BFS æœç´¢éšŠåˆ—**

python

è¤‡è£½ç·¨è¼¯

`from collections import deque queue = deque([(None, w)])  # å¾ y=w çš„ç„¡çª®é é»é–‹å§‹ visited = set([(None, w)])`

- `queue`ï¼šç”¨ä¾†é€²è¡Œ **BFS æœç´¢**ï¼Œåˆå§‹åŒ…å« `(None, w)`ï¼Œä»£è¡¨èµ·é» `y=w`ã€‚
- `visited`ï¼šè¨˜éŒ„**å·²ç¶“è¨ªå•éçš„ç¯€é»**ï¼Œé¿å…é‡è¤‡æœç´¢ã€‚

---

### **Step 2: åŸ·è¡Œ BFSï¼Œæª¢æŸ¥æ˜¯å¦èƒ½å¤ åˆ°é” `y=0`**

python

è¤‡è£½ç·¨è¼¯

`while queue:     x, y = queue.popleft()     # å¦‚æœ y <= 5ï¼Œè¡¨ç¤ºå¯ä»¥èˆ‡ y=0 é€£æ¥ï¼Œå‰‡è¿”å› "no"     if y <= BOUND_MIN_DISTANCE:         return "no"`

- å¦‚æœç•¶å‰ç¯€é» `y â‰¤ 5`ï¼Œè¡¨ç¤ºå®ƒå¯ä»¥**ç›´æ¥é€£æ¥åˆ° `y=0`**ï¼Œè»Šå­ç„¡æ³•é€šéï¼Œè¿”å› `"no"`ã€‚

---

### **Step 3: æª¢æŸ¥æ‰€æœ‰éšœç¤™ç‰©ï¼Œåˆ¤æ–·æ˜¯å¦é€£é€š**

python

è¤‡è£½ç·¨è¼¯

``for obstacle in obstacles:     if (obstacle[0], obstacle[1]) in visited:         continue  # é¿å…é‡è¤‡è¨ªå•      if not self.is_connected(x, y, obstacle[0], obstacle[1]):         continue  # å¦‚æœç•¶å‰éšœç¤™ç‰©èˆ‡ `x, y` ä¸ç›¸é€£ï¼Œè·³é      queue.append((obstacle[0], obstacle[1]))  # åŠ å…¥éšŠåˆ—     visited.add((obstacle[0], obstacle[1]))  # æ¨™è¨˜ç‚ºå·²è¨ªå•``

- éæ­· `obstacles`ï¼Œå¦‚æœ**ç•¶å‰éšœç¤™ç‰©èˆ‡ `(x, y)` ç›¸é€£**ï¼Œå‰‡åŠ å…¥ `queue`ï¼Œè¡¨ç¤ºå¯ä»¥æ“´å±•æœç´¢ã€‚
- **ç›¸é€£çš„æ¢ä»¶**ç”± `self.is_connected(x1, y1, x2, y2)` æ±ºå®šã€‚

---

### **Step 4: åˆ¤æ–·éšœç¤™ç‰©æ˜¯å¦ç›¸é€£**

python

è¤‡è£½ç·¨è¼¯

`def is_connected(self, x1, y1, x2, y2):     if x1 is None:         return abs(y1 - y2) <= BOUND_MIN_DISTANCE  # y=w æ˜¯å¦èˆ‡éšœç¤™ç‰©é€£æ¥     return abs(x1 - x2) ** 2 + abs(y1 - y2) ** 2 <= OBSTAClE_MIN_DISTANCE ** 2  # åˆ¤æ–·å…©å€‹éšœç¤™ç‰©è·é›¢`

- **å¦‚æœ `x1=None`**ï¼Œè¡¨ç¤º `y=w` çš„èµ·é»ï¼Œæª¢æŸ¥ `y2` æ˜¯å¦èˆ‡é‚Šç•Œè·é›¢ â‰¤ `5`ã€‚
- **ä¸€èˆ¬æƒ…æ³**ï¼šå¦‚æœå…©å€‹éšœç¤™ç‰©çš„æ­å¹¾é‡Œå¾—è·é›¢ `â‰¤ 6`ï¼Œå‰‡å®ƒå€‘ç›¸é€£ï¼Œè¿”å› `True`ã€‚

---

### **Step 5: å¦‚æœ BFS å®Œæˆå¾Œä»ç„¡æ³•é€£æ¥åˆ° `y=0`ï¼Œè¿”å› `"yes"`**

python

è¤‡è£½ç·¨è¼¯

`return "yes"`

- å¦‚æœ BFS éæ­·å®Œæ‰€æœ‰å¯é”çš„éšœç¤™ç‰©å¾Œ **æ²’æœ‰æ‰¾åˆ° `y â‰¤ 5` çš„éšœç¤™ç‰©**ï¼Œèªªæ˜è»Šå­å¯ä»¥é€šéï¼Œè¿”å› `"yes"`ã€‚

---

## **èˆ‰ä¾‹åˆ†æ**

### **Example 1**

#### **è¼¸å…¥**

python

è¤‡è£½ç·¨è¼¯

`l = 10 w = 10 obstacles = [(1, 6), (2, 6), (3, 6), (4, 5)]`

#### **Step 1: åˆå§‹åŒ–**

ini

è¤‡è£½ç·¨è¼¯

`queue = [(None, 10)] visited = {(None, 10)}`

#### **Step 2: BFS æœç´¢**

|ç•¶å‰ç¯€é» `(x, y)`|èƒ½å¦èˆ‡éšœç¤™ç‰©ç›¸é€£ï¼Ÿ|åŠ å…¥ `queue`|
|---|---|---|
|`(None, 10)`|`(1,6), (2,6), (3,6)`|`(1,6), (2,6), (3,6)`|
|`(1,6)`|`(2,6), (3,6), (4,5)`|`(4,5)`|
|`(4,5)`|`y=5`ï¼Œå¯é€£æ¥åˆ° `y=0`|**è¿”å› `"no"`**|

**çµæœï¼š`"no"`**ï¼ˆéšœç¤™ç‰©å½¢æˆå°é–å€ï¼‰

---

### **Example 2**

#### **è¼¸å…¥**

python

è¤‡è£½ç·¨è¼¯

`l = 10 w = 10 obstacles = [(1, 8), (2, 7)]`

#### **BFS æœç´¢**

- `(None, 10)` â†’ `(1,8)`, `(2,7)`
- **éƒ½ç„¡æ³•åˆ°é” `y â‰¤ 5`**
- **è¿”å› `"yes"`**

---

## **æ™‚é–“èˆ‡ç©ºé–“è¤‡é›œåº¦åˆ†æ**

### **æ™‚é–“è¤‡é›œåº¦**

|æ­¥é©Ÿ|è¤‡é›œåº¦|
|---|---|
|**Step 1: åˆå§‹åŒ– BFS**|`O(1)`|
|**Step 2: éæ­·æ‰€æœ‰ `obstacles`**|`O(N)`|
|**Step 3: æ¯å€‹éšœç¤™ç‰©æœ€å¤šè¨ªå•ä¸€æ¬¡**|`O(N)`|
|**Step 4: åˆ¤æ–· `is_connected()`**|`O(1)`|
|**ç¸½è¨ˆ**|`O(N)`|

### **ç©ºé–“è¤‡é›œåº¦**

|çµæ§‹|ç©ºé–“|
|---|---|
|**è¨ªå•è¨˜éŒ„ `visited`**|`O(N)`|
|**BFS `queue`**|`O(N)`|
|**ç¸½è¨ˆ**|`O(N)`|

---

## **å…¶ä»–è§£æ³•ï¼ˆä¸éœ€ä»£ç¢¼ï¼‰**

### **1. ä½¿ç”¨ DFSï¼ˆæ·±åº¦å„ªå…ˆæœå°‹ï¼‰**

- **æ™‚é–“è¤‡é›œåº¦ `O(N)`**
- **èˆ‡ BFS é¡ä¼¼ï¼Œä½†å¯èƒ½æœƒæœ‰è¼ƒæ·±çš„éæ­¸é–‹éŠ·**

### **2. ä½¿ç”¨åœ–è«–çš„é€£é€šæ€§æª¢æŸ¥ï¼ˆä¸¦æŸ¥é›†ï¼‰**

- **æ§‹å»ºç„¡å‘åœ–ï¼Œæª¢æŸ¥ `y=w` æ˜¯å¦èˆ‡ `y=0` é€£æ¥**
- **æ™‚é–“ `O(N Î±(N))`**

---

## **ç¸½çµ**

- **æœ€ä½³è§£æ³•ï¼šBFS**
- **æ™‚é–“ `O(N)`ï¼Œç©ºé–“ `O(N)`**
- **é©åˆè™•ç†éšœç¤™ç‰©æ•¸é‡è¼ƒå¤§çš„æƒ…æ³**
- **æ¯” DFS æ›´é©åˆå¤§è¦æ¨¡æœç´¢**

é€™é“é¡Œçš„æœ¬è³ªæ˜¯**ç„¡å‘åœ–çš„é€£é€šæ€§å•é¡Œ**ï¼ŒBFS æ˜¯æœ€ä½³é¸æ“‡ï¼Œèƒ½å¤ é«˜æ•ˆåœ°åˆ¤æ–·è»Šè¼›æ˜¯å¦å¯ä»¥é€šé ğŸš—

  

O

æœå°‹