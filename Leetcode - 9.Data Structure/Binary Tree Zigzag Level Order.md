Lintcode 71
给出一棵二叉树，返回其节点值的锯齿形层次遍历（先从左往右，下一层再从右往左，层与层之间交替进行）

### **LintCode 71 - 二叉树的锯齿形层次遍历 解法詳細步驟**

---

### **題目分析**

對給定的二叉樹，進行層次遍歷，但要求遍歷的方向呈「锯齿形」：

1. 第一層從左到右。
2. 第二層從右到左。
3. 第三層再從左到右，以此類推。

---

### **解法核心思路**

1. 使用**隊列**實現層次遍歷（BFS）。
2. 在每層處理時，根據當前層的方向（從左到右或從右到左）決定是否反轉當前層的結果。
3. 利用一個標誌 `isForward` 來跟踪當前遍歷方向。

---

### **解法步驟**

#### **1. 初始化**

- **特殊情況處理**：如果 `root` 為空，直接返回空列表 `[]`。
- 初始化：
    - `ans`：保存結果的列表。
    - `q`：雙端隊列，用於層次遍歷，初始加入根節點。
    - `isForward`：方向標誌，初始為 `1` 表示正向遍歷。

---

#### **2. 開始層次遍歷**

- 當隊列 `q` 非空時，進行以下操作：
    1. 初始化 `row` 列表，用於存儲當前層的節點值。
    2. 遍歷當前層的所有節點：
        - 從隊列中彈出節點。
        - 如果該節點有左子節點，將左子節點加入隊列。
        - 如果該節點有右子節點，將右子節點加入隊列。
        - 將當前節點值加入 `row`。
    3. 根據 `isForward` 標誌確定是否反轉當前層的節點順序：
        - 如果 `isForward = 1`，保持正向。
        - 如果 `isForward = -1`，反轉 `row`。
    4. 將處理好的 `row` 加入結果列表 `ans`。
    5. 切換方向標誌 `isForward`，即 `isForward *= -1`。

---

#### **3. 返回結果**

- 最終返回結果列表 `ans`。

---
Example: 
**样例 1：**
输入：
```python
tree = {1,2,3}
```
输出：
```python
[[1],[3,2]]
```
解释：
```python
    1
   / \
  2   3
```
它将被序列化为 {1,2,3} 
**样例 2：**
输入：
```python
tree = {3,9,20,#,#,15,7}
```
输出：
```python
[[3],[20,9],[15,7]]
```
解释：
```python
    3
   / \
  9  20
    /  \
   15   7
```
它将被序列化为 {3,9,20,#,#,15,7}


```python
    def zigzagLevelOrder(self, root):
        import collections
        # write your code here
        if root is None:
            return []
        ans = []
        q = collections.deque()
        q.append(root)
        #正反向标志
        isForward = 1
        while len(q) is not 0:
            row = []
            for i in range(len(q)):
                if q[0].left:
                    q.append(q[0].left)
                if q[0].right:
                    q.append(q[0].right)
                row.append(q[0].val)
                q.popleft()
            #根据标志来确认当前层遍历的方向
            row = row[::isForward]#翻转
            ans += [row]
            #方向反转
            isForward *= -1
        return ans
```
pass
### **具體舉例**

#### 輸入：

python

複製程式碼

`root = [3, 9, 20, null, null, 15, 7]`

對應的二叉樹為：

markdown

複製程式碼

        `3        / \       9   20          /  \         15   7`

#### 遍歷步驟：

1. **初始化：**
    
    - `ans = []`
    - `q = deque([3])`
    - `isForward = 1`
2. **第一層：**
    
    - 隊列大小：`len(q) = 1`
    - 處理節點：
        - 彈出 `3`，將其值加入 `row = [3]`。
        - 將左子節點 `9` 和右子節點 `20` 加入隊列。
    - 根據 `isForward`（正向）：`row = [3]`。
    - 更新結果：`ans = [[3]]`
    - 切換方向：`isForward = -1`
3. **第二層：**
    
    - 隊列大小：`len(q) = 2`
    - 處理節點：
        - 彈出 `9`，將其值加入 `row = [9]`。
        - 彈出 `20`，將其值加入 `row = [9, 20]`，並將其子節點 `15` 和 `7` 加入隊列。
    - 根據 `isForward`（反向）：`row = [20, 9]`。
    - 更新結果：`ans = [[3], [20, 9]]`
    - 切換方向：`isForward = 1`
4. **第三層：**
    
    - 隊列大小：`len(q) = 2`
    - 處理節點：
        - 彈出 `15`，將其值加入 `row = [15]`。
        - 彈出 `7`，將其值加入 `row = [15, 7]`。
    - 根據 `isForward`（正向）：`row = [15, 7]`。
    - 更新結果：`ans = [[3], [20, 9], [15, 7]]`
    - 切換方向：`isForward = -1`
5. **結束：**
    
    - 隊列為空，返回結果 `ans = [[3], [20, 9], [15, 7]]`。

---

### **時間與空間複雜度分析**

1. **時間複雜度：**
    
    - 每個節點進入隊列一次並處理一次，因此總時間複雜度為 O(n)O(n)O(n)，其中 nnn 為節點數量。
2. **空間複雜度：**
    
    - 使用了雙端隊列 `q`，其大小最多為某層節點數，最壞情況為 O(n)O(n)O(n)。
    - 結果列表 `ans` 的大小為 O(n)O(n)O(n)。
    - 總空間複雜度為 O(n)O(n)O(n)。

---

### **其他解法簡述**

1. **遞歸法：**
    
    - 使用遞歸遍歷樹，同時記錄當前層數，根據層數的奇偶性決定插入結果列表的方向。
    - **時間複雜度：** O(n)O(n)O(n)
    - **空間複雜度：** O(h)O(h)O(h)，其中 hhh 是樹的高度。
2. **雙棧法：**
    
    - 使用兩個棧分別存儲當前層和下一層的節點，交替處理。
    - **時間複雜度：** O(n)O(n)O(n)
    - **空間複雜度：** O(n)O(n)O(n)。

該解法利用 BFS 和方向控制，易於實現且高效，非常適合大多數場景。

4o

  

O

ChatGPT 可能會