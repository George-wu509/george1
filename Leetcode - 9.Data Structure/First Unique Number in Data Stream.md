Lintcode 685
给一个连续的数据流,写一个函数返回终止数字到达时的第一个唯一数字（包括终止数字）,如果找不到这个终止数字, 返回 `-1`.

**样例1**
```python
""" 
[1, 2, 2, 1, 3, 4, 4, 5, 6]
5
输出： 3
```
解釋:
找出nums在5之前(包含5)的 [1,2,2,1,3,4,4,5],   只出現一次的數字=3
因為 counter={'1':2, '2':2, '3':1, '4':2}

**样例2**
```python
"""
输入：
[1, 2, 2, 1, 3, 4, 4, 5, 6]
7
输出： -1
```
**样例3**
```python
"""
输入：
[1, 2, 2, 1, 3, 4]
3
输出： 3
```


```python
    def first_unique_number(self, nums, number):
        counter = {}
        for num in nums:
            counter[num] = counter.get(num, 0) + 1
            if num == number:
                break
        else:
            return -1
            
        for num in nums:
            if counter[num] == 1:
                return num
            if num == number:
                break

        return -1
```
pass


# **LintCode 960: First Unique Number in Data Stream 解法分析**

## **解題目標**

給定一個數字流 `nums` 和一個目標數字 `number`，我們需要找到在 `nums` **遍歷到 `number` 之前的第一個唯一數字**（只出現一次的數字）。

如果 `number` **不在數組中**，或者 **在 `number` 之前沒有唯一數字**，則返回 `-1`。

---

## **解法核心**

本題的主要考慮點：

1. **遍歷數據流，記錄每個數字的出現次數。**
2. **當遍歷到 `number` 時，停止計數，確保我們只關心 `number` 之前的數字。**
3. **再次遍歷 `nums`，找到第一個出現 `1` 次的數字，作為答案。**
4. **如果沒有找到唯一數字，返回 `-1`。**

這種方法有效地將問題拆解成 **兩次遍歷**：

- 第一次遍歷：**計數出現次數**
- 第二次遍歷：**尋找第一個唯一數字**

這樣的策略確保了我們 **僅處理必要的數據範圍**，避免了額外的計算負擔。

---

## **解法步驟**

### **Step 1: 記錄數字頻率**

- 使用一個 **哈希表 `counter`** 記錄 `nums` 中每個數字的出現次數。
- 當 `nums[i] == number` 時，**停止記錄**，因為我們只關心 `number` **之前的數字**。

### **Step 2: 找到第一個唯一數**

- 再次遍歷 `nums`，當發現 `counter[num] == 1`（僅出現一次），立即返回該數字。
- 若在 `number` 之前沒有唯一數字，則返回 `-1`。

---

## **變數定義**

|變數名稱|作用|
|---|---|
|`nums`|數字流|
|`number`|目標數字|
|`counter`|哈希表，記錄每個數字的出現次數|
|`num`|當前遍歷的數字|

---

## **具體範例**

### **範例 1**

text

複製編輯

`輸入: nums = [2, 3, 5, 3, 2, 4, 5], number = 5`

#### **Step 1: 記錄數字頻率**

|數字 `num`|`counter` 更新|`num == number`？|記錄中斷？|
|---|---|---|---|
|`2`|`{2: 1}`|❌|繼續|
|`3`|`{2: 1, 3: 1}`|❌|繼續|
|`5`|`{2: 1, 3: 1, 5: 1}`|✅|**停止記錄**|

**結果:** `{2: 1, 3: 1, 5: 1}`

#### **Step 2: 找到第一個唯一數**

|遍歷 `nums`|`counter[num]`|`num == number`？|是否返回|
|---|---|---|---|
|`2`|`1`|❌|**返回 `2`**|

**輸出**: `2`

---

### **範例 2**

text

複製編輯

`輸入: nums = [1, 2, 2, 3, 3, 4], number = 3`

#### **Step 1: 記錄數字頻率**

|數字 `num`|`counter` 更新|`num == number`？|記錄中斷？|
|---|---|---|---|
|`1`|`{1: 1}`|❌|繼續|
|`2`|`{1: 1, 2: 1}`|❌|繼續|
|`2`|`{1: 1, 2: 2}`|❌|繼續|
|`3`|`{1: 1, 2: 2, 3: 1}`|✅|**停止記錄**|

**結果:** `{1: 1, 2: 2, 3: 1}`

#### **Step 2: 找到第一個唯一數**

|遍歷 `nums`|`counter[num]`|`num == number`？|是否返回|
|---|---|---|---|
|`1`|`1`|❌|**返回 `1`**|

**輸出**: `1`

---

### **範例 3**

text

複製編輯

`輸入: nums = [4, 4, 4, 4], number = 4`

#### **Step 1: 記錄數字頻率**

|數字 `num`|`counter` 更新|`num == number`？|記錄中斷？|
|---|---|---|---|
|`4`|`{4: 1}`|✅|**停止記錄**|

**結果:** `{4: 1}`

#### **Step 2: 找到第一個唯一數**

|遍歷 `nums`|`counter[num]`|`num == number`？|是否返回|
|---|---|---|---|
|`4`|`1`|✅|**沒有數字符合條件，返回 -1**|

**輸出**: `-1`

---

## **時間與空間複雜度分析**

### **時間複雜度**

|操作|時間複雜度|說明|
|---|---|---|
|記錄數字頻率 (`O(n)`)|`O(n)`|遍歷 `nums` 直到 `number`|
|查找第一個唯一數 (`O(n)`)|`O(n)`|最多遍歷 `nums` 一次|
|**總計**|`O(n)`|線性時間複雜度|

### **空間複雜度**

|操作|空間複雜度|說明|
|---|---|---|
|`counter` (哈希表)|`O(n)`|最壞情況需要存儲所有數字|
|**總計**|`O(n)`|線性空間複雜度|

**這個方法是最優解，因為所有操作都是線性 `O(n)`**。

---

## **其他解法 (不寫 Code)**

1. **雙佇列 (Two Queues)**
    
    - **使用 `Queue`**：
        - 一個隊列儲存 `num`，按順序記錄數字。
        - 另一個隊列儲存 **唯一數字**，如果某個數字在 `counter` 變為 `2`，則將其從唯一隊列中刪除。
    - **查找唯一數只需 `O(1)`**，但維護隊列有額外開銷。
2. **LinkedHashMap (`O(n)`)**
    
    - 使用 **有序字典 (OrderedDict)**，確保插入順序：
        - `counter[num]++` 記錄次數。
        - 遍歷 OrderedDict，找到第一個 `count == 1` 的數字。
    - 與 `HashMap + List` 相比，有更好的查找性能。
3. **暴力法 (`O(n^2)`)**
    
    - 每次遍歷 `nums`，對 `num[i]` 進行 **`O(n)` 次計數**。
    - **時間複雜度 `O(n^2)`**，不適用於大數據。

---

## **總結**

|**解法**|**時間複雜度**|**適用場景**|**優缺點**|
|---|---|---|---|
|**哈希表 (`O(n)`)**|`O(n)`|最通用|✅ 高效，適用所有數據|
|**雙佇列 (`O(n)`)**|`O(n)`|需要高效查找|⚠ 額外空間消耗|
|**OrderedDict (`O(n)`)**|`O(n)`|保持插入順序|⚠ 需 Python 內建功能|
|**暴力 (`O(n^2)`)**|`O(n^2)`|數據小時可行|❌ 低效|

✅ **最佳解法：哈希表 (`O(n)`)，空間 `O(n)`，最適合所有場景！** 🚀