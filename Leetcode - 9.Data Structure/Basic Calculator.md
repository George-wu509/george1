Lintcode 978
实现一个基础的计算器来计算一个简单表达式。

这个表达式字符串可能包含左括号 `'('` 与右括号 `')'`，加号 `'+'` 或者 减号 `'-'`，**非负**整数以及空格 `' '`。

给出的表达式总是合理的。

### **LintCode 978 基础计算器解法**

這題目要求實現一個簡單的計算器來計算包含整數、加法（`+`）、減法（`-`）、括號（`(` 和 `)`）的算術表達式。

#### **目标**

实现一个简单的计算器，支持以下功能：

- 整数计算（正数与负数）。
- 操作符 `+`、`-`。
- 括号 `(` 和 `)` 处理嵌套计算。

### 最小复杂度解法

#### **核心思路**

通过一个栈（`stack`）来管理括号嵌套，保持计算逻辑简单且高效。

**主要步骤：**

1. 使用 **一个栈** 记录括号内外的计算状态：
    - 当前的累积结果（`current_result`）。
    - 当前的符号（`current_sign`）。
2. 遍历输入字符串，逐个处理字符：
    - 遇到数字：累积读取完整数字。
    - 遇到符号：调整当前的符号。
    - 遇到左括号 `(`：将当前结果和符号入栈，开始新一层的计算。
    - 遇到右括号 `)`：将括号内的结果合并到上一层。
3. 返回最终结果。

---

#### 解法细节及复杂度

- **时间复杂度：** O(n)，每个字符只被处理一次。
- **空间复杂度：** O(h)，栈的最大深度为括号的嵌套深度 hhh。

---

### **解題思路**

這是一道經典的字符串處理與數學運算結合的題目。主要解題思路如下：

1. **使用棧模擬括號的計算順序：**
    
    - 括號會影響計算順序，最內層括號的表達式需要最先計算。
    - 棧結構（stack）是一種後進先出的結構，能很好地模擬括號的嵌套計算。
2. **逐字符解析字符串：**
    
    - 如果是數字，累積形成完整的數字。
    - 如果是加號或減號，將其應用於棧頂的計算狀態。
    - 如果遇到左括號，將當前狀態（結果和符號）存入棧，開始處理括號內的新狀態。
    - 如果遇到右括號，彈出棧頂的狀態，將括號內的結果與外層結果結合。
3. **符號的處理：**
    
    - `+` 和 `-` 符號需要結合當前計算結果，根據符號更新結果。
4. **計算結果：**
    
    - 需要遍歷完整的字符串，處理所有的括號，並在棧結構的幫助下累積計算結果。

Example:
样例 1
输入："1 + 1"
输出：2

样例 2
输入："(1+(4+5+2)-3)+(6+8)" 
输出：23

---

### **代碼步驟**

以下是 Python 實現的具體代碼及詳細注釋：

```python
def calculate(s: str) -> int:
    # 初始化變量
    stack = []  # 棧用於存儲 (當前結果, 當前符號)
    num = 0  # 用於累積數字
    result = 0  # 最終結果
    sign = 1  # 當前符號，1 表示正，-1 表示負

    for char in s:
        if char.isdigit():  # 如果是數字
            num = num * 10 + int(char)  # 構造完整數字
        elif char == '+':  # 如果是加號
            result += sign * num  # 把之前累積的數字根據符號加入結果
            num = 0  # 重置數字
            sign = 1  # 加號對應正號
        elif char == '-':  # 如果是減號
            result += sign * num  # 把之前累積的數字根據符號加入結果
            num = 0  # 重置數字
            sign = -1  # 減號對應負號
        elif char == '(':  # 如果是左括號
            # 將當前結果和符號壓入棧
            stack.append((result, sign))
            result = 0  # 括號內重置結果
            sign = 1  # 括號內默認符號為正
        elif char == ')':  # 如果是右括號
            result += sign * num  # 處理括號內的最後一個數字
            num = 0  # 重置數字
            prev_result, prev_sign = stack.pop()  # 彈出棧頂的狀態
            result = prev_result + prev_sign * result  # 結合括號內外的結果
        # 忽略空格
    # 處理最後一個數字
    result += sign * num
    return result

```
pass

---

### **步驟詳解及舉例**

#### 輸入：`"(1+(4+5+2)-3)+(6+8)"`

1. **初始化：**
    
    - `stack = []`
    - `num = 0`
    - `result = 0`
    - `sign = 1`
2. **逐字符解析：**
    
    - `char = '('`:
        - 把當前 `(result=0, sign=1)` 壓入棧，並初始化括號內的計算。
        - `stack = [(0, 1)]`
        - `result = 0`
        - `sign = 1`
    - `char = '1'`:
        - 累積數字 `num = 1`
    - `char = '+'`:
        - `result = result + sign * num = 0 + 1 * 1 = 1`
        - `num = 0`
        - `sign = 1`（加號）
    - `char = '('`:
        - 把當前 `(result=1, sign=1)` 壓入棧，初始化括號內的計算。
        - `stack = [(0, 1), (1, 1)]`
        - `result = 0`
        - `sign = 1`
    - `char = '4'`:
        - 累積數字 `num = 4`
    - `char = '+'`:
        - `result = result + sign * num = 0 + 1 * 4 = 4`
        - `num = 0`
        - `sign = 1`
    - `char = '5'`:
        - 累積數字 `num = 5`
    - `char = '+'`:
        - `result = result + sign * num = 4 + 1 * 5 = 9`
        - `num = 0`
        - `sign = 1`
    - `char = '2'`:
        - 累積數字 `num = 2`
    - `char = ')'`:
        - `result = result + sign * num = 9 + 1 * 2 = 11`
        - 從棧彈出 `(1, 1)`，更新外層結果。
        - `result = prev_result + prev_sign * result = 1 + 1 * 11 = 12`
        - `stack = [(0, 1)]`
    - `char = '-'`:
        - `result = result + sign * num = 12 - 1 * 3 = 9`
        - `num = 0`
        - `sign = -1`
    - `char = ')'`:
        - `result = result + sign * num = 12 + (-1) * 3 = 9`
        - 從棧彈出 `(0, 1)`，更新外層結果。
        - `result = prev_result + prev_sign * result = 0 + 1 * 9 = 9`
    - `char = '+'`:
        - `result = result + sign * num`
    - `char = '('`:
        - 把當前 `(result=9, sign=1)` 壓入棧。
        - `stack = [(9, 1)]`

---

最後得到計算結果 `23`。




### 解法思路分析：

這道題目是模擬一個簡單的計算器，處理 `+`、`-`、`(`、`)` 以及整數數字，不包含 `*`、`/` 等運算。

#### **解法核心**

1. **數字處理：**
    
    - 若當前字元是數字，則需考慮多位數的情況，累積到 `num` 中。
    - 例如，對於 `"23"`，會將 `num = num * 10 + 3`，變成 `23`。
2. **加減號處理：**
    
    - 當遇到 `+` 或 `-` 時，應將 `num` 乘以 `sign`（代表當前符號），並累積到 `result` 中。
    - `sign` 變數用來記錄當前的運算符號，`+` 對應 `sign = 1`，`-` 對應 `sign = -1`。
3. **括號處理：**
    
    - 遇到 `(` 時：
        - 需將當前 `result` 和 `sign` 推入 **棧**，因為 `(` 代表一個新的運算範圍，進入後需重置 `result` 為 0，並將 `sign` 設為 `1`。
    - 遇到 `)` 時：
        - 需先將當前 `result` 計算完整（因為可能有未處理的 `num`）。
        - 之後彈出棧頂元素 `prev_result` 和 `prev_sign`，代表這個括號前的累積結果與符號，並計算 `prev_result + prev_sign * result`。
4. **處理最後的數字**
    
    - 由於 `for` 迴圈結束時最後一個數字可能尚未累積到 `result`，因此需執行 `result += sign * num`。

---

### **變數說明**

|變數名稱|作用|
|---|---|
|`stack`|儲存 `(前面結果, 前面符號)` 以處理括號計算|
|`num`|累積當前數字（處理多位數）|
|`result`|當前計算結果|
|`sign`|當前符號（1 為 `+`，-1 為 `-`）|

---

### **示例解析**

#### **輸入**: `"1 + (2 - (3 + 4))"`

1. `1`：`num = 1`
2. `+`：`result = 1`，`sign = 1`
3. `(`：`stack.push((1, 1))`，`result = 0`
4. `2`：`num = 2`
5. `-`：`result = 2`，`sign = -1`
6. `(`：`stack.push((2, -1))`，`result = 0`
7. `3`：`num = 3`
8. `+`：`result = 3`，`sign = 1`
9. `4`：`num = 4`
10. `)`：`result = 3 + 4 = 7`，`stack.pop() = (2, -1)`，`result = 2 - 7 = -5`
11. `)`：`stack.pop() = (1, 1)`，`result = 1 + (-5) = -4`
12. **最終結果**：`-4`

---

### **時間與空間複雜度分析**

- **時間複雜度：**
    
    - 遍歷字串一次 `O(N)`，每個字元處理的時間為 `O(1)`。
    - 在最壞情況下，遇到 `(` 需要推入棧、`)` 需要彈出棧，這些操作為 `O(1)`，因此總體時間複雜度為 **`O(N)`**。
- **空間複雜度：**
    
    - 使用棧來存儲 `(` 前的結果與符號，最多可能儲存 `O(N/2)` 個元素（假設每個數字都包在括號內）。
    - 因此，**空間複雜度為 `O(N)`**。

---

### **其他可能解法**

1. **遞歸解法**
    
    - 遇到 `(` 時遞歸計算 `)` 內部的表達式，直到 `)` 返回結果。
    - 遞歸結束時更新當前 `result`。
2. **雙棧解法**
    
    - 使用 **數字棧** 和 **運算符棧** 分別存儲數字與運算符，根據運算優先級處理加減法。
3. **轉換為中序或後序表示法**
    
    - 先將字串轉為後序表達式（Postfix Notation），再用 **逆波蘭表示法（RPN, Reverse Polish Notation）** 進行計算。