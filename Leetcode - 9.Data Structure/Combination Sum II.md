Lintcode 153
给定一个数组 `num` 和一个整数 `target`. 找到 `num` 中所有的数字之和为 `target` 的组合.


**样例 1:**
```python
"""
输入: num = [7,1,2,5,1,6,10], target = 8
输出: [[1,1,6],[1,2,5],[1,7],[2,6]]
```
**样例 2:**
```python
"""
输入: num = [1,1,1], target = 2
输出: [[1,1]]
解释: 解集不能包含重复的组合
```


```python
    def combination_sum2(self, num, target): 
        # write your code here
        num.sort()        
        self.ans, tmp, use = [], [], [0] * len(num)        
        self.dfs(num, target, 0, 0, tmp, use)        
        return self.ans    
    def dfs(self, can, target, p, now, tmp, use):        
        if now == target:            
            self.ans.append(tmp[:])            
            return        
        for i in range(p, len(can)):            
            if now + can[i] <= target and (i == 0 or can[i] != can[i-1] or use[i-1] == 1):                
                tmp.append(can[i])
                use[i] = 1                
                self.dfs(can, target, i+1, now + can[i], tmp, use)                
                tmp.pop()                
                use[i] = 0
```
pass


# **LintCode 153: Combination Sum II 解法分析**

## **解題目標**

給定一個數組 `num`（可能包含 **重複數字**），以及一個目標數值 `target`，找出所有 **不重複的組合**，使得組合中數字的總和等於 `target`。  
**每個數字只能使用一次**。

範例：

`輸入: num = [10,1,2,7,6,1,5], target = 8 輸出: [[1,1,6],[1,2,5],[1,7],[2,6]]`

---

## **解法核心**

這是一個 **組合型回溯 (Combination + Backtracking) 問題**，因為：

1. **不能重複使用同一個數字**（與 Combination Sum I 的區別）。
2. **需要去除重複組合**（因為 `num` 可能有重複元素）。
3. **數字不能改變順序**（先排序，然後 `dfs` 進行遞增搜索）。

### **解法策略**

1. **先排序**：確保相同的數字相鄰，方便去重。
2. **回溯 (Backtracking)**
    - 遍歷數組中的每個數字：
        - 若當前數字 `can[i]` 超過 `target`，則剪枝。
        - 若當前數字 `can[i]` 與前一個數字相同，且前一個數字未使用過，則跳過（去重）。
    - 透過 `dfs` 進行遞迴探索 **當前組合**。
    - **回溯 (Backtrack)**：在每次遞歸返回後，將當前數字從 `tmp` 移除，以測試其他可能組合。

---

## **解法步驟**

### **Step 1: 預處理**

對 `num` 進行 **遞增排序**，確保相同數字相鄰，方便後續去重。

### **Step 2: 回溯 (DFS)**

使用 **遞歸深度優先搜索 (DFS)**，從 `p` 開始遍歷：

1. **邊界條件**：
    - 若當前總和 `now` **等於 `target`**，則將 `tmp` 加入答案。
    - 若 `now` **超過 `target`**，則直接返回（剪枝）。
2. **遍歷 `num[p:]`**：
    - 跳過 **相同數字但未使用過的情況**（避免重複）。
    - 遞歸嘗試選擇 `can[i]`。
    - **回溯 (pop 掉當前選擇，恢復狀態)**。

---

## **變數定義**

|變數名稱|作用|
|---|---|
|`num`|給定的數組，排序後用於組合搜尋|
|`target`|目標和|
|`tmp`|當前組合|
|`use`|記錄 `num` 中元素是否被使用|
|`ans`|存儲所有符合條件的組合|
|`p`|當前 DFS 搜尋位置|
|`now`|當前組合總和|
|`can[i]`|當前遍歷的數字|

---

## **具體範例**

### **範例 1**

text

複製編輯

`輸入: num = [10,1,2,7,6,1,5], target = 8`

#### **Step 1: 排序**

text

複製編輯

`排序後: [1,1,2,5,6,7,10]`

#### **Step 2: DFS 遞迴搜索**

|遞歸層|`tmp`|`now`|記錄 `use`|選擇|
|---|---|---|---|---|
|0|`[]`|`0`|`[0,0,0,0,0,0,0]`|選擇 `1`|
|1|`[1]`|`1`|`[1,0,0,0,0,0,0]`|選擇 `1`|
|2|`[1,1]`|`2`|`[1,1,0,0,0,0,0]`|選擇 `6`|
|3|`[1,1,6]`|`8`|`[1,1,0,0,1,0,0]`|**找到解，加入 `ans`**|
|回溯|`[1,1]`|`2`|`[1,1,0,0,0,0,0]`|選擇 `2`|
|3|`[1,2]`|`3`|`[1,0,1,0,0,0,0]`|選擇 `5`|
|4|`[1,2,5]`|`8`|`[1,0,1,1,0,0,0]`|**找到解，加入 `ans`**|

**最終結果**

text

複製編輯

`[[1,1,6], [1,2,5], [1,7], [2,6]]`

---

## **時間與空間複雜度分析**

### **時間複雜度**

- **排序**：`O(n log n)`
- **回溯搜索**：
    - 最差情況為 `O(2^n)`，因為每個元素都有 **選擇與不選擇** 兩種情況。
    - 但由於 **剪枝 (剪去超過 `target` 的情況)**，實際情況遠小於 `O(2^n)`。
- **總計**：`O(2^n)`

### **空間複雜度**

- 主要來自於 **遞迴棧** 和 **暫存組合 `tmp`**。
- 最多為 `O(n)`（`n` 層遞迴）。
- **總計**：`O(n)`

---

## **其他解法 (不寫 Code)**

1. **Bitmask 枚舉 (`O(2^n)`)**
    
    - 遍歷所有可能的組合 (`2^n`)，計算和是否等於 `target`。
    - **缺點**：不夠高效，且無法去重。
2. **動態規劃 (`O(n * target)`)**
    
    - `dp[i][j]` 表示前 `i` 個數字是否能湊出 `j`。
    - **適合** `target` **較小** 的情況，但 **不適用於輸出所有組合**。

---

## **總結**

|**解法**|**時間複雜度**|**適用場景**|**優缺點**|
|---|---|---|---|
|**回溯 + 剪枝 (DFS, `O(2^n)`)**|`O(2^n)`|數字數量少但 `target` 大|✅ 高效剪枝，去重|
|**Bitmask (`O(2^n)`)**|`O(2^n)`|適用於小數組|❌ 去重困難|
|**動態規劃 (`O(n * target)`)**|`O(n * target)`|適用於小 `target`|❌ 無法輸出所有組合|

---

## **最佳解法**

✅ **回溯 (DFS) + 剪枝** (`O(2^n)`)

- **去重處理**
- **減少不必要的搜索**
- **適用於數字數量 `n` 較小但 `target` 大的情況**

🚀 **剪枝 + 排序是高效關鍵！**

  

O