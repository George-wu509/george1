
### **LintCode 642 - 数据流滑动窗口平均值 解法詳細步驟**

---

### **題目分析**

實現一個計算滑動窗口平均值的數據結構：

1. 滑動窗口的大小為固定值 `size`。
2. 當新數據到來時，窗口向右滑動：
    - 如果窗口中已有的元素數量小於 `size`，直接加入。
    - 如果已滿，刪除窗口最左端的數據，然後加入新數據。
3. 返回當前窗口中所有數據的平均值。

---

### **解法核心思路**

使用**雙端隊列（deque）**來維護滑動窗口的數據，並通過一個變量 `sum` 記錄窗口內數據的總和：

1. 當窗口內數據個數達到 `size` 時，移除隊首的元素，並從 `sum` 中減去該值。
2. 加入新數據到隊尾，並更新 `sum`。
3. 返回窗口內數據總和除以當前窗口內數據數量。

---
Example:
```python
MovingAverage m = new MovingAverage(3);
m.next(1) = 1 // 返回 1.00000
m.next(10) = (1 + 10) / 2 // 返回 5.50000
m.next(3) = (1 + 10 + 3) / 3 // 返回 4.66667
m.next(5) = (10 + 3 + 5) / 3 // 返回 6.00000
```


```python
from collections import deque
class MovingAverage(object):
    def __init__(self, size):
        self.queue = deque([])
        self.size = size
        self.sum = 0.0
        

    def next(self, val):
        if len(self.queue) == self.size:
            self.sum -= self.queue.popleft()
            
        self.sum += val
        self.queue.append(val)
        return self.sum / len(self.queue)
```
pass

### **解法步驟**

#### **1. 初始化**

- 定義變量：
    - `queue`：雙端隊列，用於存儲滑動窗口內的數據。
    - `size`：滑動窗口的固定大小。
    - `sum`：記錄當前窗口內數據的總和。

---

#### **2. 添加新數據（`next` 方法）**

- 當新數據 `val` 到來時：
    1. 如果窗口已滿（`len(queue) == size`），移除隊首元素：
        - 從 `queue` 中彈出隊首元素。
        - 從 `sum` 中減去該元素的值。
    2. 加入新數據到隊尾：
        - 將 `val` 添加到 `queue` 中。
        - 將 `val` 加到 `sum` 中。
    3. 返回當前窗口的平均值：
        - 計算公式：`sum / len(queue)`。

---

### **具體舉例**

#### 輸入：

`size = 3 data = [1, 10, 3, 5]`

#### 步驟詳解：

1. **初始化：**
    
    - `queue = deque([])`
    - `sum = 0.0`
2. **第一個數據：`next(1)`**
    
    - 窗口未滿（`len(queue) < size`）。
    - 加入 `1` 到隊尾，更新 `sum = 1.0`。
    - 計算平均值：`1.0 / 1 = 1.0`。
    - 返回 `1.0`。
    - **狀態：**
        - `queue = deque([1])`
        - `sum = 1.0`
3. **第二個數據：`next(10)`**
    
    - 窗口未滿（`len(queue) < size`）。
    - 加入 `10` 到隊尾，更新 `sum = 1.0 + 10 = 11.0`。
    - 計算平均值：`11.0 / 2 = 5.5`。
    - 返回 `5.5`。
    - **狀態：**
        - `queue = deque([1, 10])`
        - `sum = 11.0`
4. **第三個數據：`next(3)`**
    
    - 窗口未滿（`len(queue) < size`）。
    - 加入 `3` 到隊尾，更新 `sum = 11.0 + 3 = 14.0`。
    - 計算平均值：`14.0 / 3 = 4.6667`。
    - 返回 `4.6667`。
    - **狀態：**
        - `queue = deque([1, 10, 3])`
        - `sum = 14.0`
5. **第四個數據：`next(5)`**
    
    - 窗口已滿（`len(queue) == size`）。
    - 移除隊首元素 `1`，更新 `sum = 14.0 - 1 = 13.0`。
    - 加入 `5` 到隊尾，更新 `sum = 13.0 + 5 = 18.0`。
    - 計算平均值：`18.0 / 3 = 6.0`。
    - 返回 `6.0`。
    - **狀態：**
        - `queue = deque([10, 3, 5])`
        - `sum = 18.0`

---

#### **最終輸出：**

`[1.0, 5.5, 4.6667, 6.0]`

---

### **時間與空間複雜度分析**

1. **時間複雜度：**
    
    - 每次調用 `next()`：
        - 移除隊首、加入隊尾為 O(1)O(1)O(1)。
        - 更新總和及計算平均值為 O(1)O(1)O(1)。
    - 總時間複雜度：每次調用 O(1)O(1)O(1)。
2. **空間複雜度：**
    
    - 雙端隊列的最大長度為窗口大小 sizesizesize，空間複雜度為 O(size)O(size)O(size)。
    - 總空間複雜度：O(size)O(size)O(size)。

---

### **其他解法簡述**

1. **暴力法：**
    
    - 每次滑動窗口時，計算窗口內所有數字的總和，然後求平均值。
    - **時間複雜度：** O(size⋅n)O(size \cdot n)O(size⋅n)，不適用於大數據。
2. **固定長度列表法：**
    
    - 使用固定大小的循環隊列取代雙端隊列，保持窗口的固定長度。
    - 每次計算直接更新窗口的總和。
    - 與當前解法時間空間複雜度一致，但實現稍有不同。

該解法基於雙端隊列的設計，簡潔高效，非常適合處理滑動窗口問題。