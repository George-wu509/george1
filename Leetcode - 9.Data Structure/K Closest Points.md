Lintcode 612
找到离原点最近的 k 个点。


例1:
```python
"""
输入：
points = [[4,6],[4,7],[4,4],[2,5],[1,1]]
origin = [0, 0]
k = 3 
输出：
[[1,1],[2,5],[4,4]]
```
例2:
```python
"""
输入：
points = [[0,0],[0,9]]
origin = [3, 1]
k = 1
输出：
[[0,0]]
```



```python
import heapq
class Solution:

    def k_closest(self, points: List[Point], origin: Point, k: int) -> List[Point]:
        self.heap = []
        for point in points:
            dist = self.getDistance(point, origin)
            heapq.heappush(self.heap, (-dist, -point.x, -point.y))
            
            if len(self.heap) > k:
                heapq.heappop(self.heap)

        result = []
        while len(self.heap) > 0:
            _, x, y = heapq.heappop(self.heap)
            result.append(Point(-x, -y))

        result.reverse()
        return result

    def getDistance(self, a, b):
        return (a.x - b.x) ** 2 + (a.y - b.y) ** 2
```
pass



**問題描述 (K Closest Points)**

這個問題要求你找到給定點集 `points` 中，距離 `origin` (原點) 最近的 `k` 個點。這裡的距離通常是指歐幾里得距離的平方，因為這樣可以避免開方運算，簡化計算。當兩個點距離相等時，通常會根據 x 坐標和 y 坐標來進行額外的排序，例如 x 坐標小的優先，x 坐標相同時 y 坐標小的優先。

**解題思路**

這個問題可以使用最大堆（Max-Heap）來高效解決。核心思想是維護一個大小為 `k` 的最大堆。遍歷所有點，對於每個點，計算它到 `origin` 的距離。

Reference: Max-Heap https://www.shubo.io/binary-heap/

1. **如果堆的大小還不到 `k` 個**：直接將點（及其距離）加入堆中。
    
2. **如果堆的大小已經達到 `k` 個**：比較當前點到 `origin` 的距離與堆頂元素（即堆中距離最大的點）的距離。
    
    - 如果當前點的距離小於堆頂元素的距離，則將堆頂元素彈出，然後將當前點加入堆中。
        
    - 如果當前點的距離大於或等於堆頂元素的距離，則不做任何操作，因為這個點不是 `k` 個最近點之一。
        

這樣，當遍歷完所有點後，堆中剩下的 `k` 個點就是距離 `origin` 最近的 `k` 個點。

**為什麼使用最大堆？**

因為我們想要找到距離最小的 `k` 個點。如果使用最小堆，我們會得到距離最小的點，但我們需要不斷地彈出最小的點直到剩下 `k` 個，這效率不高。

使用最大堆，堆頂總是當前 `k` 個點中距離最遠的那個。這樣，每次新來一個點，我們只需要和堆頂比較，如果新點更近，就替換掉最遠的那個，保持堆中始終是當前已處理點中最近的 `k` 個。

**Python 實現詳解**

```python
import heapq

class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

class Solution:
    def k_closest(self, points: List[Point], origin: Point, k: int) -> List[Point]:
        # self.heap 用來存儲最大堆
        # 堆中存儲的元素是 (負距離, 負x坐標, 負y坐標)
        # 這裡取負值是為了讓 heapq 實現最大堆的功能
        # heapq 默認是最小堆，如果我們想實現最大堆，可以將元素取負數
        # 當距離相同時，負x坐標較大（即x坐標較小）的排在前面
        # 當距離和x坐標都相同時，負y坐標較大（即y坐標較小）的排在前面
        self.heap = []

        for point in points:
            dist = self.getDistance(point, origin)
            # 將 (負距離, 負x坐標, 負y坐標) 壓入堆中
            # 這樣堆頂就是距離最大、x最大、y最大的點（因為取了負號，實際是距離最小、x最小、y最小的點）
            # 不對，這裡是堆頂是距離最大，x最大，y最大的，因為我們取了負號，所以 -dist 最小，在最小堆中排在前面
            # 所以為了實現最大堆，我們應該將值取負。當我們希望距離大的在堆頂時，我們將距離取負，
            # 這樣距離大的負數就變成了小的負數，在最小堆中會排在前面。
            # 因此，heapq.heappush(self.heap, (-dist, -point.x, -point.y))
            # 會使得堆頂元素是 (-dist_max, -x_max, -y_max)
            # 彈出時，會彈出距離最大的那個點。
            heapq.heappush(self.heap, (-dist, -point.x, -point.y))

            # 如果堆的大小超過 k，則彈出堆頂元素（距離最大的那個點）
            if len(self.heap) > k:
                heapq.heappop(self.heap)

        ret = []
        # 從堆中逐一取出元素，並將其還原為 Point 對象
        while len(self.heap) > 0:
            _, x, y = heapq.heappop(self.heap)
            # 因為之前取了負號，所以這裡要再取一次負號還原
            ret.append(Point(-x, -y))

        # 由於 heapq.heappop 每次取出的是堆中最小的元素（因為存儲的是負值，所以實際上是原始值中最大的），
        # 所以彈出的順序是從距離大到距離小。
        # 因此，最後的結果需要反轉才能得到從近到遠的排序。
        ret.reverse()
        return ret

    # 計算兩個點之間距離的平方
    def getDistance(self, a, b):
        return (a.x - b.x) ** 2 + (a.y - b.y) ** 2

```

**關鍵點解釋：**

1. **`import heapq`**: 導入 Python 的堆模塊。`heapq` 模塊實現了最小堆（min-heap）。
    
2. **`self.heap = []`**: 初始化一個空列表，用作堆的底層存儲。
    
3. **`heapq.heappush(self.heap, (-dist, -point.x, -point.y))`**:
    
    - 這是實現最大堆的關鍵。`heapq` 默認是最小堆，它會將最小的元素放在堆頂。
        
    - 為了讓它行為像最大堆（即將最大的元素放在堆頂），我們將要比較的數值取負。
        
    - 所以，我們存儲 `(-dist, -point.x, -point.y)`。這樣，距離 `dist` 越大，`-dist` 就越小，在最小堆中就會排在前面。
        
    - 當距離 `dist` 相等時，`(-point.x, -point.y)` 用於打破平局。由於 `point.x` 和 `point.y` 也取了負號，這意味著如果 `point.x` 越小，`-point.x` 就越大，在最小堆中它會排在後面。這也符合題意，通常距離相同時，x 坐標小的優先。但是這裡取負號後，因為是最小堆，所以 `-point.x` 越小，它越靠前。所以 `-point.x` 負得越多，即 `point.x` 越大，它越靠前。這與我們的期望（x 小的優先）是相反的。
        
    - **修正理解**: 如果希望距離相同時 `x` 小的點優先，那麼在元組中，應該讓 `x` 小的元組元素在最小堆中"顯得"更大。也就是說，當距離相等時，我們希望 `(-dist, -point.x, -point.y)` 這個元組在 `heapq` 比較時，如果 `point.x` 更小，那麼這個元組應該被認為"更小"。
        
    - 所以，為了讓 `x` 越小，在最小堆中排在前面，我們應該在元組中將 `point.x` 保持為正值（或者說，如果比較規則是先比 `dist` 再比 `x` 再比 `y`，那麼元組的結構應該是 `(dist, point.x, point.y)`）。
        
    - 但是，我們現在的目標是實現 **最大堆**，堆頂是距離最大的點。
        
    - 所以，`heapq.heappush(self.heap, (-dist, -point.x, -point.y))` 的行為是：堆頂是當前堆中 `dist` 最大的點。當 `dist` 相等時，`-point.x` 較小（即 `point.x` 較大）的點會被優先彈出（因為堆是最小堆）。這意味著當距離相同時，x 坐標大的點會被優先“踢出”堆，留下 x 坐標小的點。這正是我們想要的（距離相同，x 坐標小的優先保留）。同樣地，x 坐標相同時，y 坐標大的點會被優先“踢出”，留下 y 坐標小的點。
        
    - 總結一下：這個 `(-dist, -point.x, -point.y)` 元組的設計，使得當堆的尺寸超過 `k` 時，`heapq.heappop()` 彈出的是**距離最遠的點**。如果多個點距離相同，則優先彈出 `x` 坐標最大的，然後 `y` 坐標最大的。這也符合我們希望保留距離最近、`x` 坐標最小、`y` 坐標最小的點。
        
4. **`if len(self.heap) > k: heapq.heappop(self.heap)`**: 如果堆中的元素數量超過了 `k`，就彈出堆頂元素。由於我們用負數實現了最大堆，彈出的就是當前堆中距離最遠的那個點。
    
5. **`while len(self.heap) > 0: ... ret.append(Point(-x, -y))`**: 遍歷堆，將取出的元素還原為 `Point` 對象。由於彈出順序是從距離大的負數（即距離小的原始值）到距離小的負數（即距離大的原始值），所以彈出的點是從距離最近到距離最遠。
    
6. **`ret.reverse()`**: 因為 `heapq.heappop` 每次彈出的是當前堆中**原始值最大的**那個（由於我們存儲的是負數，所以實際上是原始值最小的），所以彈出的順序是從“最不應該被保留的”點（即距離最大，或者距離相同但x或y大的）開始。這導致 `ret` 列表中的點是按照距離從大到小排序的。因此，需要 `reverse()` 將其翻轉，使其從距離小到大排序。
    

**具體舉例說明**

假設 `points = [Point(1,1), Point(0,0), Point(2,2), Point(3,3)]`, `origin = Point(0,0)`, `k = 2`。

我們目標是找到距離 `(0,0)` 最近的 `2` 個點。

1. **初始化**: `self.heap = []`
    
2. **處理 `Point(1,1)`**:
    
    - `dist = (1-0)^2 + (1-0)^2 = 2`
        
    - `heapq.heappush(self.heap, (-2, -1, -1))`
        
    - `self.heap` 現在是 `[(-2, -1, -1)]`
        
    - `len(self.heap)` 是 1，不大于 `k=2`。
        
3. **處理 `Point(0,0)`**:
    
    - `dist = (0-0)^2 + (0-0)^2 = 0`
        
    - `heapq.heappush(self.heap, (0, 0, 0))` (注意这里 0 不取负也行，但为了统一，我们写成 `(-0, -0, -0)`)
        
    - `self.heap` 現在是 `[(0, 0, 0), (-2, -1, -1)]` (堆自動調整，`0` 比 `-2` 大，所以 `(0,0,0)` 在堆頂)
        
    - `len(self.heap)` 是 2，不大于 `k=2`。
        
4. **處理 `Point(2,2)`**:
    
    - `dist = (2-0)^2 + (2-0)^2 = 8`
        
    - `heapq.heappush(self.heap, (-8, -2, -2))`
        
    - `self.heap` 現在是 `[(-2, -1, -1), (-8, -2, -2), (0, 0, 0)]` (堆自動調整)
        
    - `len(self.heap)` 是 3，大于 `k=2`。
        
    - `heapq.heappop(self.heap)`：彈出堆頂元素，即 `(-2, -1, -1)` (因為 `-2` 是最小的負數，代表距離最大的點)。所以 `Point(1,1)` 被移除了。
        
    - `self.heap` 現在是 `[(-8, -2, -2), (0, 0, 0)]` (堆自動調整)
        
5. **處理 `Point(3,3)`**:
    
    - `dist = (3-0)^2 + (3-0)^2 = 18`
        
    - `heapq.heappush(self.heap, (-18, -3, -3))`
        
    - `self.heap` 現在是 `[(-8, -2, -2), (-18, -3, -3), (0, 0, 0)]` (堆自動調整)
        
    - `len(self.heap)` 是 3，大于 `k=2`。
        
    - `heapq.heappop(self.heap)`：彈出堆頂元素，即 `(-8, -2, -2)` (因為 `-8` 是最小的負數，代表距離最大的點)。所以 `Point(2,2)` 被移除了。
        
    - `self.heap` 現在是 `[(-18, -3, -3), (0, 0, 0)]` (堆自動調整)
        
6. **遍歷結束，取出結果**:
    
    - `while len(self.heap) > 0`:
        
        - 第一次 `heapq.heappop(self.heap)`：彈出 `(-18, -3, -3)`。 `x=-3, y=-3`。 `ret.append(Point(3,3))`。 `ret = [Point(3,3)]`
            
        - 第二次 `heapq.heappop(self.heap)`：彈出 `(0, 0, 0)`。 `x=0, y=0`。 `ret.append(Point(0,0))`。 `ret = [Point(3,3), Point(0,0)]`
            
    - 堆為空。
        
7. **反轉結果**:
    
    - `ret.reverse()`
        
    - `ret` 變為 `[Point(0,0), Point(3,3)]`
        

**最終結果：`[Point(0,0), Point(3,3)]`**

等等，這好像有點問題。`Point(3,3)` 的距離是 18，而 `Point(1,1)` 的距離是 2，`Point(2,2)` 的距離是 8。顯然 `(0,0)` 和 `(1,1)` 才是最近的兩個點。

**問題出在哪裡？**

我的例子中對 `heapq.heappop()` 的理解有誤。`heapq.heappop()` 彈出的是**最小的元素**。當我們將 `(-dist, -point.x, -point.y)` 放入堆時，如果想讓 `dist` 最大的元素被彈出，那麼 `-dist` 應該是最小的。這正是我們想要的。

讓我們重新跑一下例子，更仔細地觀察堆的狀態。

1. **初始化**: `self.heap = []`
    
2. **處理 `Point(1,1)`**: `dist = 2`
    
    - `heapq.heappush(self.heap, (-2, -1, -1))`
        
    - `self.heap`: `[(-2, -1, -1)]` (堆中只有一個元素)
        
3. **處理 `Point(0,0)`**: `dist = 0`
    
    - `heapq.heappush(self.heap, (0, 0, 0))`
        
    - `self.heap`: `[(0, 0, 0), (-2, -1, -1)]` (因為 0 > -2，所以 0 在堆頂，這是錯誤的理解，`heapq` 是最小堆，`0` 比 `-2` 大，所以 `-2` 才是堆頂。 `(0,0,0)` 會被放到後面。
        
    - 正確的堆狀態: `[(-2, -1, -1), (0, 0, 0)]`。堆頂是 `(-2, -1, -1)`，因為 `-2` 是所有負數中值最小的（最負的）。
        
4. **處理 `Point(2,2)`**: `dist = 8`
    
    - `heapq.heappush(self.heap, (-8, -2, -2))`
        
    - `self.heap`: 堆會自動調整，堆頂將是 `-8`。`[(-8, -2, -2), (-2, -1, -1), (0, 0, 0)]` (這是一個最小堆，所以最小的元素 `-8` 在堆頂)
        
    - `len(self.heap)` 是 3，大于 `k=2`。
        
    - `heapq.heappop(self.heap)`：彈出堆頂元素 `(-8, -2, -2)`。這代表距離最大的點 `Point(2,2)` 被彈出。
        
    - `self.heap`: `[(-2, -1, -1), (0, 0, 0)]`
        
5. **處理 `Point(3,3)`**: `dist = 18`
    
    - `heapq.heappush(self.heap, (-18, -3, -3))`
        
    - `self.heap`: 堆會自動調整，堆頂將是 `-18`。 `[(-18, -3, -3), (-2, -1, -1), (0, 0, 0)]`
        
    - `len(self.heap)` 是 3，大于 `k=2`。
        
    - `heapq.heappop(self.heap)`：彈出堆頂元素 `(-18, -3, -3)`。這代表距離最大的點 `Point(3,3)` 被彈出。
        
    - `self.heap`: `[(-2, -1, -1), (0, 0, 0)]`
        
6. **遍歷結束，取出結果**:
    
    - `while len(self.heap) > 0`:
        
        - 第一次 `heapq.heappop(self.heap)`：彈出 `(-2, -1, -1)`。 `x=-1, y=-1`。 `ret.append(Point(1,1))`。 `ret = [Point(1,1)]`
            
        - 第二次 `heapq.heappop(self.heap)`：彈出 `(0, 0, 0)`。 `x=0, y=0`。 `ret.append(Point(0,0))`。 `ret = [Point(1,1), Point(0,0)]`
            
    - 堆為空。
        
7. **反轉結果**:
    
    - `ret.reverse()`
        
    - `ret` 變為 `[Point(0,0), Point(1,1)]`
        

**最終結果：`[Point(0,0), Point(1,1)]`**

這個結果是正確的！`Point(0,0)` 距離為 0，`Point(1,1)` 距離為 2。它們是距離 `(0,0)` 最近的兩個點。

**總結**

這段代碼巧妙地利用了 `heapq` 模塊的最小堆特性，通過存儲負值來實現了一個“大小為 `k` 的最大堆”，從而有效地解決了 K Closest Points 問題。在處理 Tie-breaking（平局）時，`(-point.x, -point.y)` 的設計確保了當距離相同時，x 坐標小的點優先保留，x 坐標相同時 y 坐標小的點優先保留。最後，由於彈出的順序是從距離近到距離遠，所以需要 `ret.reverse()` 來得到最終正確的排序。



## 哪種方法是 LintCode K Closest Points 問題的最佳解法？

對於 LintCode K Closest Points 問題，**最大堆（Max-Heap）是最佳解法之一**。單調棧**不適合**解決這個問題。

### 為什麼單調棧不適合？

**單調棧**主要用於解決需要找到元素在序列中左側或右側第一個比它大（或小）的元素的問題，或者處理區間最值等。它的核心思想是維護棧內元素的單調性。

然而，K Closest Points 問題的關鍵在於**距離的比較和排序**，以及**動態維護一個大小為 `k` 的集合**。單調棧無法直接幫助我們：

1. **計算距離並進行比較：** 單調棧不具備根據點的坐標計算距離並進行排序的功能。
    
2. **維護 `k` 個最近點：** 單調棧無法在每次新點加入時，自動剔除距離最遠的點，並保持剩餘 `k` 個點是當前最近的。它沒有「容量限制」和「淘汰機制」。
    
3. **多維數據的處理：** 點有 x 和 y 兩個坐標，單調棧通常處理一維數據的順序關係。
    

因此，將單調棧應用於 K Closest Points 問題，就好像嘗試用螺絲刀去釘釘子，工具不對路。

---

### 為什麼最大堆是最佳解法？

最大堆（或用最小堆模擬最大堆）是解決 K Closest Points 這類 **Top-K 問題** 的經典且高效的方法。

1. **動態維護 Top K：** 最大堆的核心優勢在於它能高效地動態維護集合中最大（或最小）的 `k` 個元素。對於 K Closest Points，我們希望找到距離最小的 `k` 個點。透過將距離取負數存入最小堆，我們就能讓距離最大的點（其負值最小）位於堆頂，方便進行替換。
    
2. **時間複雜度：**
    
    - 構建堆：對於每個點，我們進行一次距離計算（常數時間）和一次堆操作（O(logk) 時間）。總共有 `N` 個點，所以總時間複雜度是 O(Nlogk)。
        
    - 取出結果：最後從堆中取出 `k` 個點，每次操作是 O(logk)，所以是 O(klogk)。
        
    - 綜合來看，總時間複雜度為 O(Nlogk)，這對於大型數據集來說非常高效。
        
3. **空間複雜度：** 最大堆需要存儲 `k` 個點，所以空間複雜度是 O(k)。
    

---

### 其他可能的解法與比較

除了最大堆，還有其他解決此問題的方法，但它們在效率上可能不如最大堆：

1. **排序（Sorting）：**
    
    - **方法：** 計算所有點到原點的距離，然後將這些點根據距離進行排序，取前 `k` 個。
        
    - **時間複雜度：** O(NlogN) (取決於排序算法)。當 `k` 遠小於 `N` 時，這會比 O(Nlogk) 慢。
        
    - **優點：** 實現簡單直觀。
        
    - **缺點：** 當 `N` 很大時，計算所有點的距離並排序的開銷較大。
        
2. **快速選擇（Quick Select）/分治法：**
    
    - **方法：** 類似於快速排序的分區思想。選擇一個樞軸點，將所有點分為比它近的和比它遠的兩組。根據樞軸點的排名來判斷 `k` 個最近點在哪一組，然後遞歸處理。
        
    - **時間複雜度：** 平均情況下 O(N)，最壞情況下 O(N2)。
        
    - **優點：** 平均時間複雜度最低。
        
    - **缺點：** 實現相對複雜，且最壞情況性能不佳（儘管可以通過隨機化樞軸選擇來降低最壞情況發生的概率）。對於面試或一般應用，堆的穩定 O(Nlogk) 往往更受青睞。
        

---

### 結論

綜合考慮時間複雜度、空間複雜度和實現難度，**最大堆（Max-Heap）是解決 K Closest Points 問題的最佳解法。** 它在效率和實用性之間取得了很好的平衡。