Lintcode 124
给定一个未排序的整数数组`num`，找出最长连续序列的长度。


**样例 1：**
输入：
```python
num = [100, 4, 200, 1, 3, 2]
```
输出：
```python
4
```
解释：
这个最长的连续序列是 [1, 2, 3, 4]. 返回所求长度 4


```python
def longest_consecutive(self, num: List[int]) -> int:
	longest_streak = 0
	num_set = set(num)

	for nu in num_set:
		if nu - 1 not in num_set:
			current_num = nu
			current_streak = 1

			while current_num + 1 in num_set:
				current_num += 1
				current_streak += 1

			longest_streak = max(longest_streak, current_streak)

	return longest_streak
```
pass

解釋:
step1: 由num 轉成set() = {1,2,3,100,4,200}
step2:


### 解法分析

本題 **Longest Consecutive Sequence** 要求找出陣列中的 **最長連續序列**，並回傳其長度。這裡的「連續」指的是數字在數字值上的連續，例如 `[100, 4, 200, 1, 3, 2]` 中的 **`[1, 2, 3, 4]`** 為最長的連續序列。

#### **解法核心：哈希表 (HashSet)**

使用 **哈希表 (HashSet)** 記錄陣列中的數字，然後遍歷陣列並嘗試擴展連續序列。

#### **解法步驟**

1. **建立 HashSet**：先將所有數字存入哈希表中，以便快速查找某個數字是否存在 (`O(1)` 查找)。
2. **遍歷數組**：
    - 如果 `num - 1` **不在** 哈希表內，則 `num` 是某個連續序列的起點。
    - 向右擴展 (`num + 1, num + 2, ...`) 直到該序列結束。
    - 記錄最大連續長度。
3. **回傳結果**。

---

### **變數定義**

|變數名稱|作用|
|---|---|
|`nums`|輸入的數組|
|`num_set`|哈希表，存入 `nums` 中所有數字|
|`longest`|記錄目前找到的最長連續序列長度|
|`num`|當前遍歷的數字|
|`current_length`|當前找到的連續序列長度|
|`current_num`|當前連續序列中的數字|

---

### **時間與空間複雜度分析**

- **建表 (建立 HashSet)：** `O(n)`
- **遍歷數組並嘗試擴展：**
    - 每個數字最多被訪問兩次（一次作為起點，一次在擴展時遇到），因此 **整體為 O(n)**。
- **空間複雜度：** `O(n)`（哈希表存儲所有數字）

**總體時間複雜度：** `O(n)`  
**總體空間複雜度：** `O(n)`

---

### **具體範例**

#### **範例 1**

text

複製編輯

`` 輸入: nums = [100, 4, 200, 1, 3, 2] 步驟: 1. 建立哈希表: {100, 4, 200, 1, 3, 2} 2. 遍歷數組：    - `1` 是起點 (1-1 不在集合內)，擴展 `2, 3, 4`，長度 = 4    - `100` 是起點 (無法擴展)，長度 = 1    - `200` 是起點 (無法擴展)，長度 = 1 3. 最長連續序列長度 = `4` 輸出: `4` ``

#### **範例 2**

text

複製編輯

`` 輸入: nums = [9, 1, 4, 7, 3, 2, 6, 8, 5] 步驟: 1. 建立哈希表: {9, 1, 4, 7, 3, 2, 6, 8, 5} 2. 遍歷數組：    - `1` 是起點 (1-1 不在集合內)，擴展 `2, 3, 4, 5, 6, 7, 8, 9`，長度 = 9 3. 最長連續序列長度 = `9` 輸出: `9` ``

---

### **其他解法 (不寫 Code)**

1. **排序後線性掃描 (`O(n log n)`)**
    
    - 先對 `nums` 進行排序 (`O(n log n)`)
    - 使用變數追蹤連續長度 (`O(n)`)
    - **時間複雜度：** `O(n log n)`
2. **並查集 (Union-Find) (`O(n)`)**
    
    - 將每個數作為節點，構建連通分量
    - 使用 **查找** (`find()`) 來確認是否為同一區間
    - **時間複雜度：** `O(n α(n))` (`α(n)` 為阿克曼函數的反函數)
3. **貪心 + 記錄區間端點 (`O(n)`)**
    
    - 使用 **哈希表記錄區間端點**，例如 `{1:4, 4:1}` 表示 `1-4`
    - 每當插入一個新數字時，嘗試合併區間
    - **時間複雜度：** `O(n)`

---

### **總結**

- **最佳解法：** **哈希表 (`O(n)`)**
- **次佳：** **並查集 (`O(n α(n))`)**
- **較差解法：** 排序後線性掃描 (`O(n log n)`)

**哈希表方案最簡潔且高效，適用於大數據集合。**