Lintcode 35
翻转一个链表


**样例 1：**
输入：
```python
"""
链表 = 1->2->3->null
```
输出：
```python
"""
3->2->1->null
```
解释：
翻转链表

**样例 2：**
输入：
```python
"""
链表 = 1->2->3->4->null
```
输出：
```python
"""
4->3->2->1->null
```
解释：
翻转链表


```python
    def reverse(self, head):
        #curt表示前继节点
        curt = None
        while head != None:
            #temp记录下一个节点，head是当前节点
            temp = head.next
            head.next = curt
            curt = head
            head = temp
        return curt
```
pass


### **解法分析（Iterative Approach）**

這是一個 **反轉單向鏈表（Reverse Linked List）** 的經典問題。我們的目標是將鏈表的指針反轉，使原本指向下一個節點的指針，改為指向前一個節點，從而達成鏈表反轉的效果。

#### **解法思路**

1. **初始化變數**：
    
    - `curt`（current，即目前處理到的節點）初始為 `None`，它將用來存儲 **反轉後的鏈表頭**。
    - `head`（遍歷指標）初始化為鏈表的 `head`，負責遍歷整個鏈表。
2. **遍歷鏈表**：
    
    - 在每一步中，我們需要 **存儲當前節點 `head` 的下一個節點**，以防止指針斷裂。
    - 讓當前節點 `head` 的 `next` 指向 `curt`（前一個節點）。
    - 更新 `curt` 為 `head`，並移動 `head` 到 `temp`（下一個節點）。
3. **返回結果**：
    
    - 當 `head == None` 時，表示我們已經反轉整個鏈表，此時 `curt` 就是新鏈表的頭部，返回 `curt` 即可。

---

### **變數表**

|變數名稱|角色|作用|初始值|變化過程|
|---|---|---|---|---|
|`head`|遍歷指標|指向當前處理的節點|`head`|每次迭代更新為 `temp`（下一個節點）|
|`curt`|反轉後的頭|指向新鏈表的頭|`None`|每次迭代更新為當前的 `head`|
|`temp`|暫存指標|存儲 `head.next`，防止丟失|`head.next`|每次迭代更新為 `head.next`|

---

### **時間與空間複雜度分析**

#### **時間複雜度：O(n)**

- 這個演算法遍歷了整個鏈表一次，對每個節點進行恰好一次的操作，因此時間複雜度為 **O(n)**，其中 `n` 為鏈表節點數。

#### **空間複雜度：O(1)**

- 這是 **原地反轉（In-Place Reversal）** 的方法，僅使用了 **三個額外變數** (`curt`, `head`, `temp`)，不依賴額外的數據結構，因此空間複雜度為 **O(1)**。

---

### **其他解法**

#### **1. 遞歸解法（Recursive Approach, O(n) 時間, O(n) 空間）**

- 使用遞歸方式反轉鏈表，每次調用遞歸函數處理下一個節點，並讓該節點的 `next.next = head`，最後返回新的頭節點。
- 由於遞歸的深度為 `n`，**空間複雜度為 O(n)**（遞歸棧佔用額外空間）。

#### **2. 使用堆疊（Stack Approach, O(n) 時間, O(n) 空間）**

- 先將鏈表所有節點存入 **堆疊（Stack）**，然後依序彈出節點，重新串接成反轉後的鏈表。
- 時間複雜度 **O(n)**，但空間複雜度 **O(n)**（因為額外使用了堆疊）。

#### **3. 重新建立新鏈表（New List Approach, O(n) 時間, O(n) 空間）**

- 建立一個新鏈表，從舊鏈表頭部開始，依次將節點插入新鏈表的 **頭部**，使得新鏈表順序反轉。
- 時間複雜度 **O(n)**，空間複雜度 **O(n)**（因為建立了新鏈表）。

---

### **結論**

- **最優解為迭代解法（Iterative Approach），時間 O(n)，空間 O(1)**，因為它不使用額外記憶體，且遍歷一次即可完成鏈表反轉。
- 若允許額外空間，可以考慮 **遞歸** 或 **堆疊** 方法。