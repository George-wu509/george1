Lintcode 1276
不使用运算符 + 和 - ，计算两整数 a 、b 之和。


**样例 1:**
```python
"""
输入: a = 1, b = 2
输出: 3
```
**样例 2:**
```python
"""
输入: a = -2, b = 3
输出: 1
```


```python
class Solution:
    MASK1 = 4294967296  # 2^32
    MASK2 = 2147483648  # 2^31
    MASK3 = 2147483647  # 2^31-1

    def get_sum(self, a: int, b: int) -> int:
        a %= self.MASK1
        b %= self.MASK1
        while b != 0:
            carry = ((a & b) << 1) % self.MASK1
            a = (a ^ b) % self.MASK1
            b = carry
        if a & self.MASK2:  # 负数
            return ~((a ^ self.MASK2) ^ self.MASK3)
        else:  # 正数
            return a
```
pass
解釋:
step1:  a ^ b 可用來代表不考慮進位的和 (個位數兩者都是1, 則會進位, 個位數變成0)
0 ^ 0 = 0
0 ^ 1 = 1
1 ^ 0 = 1
1 ^ 1 = 0
step2:  a & b 可用來代表考慮進位的和 (個位數兩者都是1, 則會進位)
0 & 0 = 0 
0 & 1 = 0 
1 & 0 = 0 
1 & 1 = 1
譬如如果是01 + 01 = 10 (個位數變成0, 有進位)

解釋code
```python
class Solution:
    # 定義一些常用位元遮罩 (Mask)
    MASK1 = 4294967296  # 2^32，用於將數字限制在 32 位無符號整數範圍內 (處理負數的溢出)
    MASK2 = 2147483648  # 2^31，用於判斷最高位是否為 1 (即是否為負數的標誌位)
    MASK3 = 2147483647  # 2^31-1，用於將數字限制在 32 位有符號整數的正數範圍內 (處理負數轉換)

    def get_sum(self, a: int, b: int) -> int:
        # 將 a 和 b 限制在 32 位無符號整數範圍內。
        # 這是為了模擬大多數語言中整數的位數限制，尤其是處理負數時的行為。
        # Python 的整數是任意精度的，所以需要手動模擬位元溢出。
        a %= self.MASK1
        b %= self.MASK1

        # 主循環：只要有進位 (b 不為 0)，就繼續加法
        while b != 0:
            # 計算進位：
            # (a & b) 找出 a 和 b 共同為 1 的位元（表示會產生進位）
            # << 1 將進位向左移動一位，為下一次加法做準備
            # % self.MASK1 確保進位也在 32 位範圍內
            carry = ((a & b) << 1) % self.MASK1

            # 計算不帶進位的和：
            # a ^ b 執行異或運算，得到當前位不考慮進位的和
            # % self.MASK1 確保結果也在 32 位範圍內
            a = (a ^ b) % self.MASK1

            # 將進位賦值給 b，在下一次循環中，這個進位將與當前的 'a' 進行加法
            b = carry

        # 循環結束時，b 為 0 (表示沒有進位了)，此時 a 就是最終的和，但在 32 位無符號表示中。
        # 接下來需要處理負數的情況。

        # 判斷結果 'a' 是否為負數：
        # 如果 a 的最高位 (第 31 位，從 0 開始計數) 為 1，則表示它是一個負數（在二補數表示法中）
        # MASK2 (2^31) 只有第 31 位是 1，與 a 進行位元與運算，如果結果非零，則表示 a 的第 31 位是 1。
        if a & self.MASK2:  # 如果最高位為 1，則為負數
            # 負數的轉換：
            # 在 Python 中，位元運算預設是針對無限大整數的，負數會以其二補數表示。
            # 這裡的轉換是將 32 位無符號數 'a' 轉換為其對應的 32 位有符號數。
            # a ^ self.MASK2：將 a 的最高位（符號位）翻轉。
            #                例如，如果 a 是 0x80000000（-2^31），這會變成 0x00000000。
            #                如果 a 是 0xFFFFFFFF（-1），這會變成 0x7FFFFFFF。
            # ^ self.MASK3：再與 MASK3 (2^31-1，即 31 個 1) 進行異或。
            #                這個操作實際上是將結果取反（~），但只考慮 31 位。
            #                `~x` 在 Python 中是 `-(x+1)`，這裡的轉換是為了讓 32 位無符號的負數回到 Python 的負數表示。
            # 簡而言之，這行程式碼的目的是將 32 位無符號整數 `a` 轉換回其 32 位有符號整數表示。
            # 這等同於 a - MASK1，例如 0xFFFFFFFF (4294967295) - 4294967296 = -1
            return ~((a ^ self.MASK2) ^ self.MASK3)
            # 一種更直接且常用的負數轉換方法是：
            # return a - self.MASK1
            # 但您提供的程式碼使用了另一種基於位元運算的方式來實現相同的效果。
        else:  # 正數
            # 如果最高位為 0，則為正數，直接返回 a
            return a


```


### 兩個整數求和 (Sum of Two Integers) 問題解釋

您提供的這段程式碼是解決 LintCode 上 **"Sum of Two Integers"** 問題的 Python 實現。這個問題的特殊之處在於，它要求**不使用加號 (`+`) 和減號 (`-`) 運算符**來計算兩個整數的和。

這個問題通常透過**位元運算 (Bitwise Operations)** 來解決，模擬二進制加法的過程。

---

### 程式碼核心概念：位元運算加法

在二進制中，兩個數字相加的過程可以分為兩部分：

1. **不考慮進位的和 (Sum without Carry)**：這可以透過**異或運算 (`^`)** 來實現。
    
    - 0 ^ 0 = 0
    - 0 ^ 1 = 1
    - 1 ^ 0 = 1
    - 1 ^ 1 = 0 (不考慮進位)
2. **進位 (Carry)**：這可以透過**與運算 (`&`)** 後再**左移一位 (`<< 1`)** 來實現。
    
    - 0 & 0 = 0 (無進位)
    - 0 & 1 = 0 (無進位)
    - 1 & 0 = 0 (無進位)
    - 1 & 1 = 1 (產生進位，需左移一位代表進位到下一位)

這個過程會重複進行，直到不再產生進位為止。