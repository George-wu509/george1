Lintcode 1712
在由若干 `0` 和 `1` 组成的数组 `A` 中，有多少个和为 `S` 的**非空**子数组。

**样例 1:**
```python
"""
输入：A = [1,0,1,0,1], S = 2
输出：4
解释：
如下面黑体所示，有 4 个满足题目要求的子数组：
[1,0,1]
[1,0,1]
[1,0,1,0]
[0,1,0,1]
```

**样例 2:**
```python
"""
输入：A = [0,0,0,0,0,0,1,0,0,0], S = 0
输出：27
解释：
和为 S 的子数组有 27 个
```


```python
    def num_subarrays_with_sum(self, a: List[int], s: int) -> int:
        n = len(a)
        left1, left2, right = 0, 0, 0
        sum1, sum2 = 0, 0
        ret = 0
        while right < n:
            sum1 += a[right]
            while left1 <= right and sum1 > s:
                sum1 -= a[left1]
                left1 += 1
            sum2 += a[right]
            while left2 <= right and sum2 >= s:
                sum2 -= a[left2]
                left2 += 1
            ret += left2 - left1
            right += 1
        return ret
```
pass


# **LintCode 1712 - Binary Subarrays With Sum（和为 S 的二进制子数组）**

## **题目解析**

给定一个只包含 `0` 和 `1` 的数组 `a`，求 **子数组的和等于 `s` 的个数**。

### **关键点**

1. **数组 `a` 仅包含 `0` 和 `1`**：
    
    - `sum(l, r) = a[l] + a[l+1] + ... + a[r]`
    - 子数组的和 **等于子数组中 `1` 的个数**。
2. **问题转换**：
    
    - **找到所有子数组 `[i, j]`，满足 `sum(i, j) == s`**。
    - 可以用 **滑动窗口优化计算子数组和**。

---

## **解法解析**

### **思路**

使用 **滑动窗口（双指针）**，利用两个窗口 `left1` 和 `left2`：

- `left1` 维护 **当前窗口内最小可能的 `i`**，满足 `sum1 > s` 时左移。
- `left2` 维护 **当前窗口内最大的 `i`**，满足 `sum2 >= s` 时左移。
- `ret += left2 - left1` 计算符合 `sum == s` 的子数组个数。

---

## **解法步骤**

1. **定义双指针 `left1` 和 `left2`，右指针 `right` 遍历 `a`**
    
    - `sum1` 计算窗口 `[left1, right]` 的和
    - `sum2` 计算窗口 `[left2, right]` 的和
    - `left1` 负责 **缩小窗口直到 `sum1 ≤ s`**
    - `left2` 负责 **缩小窗口直到 `sum2 < s`**
    - `ret += left2 - left1` 贡献符合条件的子数组个数。
2. **右指针 `right` 遍历 `a`**
    
    - 更新 `sum1` 和 `sum2`
    - 计算有效子数组个数。

---

## **具体举例**

假设 `a = [1, 0, 1, 0, 1]`，`s = 2`。

|`right`|`a[right]`|`sum1`|`sum2`|`left1`|`left2`|`ret`（累计有效子数组数）|
|---|---|---|---|---|---|---|
|0|1|1|1|0|0|0|
|1|0|1|1|0|0|0|
|2|1|2|2|0|1|1|
|3|0|2|2|0|2|2|
|4|1|3|3|1|3|5|

最终答案 `ret = 5`，符合条件的子数组：

css

複製編輯

`[1,0,1], [1,0,1,0], [0,1,0,1], [1,0,1], [0,1]`

---

## **时间与空间复杂度分析**

### **时间复杂度**

- **右指针 `right` 遍历 `n`**：O(n)
- **每个 `left1` 和 `left2` 只向前移动 `n` 次**：O(n)
- **总复杂度 O(n)**。

### **空间复杂度**

- **只使用了几个变量 `sum1, sum2, left1, left2`**，**O(1)**。

---

## **其他解法**

### **1. 前缀和 + 哈希表（O(n)）**

- **思路**：
    - 使用 `prefix_sum` 计算 `prefix[j] - prefix[i] = s` 的个数。
    - 用 `hashmap` 记录 `prefix_sum` 出现次数，快速查找前缀和是否满足 `sum == s`。

### **2. 暴力解法（O(n²)）**

- **思路**：
    - 遍历所有 `(i, j)` 计算 `sum(i, j)`，检查是否等于 `s`。

### **3. 二分查找（O(n log n)）**

- **思路**：
    - 先计算 `prefix_sum`，然后对 `prefix[j] - s` 进行二分查找。

---

## **LintCode 相关题目**

|**题号**|**题目名称**|**难度**|**核心技术**|
|---|---|---|---|
|**LintCode 1712**|Binary Subarrays With Sum|⭐⭐⭐|**滑动窗口 + 双指针**|
|**LintCode 1075**|Subarray Product Less Than K|⭐⭐⭐|**滑动窗口 + 乘积**|
|**LintCode 1380**|Subarray Sum Equals K|⭐⭐⭐|**前缀和 + 哈希表**|
|**LintCode 604**|Window Sum|⭐⭐|**滑动窗口**|

---

## **总结**

1. **最优解法：滑动窗口 `O(n)`**
    
    - **两个左指针 `left1` 和 `left2` 计算满足 `sum == s` 的子数组**。
2. **其他解法**
    
    - **前缀和 + 哈希表（O(n)）**，适用于 **任意整数数组**。
    - **暴力解法（O(n²)）**，仅适用于小规模数据。
    - **二分查找（O(n log n)）**，适用于 **预处理后查询**。