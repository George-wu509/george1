Lintcode 167
你有两个用链表代表的整数，其中每个节点包含一个数字。数字存储按照在原来整数中`相反`的顺序，使得第一个数字位于链表的开头。写出一个函数将两个整数相加，用链表形式返回和。

**样例 1:**
```python
"""
输入: 7->1->6->null, 5->9->2->null
输出: 2->1->9->null	
样例解释: 617 + 295 = 912, 912 转换成链表:  2->1->9->null
```

**样例
```python
"""
输入:  3->1->5->null, 5->9->2->null
输出: 8->0->8->null	
样例解释: 513 + 295 = 808, 808 转换成链表: 8->0->8->null
```


```python
def add_lists(self, l1, l2) -> list:       
	dummy = ListNode(None)
	tail = dummy
	
	carry = 0 
	while l1 or l2 or carry:
		num = 0 
		if l1:
			num += l1.val 
			l1 = l1.next
		if l2:
			num += l2.val 
			l2 = l2.next
		num += carry
		digit, carry = num % 10, num // 10
		node = ListNode(digit)
		tail.next, tail = node, node 
	return dummy.next
```
pass


## **LintCode 167: Add Two Numbers**

### **解法分析**

本題目要求對應加總 **兩個非空鏈表所表示的數字**，其中：

- 每個節點 **存儲一位數**（即 `0-9`）。
- 整數是 **逆序存儲**（最低位數在鏈表頭部）。
- 結果仍以**逆序存儲**在鏈表中。

例如：
```python
l1 = 2 → 4 → 3   (表示 342)
l2 = 5 → 6 → 4   (表示 465)
輸出應為：7 → 0 → 8   (表示 807)
```

---

### **解法思路**

1. **初始化變數**
    
    - `dummy` 為 **虛擬頭節點**（方便處理頭節點的插入）。
    - `tail` 為 **當前鏈表的尾節點**（用於連接新節點）。
    - `carry` 為 **進位標誌**，初始為 `0`。
2. **遍歷 `l1` 和 `l2`**
    
    - 當 `l1` 或 `l2` 不為 `None`，或有進位 `carry`，則繼續執行：
        - 取 `l1.val`（若 `l1` 為 `None`，則為 `0`）。
        - 取 `l2.val`（若 `l2` 為 `None`，則為 `0`）。
        - 加總當前數字和 `carry`，計算 **個位數 `digit`** 和 **進位 `carry`**：
            - `digit = num % 10`
            - `carry = num // 10`
        - 創建 `ListNode(digit)`，並將其連接到 `tail`。
3. **返回結果**
    
    - `dummy.next` 為最終結果的頭節點。

---

### **變數表**

|變數名稱|角色|作用|初始值|變化過程|
|---|---|---|---|---|
|`dummy`|虛擬頭節點|幫助構建結果鏈表|`ListNode(None)`|連接新的數字節點|
|`tail`|遍歷指標|指向結果鏈表的最後一個節點|`dummy`|每次更新為 `tail.next`|
|`carry`|進位標誌|記錄進位數字|`0`|每次計算 `carry = num // 10`|
|`num`|當前計算值|當前兩數相加再加上 `carry`|`0`|每次更新為 `l1.val + l2.val + carry`|
|`digit`|取出當前位|`num` 的個位數|`num % 10`|存入新節點|
|`l1`|遍歷指標|遍歷第一個數鏈表|`l1`|每次移動至 `l1.next`|
|`l2`|遍歷指標|遍歷第二個數鏈表|`l2`|每次移動至 `l2.next`|

---

### **時間與空間複雜度分析**

#### **時間複雜度：O(max(m, n))**

- 兩個鏈表的長度分別為 `m` 和 `n`，最多遍歷 `max(m, n)` 次，因此時間複雜度為 **O(max(m, n))**。

#### **空間複雜度：O(max(m, n))**

- 除了輸出鏈表之外，**只使用了幾個變數**（即 `dummy`、`tail`、`carry`），額外空間為 O(1)。
- 但最壞情況下，鏈表長度等於 `max(m, n) + 1`（最高位進位），所以 **結果鏈表占 O(max(m, n))** 空間。

---

### **其他解法**

4. **遞歸解法（O(max(m, n)) 時間, O(max(m, n)) 空間）**
    
    - 用遞歸方式模擬加法，每次遞歸處理一位數，最後返回 `head`。
5. **轉換為整數運算（O(m + n) 時間, O(1) 空間）**
    
    - 先將 `l1` 和 `l2` 轉為數字，相加後再拆分為鏈表。
6. **棧解法（O(m + n) 時間, O(m + n) 空間）**
    
    - 先將兩條鏈表的數字壓入棧中，依序彈出來相加，構建新的鏈表。

---

### **結論**

- **最優解法為迭代法**，因為時間複雜度為 **O(max(m, n))**，且額外空間開銷低（O(1)）。
- 遞歸方法雖然概念直觀，但會產生 **O(max(m, n)) 的遞歸棧空間**。
- 轉換為整數運算的方法，**如果數字過大可能導致溢出**，不適合實際應用。