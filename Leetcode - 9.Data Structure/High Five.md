Lintcode 613
每个学生有两个属性 `ID` 和 `scores`。找到每个学生最高的5个分数的平均值。

例1:
```python
"""
输入: 
[[1,91],[1,92],[2,93],[2,99],[2,98],[2,97],[1,60],[1,58],[2,100],[1,61]]
输出:
1: 72.40
2: 97.40
```
例2:
```python
"""
输入:
[[1,90],[1,90],[1,90],[1,90],[1,90],[1,90]]
输出: 
1: 90.00
```


```python
def highFive(self, results):
	hash = dict()
	for r in results:
		if r.id not in hash:
			hash[r.id] = []

		hash[r.id].append(r.score)
		if len(hash[r.id]) > 5:
			index = 0
			for i in range(1, 6):
				if hash[r.id][i] < hash[r.id][index]:
					index = i

			hash[r.id].pop(index)

	answer = dict()
	for id, scores in hash.items():
		answer[id] = sum(scores) / 5.0

	return answer
```
pass


# **LintCode 613: High Five 解法分析**

## **解題目標**

給定一個 `Student(id, score)` 的列表 `results`，每個學生 `id` 可能有多個 `score`。  
我們的目標是：

1. **找出每個學生的前 5 高分數**。
2. **計算這 5 個分數的平均值**，並返回 `{student_id: 平均分}` 的字典。

---

## **解法核心**

這是一個 **數據篩選與統計問題**，我們需要：

1. **為每個學生 `id` 儲存分數**。
2. **維護每個學生的前 5 個最高分數**。
3. **計算這 5 個分數的平均值**。

---

### **為何要使用 `dict + 最小堆 (Min Heap)`？**

- **最直接的方法是先排序 (`O(n log n)`)，但不夠高效**。
- **我們只需要維護「前 5 高分」**，可以用 **最小堆 (`Min Heap`)**，時間複雜度 `O(n log 5) = O(n)`：
    - **當堆大小小於 5**：直接 `push`。
    - **當堆大小等於 5，且新分數更大**：用 `heapq.heappushpop()` 替換最小值，確保堆中始終保持 **最高的 5 個分數**。

---

## **解法步驟**

### **Step 1: 使用 `dict` 儲存每個學生的 `Min Heap`**

1. 使用 `hash = {}`，其中 `hash[id]` **維護一個 `Min Heap` (最小堆)**，來存 **該學生的前 5 高分**。
2. **遍歷 `results`**：
    - 若 `id` 不存在於 `hash`，則創建一個 `Min Heap`。
    - **當 `heap` 長度小於 5**，直接 `push`。
    - **當 `heap` 長度為 5，且新分數比 `heap` 最小值大**，則替換最小值 (`heapq.heappushpop()`)。

python

複製編輯

`import heapq  def highFive(self, results):     hash = {}  # 學生 ID -> Min Heap          for r in results:         if r.id not in hash:             hash[r.id] = []                  heapq.heappush(hash[r.id], r.score)         if len(hash[r.id]) > 5:             heapq.heappop(hash[r.id])  # 保持 Heap 長度為 5`

---

### **Step 2: 計算前 5 高分的平均值**

- **遍歷 `hash`**，對每個 `id`，計算 `sum(heap) / 5.0`，並存入 `answer` 字典。

python

複製編輯

    `answer = {}     for id, scores in hash.items():         answer[id] = sum(scores) / 5.0      return answer`

---

## **變數定義**

|變數名稱|作用|
|---|---|
|`hash`|`dict`，儲存每個學生的 **最小堆 (Min Heap)**|
|`heapq`|Python 的 `heapq` 模塊，維護最小堆|
|`answer`|`dict`，存放 `{id: 前 5 高分平均數}`|
|`r.id`|當前學生的 `id`|
|`r.score`|當前學生的分數|

---

## **具體範例**

### **範例 1**

text

複製編輯

`輸入: results = [     (1, 91), (1, 92), (1, 60), (1, 65), (1, 87), (1, 100),      (2, 80), (2, 85), (2, 88), (2, 90), (2, 92), (2, 95) ]`

---

### **Step 1: 儲存 `Min Heap`**

|學生 `id`|新增分數|Heap (`前 5 高分`)|
|---|---|---|
|`1`|`91`|`[91]`|
|`1`|`92`|`[91, 92]`|
|`1`|`60`|`[60, 91, 92]`|
|`1`|`65`|`[60, 65, 91, 92]`|
|`1`|`87`|`[60, 65, 87, 91, 92]`|
|`1`|`100`|`[65, 87, 91, 92, 100]` (`60` 被移除)|
|`2`|`80`|`[80]`|
|`2`|`85`|`[80, 85]`|
|`2`|`88`|`[80, 85, 88]`|
|`2`|`90`|`[80, 85, 88, 90]`|
|`2`|`92`|`[80, 85, 88, 90, 92]`|
|`2`|`95`|`[85, 88, 90, 92, 95]` (`80` 被移除)|

---

### **Step 2: 計算平均值**

|學生 `id`|`heap`|計算方式|結果|
|---|---|---|---|
|`1`|`[65, 87, 91, 92, 100]`|`(65+87+91+92+100) / 5`|`87.0`|
|`2`|`[85, 88, 90, 92, 95]`|`(85+88+90+92+95) / 5`|`90.0`|

**輸出**

text

複製編輯

`{1: 87.0, 2: 90.0}`

---

## **時間與空間複雜度分析**

### **時間複雜度**

|操作|複雜度|說明|
|---|---|---|
|**遍歷 `results`**|`O(n log 5) = O(n)`|每次插入堆 `O(log 5) = O(1)`|
|**計算平均值**|`O(n)`|遍歷 `hash`，計算 `sum()`|
|**總計**|`O(n)`|高效解法|

---

### **空間複雜度**

|結構|空間複雜度|說明|
|---|---|---|
|`hash`|`O(n)`|存儲每個學生的 `heap`|
|`answer`|`O(n)`|存放 `id` 對應的平均值|
|**總計**|`O(n)`|主要來自 `hash`|

---

## **其他解法 (不寫 Code)**

1. **先排序再取前 5 高分 (`O(n log n)`)**
    
    - 先對 `results` 按 `(id, score)` 排序，再逐個選取 `top 5` 計算平均值。
    - **劣勢**：排序時間 `O(n log n)`，不如最小堆。
2. **`OrderedDict + 手動排序` (`O(n log n)`)**
    
    - 使用 `OrderedDict` 儲存 `id: [scores]`，每次插入時 **維護遞減排序**。
    - **劣勢**：排序 `O(log 5) = O(1)`，但插入較慢。

---

## **總結**

|**解法**|**時間複雜度**|**適用場景**|**優缺點**|
|---|---|---|---|
|**最小堆 (`O(n)`)**|`O(n)`|最快適用於大數據|✅ 插入快，維護 `O(1)`|
|**排序後取 `top 5` (`O(n log n)`)**|`O(n log n)`|適用於小數據|❌ 排序較慢|
|**`OrderedDict` (`O(n log n)`)**|`O(n log n)`|適用於已排序數據|❌ 插入慢|

✅ **最佳解法：最小堆 (`O(n)`)，適合大數據場景，時間效率最高！** 🚀

  

O