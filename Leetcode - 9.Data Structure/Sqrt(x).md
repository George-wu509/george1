Lintcode 141
实现 `int sqrt(int x)` 函数，计算并返回 _x_ 的平方根。

```python
"""
样例 1:
输入:  0
	输出: 0


样例 2:
	输入: 3
	输出: 1
	
	样例解释：
	返回对x开根号后向下取整的结果。

样例 3:
	输入: 4
	输出: 2
```


```python
    def sqrt(self, x: int) -> int:
        if x == 0:
            return 0
        
        C, x0 = float(x), float(x)
        while True:
            xi = 0.5 * (x0 + C / x0)
            if abs(x0 - xi) < 1e-7:
                break
            x0 = xi
        
        return int(x0)
```
pass


## **LintCode 141: Sqrt(x) 解法分析**

### **解法核心：牛頓法 (Newton's Method)**

本題要求計算 **√x 的整數部分**，也就是求平方根的 **向下取整值**。

最簡單的方法是從 `0` 嘗試平方，直到 `y^2 > x`，但這樣時間複雜度為 `O(√x)`，不夠高效。**牛頓法 (Newton’s Method, 又稱迭代法)** 利用 **數值逼近** 的方式，以 `O(log x)` 速度找到平方根。

---

## **解法步驟**

**牛頓法** 是一種 **數值逼近演算法**，用來解決 `f(x) = 0` 的問題。在此問題中，我們要找的是：

$f(x) = x^2 - C = 0$

其導數：

$f'(x) = 2x$

使用牛頓迭代公式：

$x_{i+1} = \frac{1}{2} \left( x_i + \frac{C}{x_i} \right)$

來逐步更新 `x_i`，直到收斂 (`|x_i - x_{i+1}|` 小於某個閥值 `ε`)。

---

### **變數定義**

|變數名稱|作用|
|---|---|
|`x`|目標值，要計算的平方根|
|`C`|`float(x)`，即要求的平方根的數值|
|`x0`|迭代變數，初始值設為 `x`|
|`xi`|牛頓法更新後的新值|
|`ε = 1e-7`|誤差閾值，確保結果收斂|

---

### **具體範例**

#### **範例 1**

text

複製編輯

`輸入: x = 8 計算: sqrt(8) 向下取整`

| 迭代步驟 | `x0` | `xi = 0.5 * (x0 + C / x0)` | `|x0 - xi|` | |---------|----|----------------------|------------| | 初始值 | `8` | `0.5 * (8 + 8/8) = 4.5` | `3.5` | | 1 | `4.5` | `0.5 * (4.5 + 8/4.5) = 3.1333` | `1.3667` | | 2 | `3.1333` | `0.5 * (3.1333 + 8/3.1333) = 2.8444` | `0.2889` | | 3 | `2.8444` | `0.5 * (2.8444 + 8/2.8444) = 2.8285` | `0.0159` | | 4 | `2.8285` | `0.5 * (2.8285 + 8/2.8285) = 2.8284` | `≈ 0` (收斂) |

**輸出結果：** `int(2.8284) = 2`

---

#### **範例 2**

text

複製編輯

`輸入: x = 10 計算: sqrt(10) 向下取整`

| 迭代步驟 | `x0` | `xi = 0.5 * (x0 + C / x0)` | `|x0 - xi|` | |---------|----|----------------------|------------| | 初始值 | `10` | `0.5 * (10 + 10/10) = 5.5` | `4.5` | | 1 | `5.5` | `0.5 * (5.5 + 10/5.5) = 3.6591` | `1.8409` | | 2 | `3.6591` | `0.5 * (3.6591 + 10/3.6591) = 3.1960` | `0.4631` | | 3 | `3.1960` | `0.5 * (3.1960 + 10/3.1960) = 3.1625` | `0.0335` | | 4 | `3.1625` | `0.5 * (3.1625 + 10/3.1625) = 3.1623` | `≈ 0` (收斂) |

**輸出結果：** `int(3.1623) = 3`

---

## **時間與空間複雜度分析**

### **時間複雜度**

牛頓法的 **迭代次數大約是 `O(log x)`**：

- 由於每次迭代 `x_i` 會 **至少減少一半的誤差**，因此整體時間複雜度為： O(log⁡x)O(\log x)O(logx)
- 這比 **暴力枚舉 (`O(√x)`)** 更快。

### **空間複雜度**

- **只使用常數變數 (`x0, xi, C`)**，不額外開陣列儲存數據，**空間複雜度 `O(1)`**。

---

## **其他解法 (不寫 Code)**

1. **二分搜尋 (`O(log x)`)**
    
    - 設定 `left = 0, right = x`，每次取中間值 `mid`：
        - 若 `mid^2 == x`，則返回 `mid`
        - 若 `mid^2 > x`，則縮小範圍 (`right = mid - 1`)
        - 若 `mid^2 < x`，則擴展範圍 (`left = mid + 1`)
    - 時間複雜度 `O(log x)`，但不如牛頓法快。
2. **暴力遍歷 (`O(√x)`)**
    
    - 從 `0` 開始枚舉 `y`，直到 `y^2 > x`。
    - 時間複雜度 `O(√x)`，適合 `x` 很小時。
3. **內建函數 (`O(1)`)**
    
    - Python 的 `math.sqrt(x)` 計算浮點數平方根，`int(math.sqrt(x))` 直接返回整數部分。
    - **適用於系統內建函數的場景**，但 `math.sqrt` 底層仍可能使用牛頓法或二分搜尋。

---

## **總結**

|**解法**|**時間複雜度**|**適用場景**|**優缺點**|
|---|---|---|---|
|**牛頓法 (Newton's Method)**|`O(log x)`|高效數值逼近平方根|**最快的數值方法**，但需了解收斂條件|
|**二分搜尋 (Binary Search)**|`O(log x)`|需要整數結果時|不如牛頓法快|
|**暴力枚舉 (Brute Force)**|`O(√x)`|`x` 很小時|速度慢|
|**內建函數 `math.sqrt(x)`**|`O(1)`|內建函數可用時|受限於函數庫|

### **最佳選擇**

✅ **牛頓法 (Newton's Method) 為最優解**，計算 `O(log x)`，比二分搜尋快，且適用於大數字 `x`。



### **牛頓迭代法 (Newton's Method) 如何導出平方根公式**

#### **1. 牛頓迭代法的基本原理**

牛頓迭代法（Newton-Raphson Method）是一種 **數值方法**，用來解非線性方程：

f(x)=0f(x) = 0f(x)=0

它的核心概念是：

- 給定一個方程 f(x)=0f(x) = 0f(x)=0，希望求解根 x∗x^*x∗。
- 從初始點 x0x_0x0​ 開始，**使用切線近似函數的零點來更新 xix_ixi​**，逐步逼近正確解。

牛頓法的通用迭代公式如下：

xi+1=xi−f(xi)f′(xi)x_{i+1} = x_i - \frac{f(x_i)}{f'(x_i)}xi+1​=xi​−f′(xi​)f(xi​)​

其中：

- f(x)f(x)f(x) 是目標函數
- f′(x)f'(x)f′(x) 是 f(x)f(x)f(x) 的導數
- xix_ixi​ 是當前的近似值
- xi+1x_{i+1}xi+1​ 是下一步的近似值

---

#### **2. 用牛頓法求平方根**

**我們的目標是計算平方根**，也就是：

C\sqrt{C}C​

這相當於解方程：

f(x)=x2−C=0f(x) = x^2 - C = 0f(x)=x2−C=0

在這個方程中：

- 目標函數： f(x)=x2−Cf(x) = x^2 - Cf(x)=x2−C
- 其導數： f′(x)=2xf'(x) = 2xf′(x)=2x

根據牛頓法的通用公式：

xi+1=xi−f(xi)f′(xi)x_{i+1} = x_i - \frac{f(x_i)}{f'(x_i)}xi+1​=xi​−f′(xi​)f(xi​)​

將 f(x)=x2−Cf(x) = x^2 - Cf(x)=x2−C 和 f′(x)=2xf'(x) = 2xf′(x)=2x 代入：

xi+1=xi−xi2−C2xix_{i+1} = x_i - \frac{x_i^2 - C}{2x_i}xi+1​=xi​−2xi​xi2​−C​

化簡：

xi+1=xi−xi2+C2xix_{i+1} = x_i - \frac{x_i}{2} + \frac{C}{2x_i}xi+1​=xi​−2xi​​+2xi​C​

再整理：

xi+1=12(xi+Cxi)x_{i+1} = \frac{1}{2} \left( x_i + \frac{C}{x_i} \right)xi+1​=21​(xi​+xi​C​)

這就是**牛頓法的平方根計算公式**。

---

#### **3. 幾何直觀解釋**

牛頓法的思想可以幾何解釋為：

- 在曲線 y=f(x)=x2−Cy = f(x) = x^2 - Cy=f(x)=x2−C 上，選擇初始點 x0x_0x0​。
- 在 x0x_0x0​ 處做**切線**，找到它與 xxx-軸的交點，即新的近似值 x1x_1x1​。
- 重複這個過程，**切線逐步逼近真正的根** C\sqrt{C}C​。

這樣的迭代方式可以快速收斂到正確的平方根。

---

#### **4. 例子推導**

以 **求解 8\sqrt{8}8​** 為例，使用牛頓法：

1. 設初始值 x0=8x_0 = 8x0​=8。
2. 計算下一步： x1=12(8+88)=12(8+1)=4.5x_1 = \frac{1}{2} \left( 8 + \frac{8}{8} \right) = \frac{1}{2} (8 + 1) = 4.5x1​=21​(8+88​)=21​(8+1)=4.5
3. 再計算： x2=12(4.5+84.5)=12(4.5+1.777)=3.1389x_2 = \frac{1}{2} \left( 4.5 + \frac{8}{4.5} \right) = \frac{1}{2} (4.5 + 1.777) = 3.1389x2​=21​(4.5+4.58​)=21​(4.5+1.777)=3.1389
4. 繼續迭代： x3=12(3.1389+83.1389)=2.8444x_3 = \frac{1}{2} \left( 3.1389 + \frac{8}{3.1389} \right) = 2.8444x3​=21​(3.1389+3.13898​)=2.8444
5. 最後： x4=12(2.8444+82.8444)=2.8285x_4 = \frac{1}{2} \left( 2.8444 + \frac{8}{2.8444} \right) = 2.8285x4​=21​(2.8444+2.84448​)=2.8285

牛頓法每次迭代會 **大幅減少誤差**，快速逼近答案。

---

### **5. 時間與收斂分析**

牛頓法每次迭代的收斂速度是 **平方級**，即誤差縮小為原來的平方：

誤差=O(1/2k)\text{誤差} = O(1 / 2^k)誤差=O(1/2k)

- 這意味著 **每迭代一次，精度大約翻倍**。
- 只需要 **O(log n)** 次迭代即可達到高精度。

相比於暴力法 O(n)O(\sqrt{n})O(n​)，牛頓法明顯更快。