
詳細解釋位元運算中的「異或運算」和「與運算」，並透過例子說明它們如何應用。此外，也會介紹其他在 LeetCode 問題中常用的位元運算。


|                              |                                                         |                |
| ---------------------------- | ------------------------------------------------------- | -------------- |
| **異或運算 (XOR, `^`)**          | 0 ^ 0 = 0<br>0 ^ 1 = 1<br>1 ^ 0 = 1<br>1 ^ 1 = 0        | 兩者不同就是1        |
| **與運算 (AND, `&`)**           | 0 & 0 = 0 <br>0 & 1 = 0 <br>1 & 0 = 0 <br>1 & 1 = 1     | 要所有都是1才是1      |
| **或運算 (OR, \|)**             | 0 \| 0 = 0 <br>0 \| 1 = 1 <br>1 \| 0 = 1 <br>1 \| 1 = 1 | 只要有1才是1        |
| **非運算 (NOT, `~`)**           | 0 -> 1<br>1 -> 0                                        |                |
| **左移運算 (Left Shift, `<<`)**  | 5≪2=20  (`0000 0101` 左移 2 位)                            | 相當於將 `x` 乘以 2n |
| **右移運算 (Right Shift, `>>`)** | 5≫1=2 (`0000 0101` 右移 1 位)                              | 相當於將 `x` 除以 2n |






---

### 1. 異或運算 (XOR, `^`)

**中文解釋：**

異或運算（Exclusive OR，簡寫為 XOR），顧名思義就是「不同才為真」。在二進制位元層面上，當兩個位元**不同**時，結果為 `1`；當兩個位元**相同**時，結果為 `0`。

**運算規則：**

- `0 ^ 0 = 0` (相同為 0)
- `0 ^ 1 = 1` (不同為 1)
- `1 ^ 0 = 1` (不同為 1)
- `1 ^ 1 = 0` (相同為 0)

**例子說明：**

假設我們想計算 5⊕3：

- 5 的二進制表示（假設 8 位）：`0000 0101`
- 3 的二進制表示（假設 8 位）：`0000 0011`

```
  0000 0101  (5)
^ 0000 0011  (3)
-----------
  0000 0110  (6)
```

所以，5⊕3=6。

**異或運算的性質（對 LeetCode 很有幫助）：**

1. **交換律和結合律：**
    
    - A⊕B=B⊕A
    - (A⊕B)⊕C=A⊕(B⊕C) 這意味著你可以隨意改變運算的順序。
2. **任何數與 0 異或，結果是它本身：**
    
    - A⊕0=A
3. **任何數與它本身異或，結果是 0：**
    
    - A⊕A=0 這個性質非常有用，可以用來**找出數組中唯一出現的數字**。如果一個數組中所有數字都出現兩次，只有一個數字出現一次，那麼將所有數字異或起來，結果就是那個唯一出現的數字。因為成對出現的數字會互相抵消變成 0。
        
    - **例子：** `nums = [2, 1, 4, 1, 2]`
        
        - `2 ^ 1 ^ 4 ^ 1 ^ 2`
        - =(22)(11)4
        - $= 0 ^ 0 ^ 4$
        - =4
4. **不使用額外變數交換兩個數的值：**
    
    - a=a⊕b
    - b=a⊕b (此時 b 變為原始的 a)
    - a=a⊕b (此時 a 變為原始的 b) 這個技巧在一些對空間複雜度有要求的場景下很有用，儘管現代 Python 通常會用 `a, b = b, a` 這種更清晰的寫法。
5. **判斷兩個數是否相等：**
    
    - 如果 A⊕B=0，則 A=B。

---

### 2. 與運算 (AND, `&`)

**中文解釋：**

與運算，只有當兩個位元**都是 `1` 時**，結果才為 `1`；否則為 `0`。它就像邏輯上的「且」。

**運算規則：**

- `0 & 0 = 0`
- `0 & 1 = 0`
- `1 & 0 = 0`
- `1 & 1 = 1`

**例子說明：**

假設我們想計算 $5 \text{ & } 3$：

- 5 的二進制表示：`0000 0101`
- 3 的二進制表示：`0000 0011`

```
  0000 0101  (5)
& 0000 0011  (3)
-----------
  0000 0001  (1)
```

所以，$5 \text{ & } 3 = 1$。

**與運算的性質（對 LeetCode 很有幫助）：**

1. **判斷奇偶性：**
    
    - 如果一個數 `num` 與 `1` 進行與運算 `(num & 1)` 的結果是 `1`，那麼這個數是奇數。
        
    - 如果結果是 `0`，那麼這個數是偶數。 這是因為奇數的二進制最低位一定是 `1`，偶數的最低位一定是 `0`。
        
    - **例子：**
        
        - `5` ( `...0101` ) `& 1` ( `...0001` ) = `0001` (1)，所以 5 是奇數。
        - `6` ( `...0110` ) `& 1` ( `...0001` ) = `0000` (0)，所以 6 是偶數。
2. **清零特定位 (Masking)：**
    
    - 可以利用與運算將數字的某些位元清零。例如，`x & (~mask)` 可以將 `mask` 為 1 的那些位在 `x` 中清零。
    - 在前面的 `Sum of Two Integers` 例子中，`a & self.MASK2` 就是用來判斷 `a` 的最高位是否為 1。`MASK2` 在除了最高位之外都是 0，所以與 `a` 進行 `&` 運算時，結果只會保留 `a` 的最高位。
3. **提取特定位：**
    
    - 通過與一個只有某一位是 1 的數進行與運算，可以檢查該位是否為 1。例如，`(num & (1 << i))` 可以檢查 `num` 的第 `i` 位是否為 `1`。
4. **判斷一個數是否是 2 的冪：**
    
    - 如果一個正整數 `num` 是 2 的冪（如 1, 2, 4, 8...），那麼它的二進制表示中只有一位是 `1`。
    - 因此，`num > 0` 且 `(num & (num - 1)) == 0`。
        - 例如：`8` 是 `1000`，`8 - 1` 是 `7` (`0111`)。 `1000 & 0111 = 0000`。
        - `6` 是 `0110`，`6 - 1` 是 `5` (`0101`)。 `0110 & 0101 = 0100` (不為 0)。

---

### 3. 其他對 LeetCode 有幫助的位元運算

1. **或運算 (OR, `|`)**
    
    - **規則：** 只要兩個位元中有一個是 `1`，結果就是 `1`；只有當兩個位元都是 `0` 時，結果才為 `0`。
    - **用途：** 通常用於**設定特定位元為 `1`**。例如，`num | (1 << i)` 可以將 `num` 的第 `i` 位設定為 `1`，而不影響其他位。
    - **例子：** `5` (`0101`) `| 3` (`0011`)
        
        ```
          0000 0101  (5)
        | 0000 0011  (3)
        -----------
          0000 0111  (7)
        ```
        
        5 | 3=7
2. **非運算 / 反轉 (NOT, `~`)**
    
    - **規則：** 將每個位元取反，`0` 變 `1`，`1` 變 `0`。
    - **注意：** 在 Python 中，`~x` 的結果是 `-(x+1)`。這是因為 Python 的整數是基於無限精度的，`~` 操作會考慮所有位元並產生一個基於二補數表示的負數。如果需要特定的位元反轉，通常需要配合遮罩。
    - **用途：** 結合其他運算來實現特定位元的操作，例如 `~mask` 可以創建一個反轉遮罩。
3. **左移運算 (Left Shift, `<<`)**
    
    - **規則：** `x << n` 表示將數字 `x` 的二進制位元向左移動 `n` 位。右邊空出的位元用 `0` 填充。
    - **效果：** 相當於將 `x` 乘以 2n。
    - **用途：** 快速計算 2n（如 `1 << n`），或在位元操作中移動位元。在 `Sum of Two Integers` 中，`carry << 1` 用於將進位移到正確的位置。
    - **例子：** 5≪2 (`0000 0101` 左移 2 位)
        
        ```
          0000 0101  (5)
        << 2
        -----------
          0001 0100  (20)
        ```
        
        5≪2=20
4. **右移運算 (Right Shift, `>>`)**
    
    - **規則：** `x >> n` 表示將數字 `x` 的二進制位元向右移動 `n` 位。
        
    - **效果：** 相當於將 `x` 除以 2n (向下取整)。
        
    - **兩種右移：**
        
        - **邏輯右移 (Logical Right Shift)：** 左邊空出的位元用 `0` 填充。
        - **算術右移 (Arithmetic Right Shift)：** 左邊空出的位元用符號位（最左邊的位元）填充，以保持數字的正負性。
        - 在 Python 中，`>>` 對於正數是邏輯右移，對於負數是算術右移（保持符號）。
    - **用途：** 快速進行除法，或遍歷數字的位元。
        
    - **例子：** 5≫1 (`0000 0101` 右移 1 位)
        
        ```
          0000 0101  (5)
        >> 1
        -----------
          0000 0010  (2)
        ```
        
        5≫1=2
        

---

### 位元運算在 LeetCode 中的應用場景

- **優化速度：** 位元運算通常比算術運算（加減乘除）更快，在處理大量數據或對性能有極高要求時有用。
- **空間優化：** 將多個布林值或小整數打包到一個整數的位元中，節省記憶體。
- **集合操作：** 使用位元遮罩表示集合，例如 `1 << i` 表示包含元素 `i` 的集合。
- **狀態壓縮 DP (Dynamic Programming)：** 在某些 DP 問題中，用一個整數的位元來表示一種狀態（例如哪些元素被選中）。
- **特定問題類型：**
    - **找出唯一出現的數字** (Single Number 系列問題)
    - **判斷奇偶性** (如 `num & 1`)
    - **檢查或設定特定位元** (Bit Manipulation 問題)
    - **無符號加法/減法** (如您提供的 `Sum of Two Integers`)