Lintcode 139
给定一个整型数组，找出主元素，它在数组中的出现次数大于数组元素个数的二分之一。

**样例 1：**
输入：
```python
#数组 = [1, 1, 1, 1, 2, 2, 2]
```
输出：
```python
1
```
解释：
数组1的个数大于数组元素的二分之一。

**样例 2：**
输入：
```python
#数组 = [1, 1, 1, 2, 2, 2, 2]
```
输出：
```python
2
```
解释：
数组中2的个数大于数组元素的二分之一。




```python
class Solution:
    def majority_number(self, nums: List[int]) -> int:
        n = len(nums)
        x, cnt = -1, 0
        for i in nums:
            if not cnt:
                x = i
            if x == i:
                cnt += 1
            else:
                cnt -= 1 
        return x if cnt and nums.count(x) > n // 2 else -1
```
pass

解釋:
step1.  x候選數,  cnt 計數器. 從i 遍歷nums. 如果x是相同的, 則x維持, cnt+1, 如果遇到不同的num, 則x維持, cnt-1. 
step2. 如果cnt減到0, 則x更新, 繼續x是相同的, 則x維持, cnt+1

### **LintCode 139 - Majority Number**

這道題目要求 **找出在數組中出現次數超過 `n/2` 的數字**，即「**多數元素（Majority Element）**」。

這是一道經典的 **Boyer-Moore Voting Algorithm（摩爾投票算法）** 問題，這個算法的特點是能夠 **O(n) 時間、O(1) 空間** 內解決問題。

---

## **解法解析**

這裡使用 **摩爾投票算法（Boyer-Moore Voting Algorithm）** 來解決問題。

### **思路**

1. **摩爾投票算法核心概念**
    
    - 若一個數字出現次數超過 `n/2`，則它在數組中出現的頻率一定比其他所有數字出現頻率的總和還要高。
    - 透過「計票」的方式，每當遇到相同的數時計數 `cnt+1`，不同時計數 `cnt-1`。
    - 若計數 `cnt` 變為 `0`，則更換當前候選數。
2. **步驟**
    
    - 設定 **候選元素 `x`** 和 **計數器 `cnt`**，初始值為 `-1` 和 `0`。
    - 遍歷 `nums`：
        - 若 `cnt = 0`，則更新候選元素 `x` 為當前數字。
        - 若當前數字 `i == x`，則 `cnt += 1`。
        - 若當前數字 `i != x`，則 `cnt -= 1`。
    - 最後的 `x` 可能是答案，但要再遍歷一次 `nums` 來檢查它的出現次數是否超過 `n/2`。

---

## **具體舉例**

假設 `nums = [3, 1, 3, 3, 2, 3, 3]`，執行過程如下：

| `i` | `nums[i]` | `x`（候選數） | `cnt`（計數器） |
| --- | --------- | -------- | ---------- |
| 0   | 3         | 3        | 1          |
| 1   | 1         | 3        | 0          |
| 2   | 3         | 3        | 1          |
| 3   | 3         | 3        | 2          |
| 4   | 2         | 3        | 1          |
| 5   | 3         | 3        | 2          |
| 6   | 3         | 3        | 3          |

最終候選數為 `3`，再檢查 `nums.count(3) = 5`，超過 `n/2 = 3.5`，因此答案為 `3`。

---

## **時間與空間複雜度分析**

- **時間複雜度：O(n)**
    
    - **第一輪遍歷**：計算 **候選數 `x`**，需 O(n)。
    - **第二輪遍歷**：檢查 `x` 出現次數是否 > `n/2`，需 O(n)。
    - **總計 O(n) + O(n) = O(n)**。
- **空間複雜度：O(1)**
    
    - 只使用兩個變數 `x` 和 `cnt`，因此 **空間複雜度為 O(1)**，非常高效。

---

## **其他解法**

### **1. 哈希表（HashMap 計數法）**

- **思路**：使用字典（`Counter`）統計每個數的出現次數，最後返回出現次數大於 `n/2` 的數字。
- **時間複雜度**：O(n)
- **空間複雜度**：O(n)

### **2. 排序法**

- **思路**：先對 `nums` 進行排序，則 `nums[n//2]` 一定是多數元素。
- **時間複雜度**：O(n log n)（排序）
- **空間複雜度**：O(1)（若使用原地排序）

### **3. 分治法（Divide and Conquer）**

- **思路**：使用遞迴方式將數組拆分成左右兩部分，分別找出左右多數元素，然後合併判斷哪個是全局多數元素。
- **時間複雜度**：O(n log n)
- **空間複雜度**：O(log n)（遞歸棧）

---

## **總結**

- **最佳解法**：摩爾投票算法（O(n) 時間，O(1) 空間）。
- **次佳解法**：HashMap 計數法，雖然時間為 O(n)，但額外需要 O(n) 空間。
- **排序法** 和 **分治法** 也可行，但時間複雜度較高，通常不如摩爾投票算法高效。