Lintcode 156
我们以一个 `Interval` 类型的列表 `intervals` 来表示若干个区间的集合，其中单个区间为 `(start, end)`。你需要**合并所有重叠的区间**，并返回一个**不重叠的区间数组**，该数组需**恰好覆盖输入中的所有区间**。

**样例1:**

```python
#输入: [(1,3)]
#输出: [(1,3)]
```

**样例 2:**

```python
#输入:  [(1,3),(2,6),(8,10),(15,18)]
#输出: [(1,6),(8,10),(15,18)]
```

```python
    def merge(self, intervals):
        intervals = sorted(intervals, key=lambda x: x.start)
        result = []
        for interval in intervals:
            if len(result) == 0 or result[-1].end < interval.start:
                result.append(interval)
            else:
                result[-1].end = max(result[-1].end, interval.end)
        return result
```
pass

解釋:
step1: 先對intervals排序, 並create 空的result = []
step2: 從頭開始for loop檢查intervals, 如果result是空的直接加入
step3: 比對for loop裡的interval跟result的最後一個. 如果沒有overlap則append加入result, 如果有overlap則跟result最後一個合併.

### **Lintcode 156 Merge Intervals 解法分析**

#### **問題理解**

給定一組區間 `intervals`，每個區間包含 `start` 和 `end`。要求將重疊的區間合併，返回一組不重疊的區間。

例如：

`輸入: [(1,3), (2,6), (8,10), (15,18)] 輸出: [(1,6), (8,10), (15,18)]`

區間 `(1,3)` 和 `(2,6)` 重疊，因此合併成 `(1,6)`，其他區間保持不變。

---

### **解法思路**

這個問題的核心在於 **判斷區間是否重疊**，以及 **合併重疊區間**。以下是解法的詳細步驟：

#### **步驟 1：將區間按照 `start` 排序**

因為合併區間時，**我們希望按照起始時間的順序來處理**，這樣才能輕鬆找到可能的重疊區間。

舉例：

`輸入: [(1,3), (2,6), (8,10), (15,18)] 排序後: [(1,3), (2,6), (8,10), (15,18)]`

由於 `(1,3)` 先於 `(2,6)`，這樣我們只需要考慮當前區間與前一個合併區間的關係。

#### **步驟 2：遍歷排序後的區間並合併**

我們用一個 **結果陣列 `result`** 來存放合併後的區間，然後逐一遍歷 `intervals`，執行以下邏輯：

1. **如果 `result` 為空，或當前區間與 `result` 最後一個區間沒有重疊，則直接加入 `result`。**
2. **否則，更新 `result` 最後一個區間的 `end` 為兩者較大的 `end` 值，以合併這兩個區間。**

##### **詳細執行過程**

以 `(1,3), (2,6), (8,10), (15,18)` 為例：

|當前區間|`result` (已合併)|操作|
|---|---|---|
|`(1,3)`|`[(1,3)]`|加入 `result`|
|`(2,6)`|`[(1,6)]`|與 `(1,3)` 重疊，合併為 `(1,6)`|
|`(8,10)`|`[(1,6), (8,10)]`|沒有重疊，加入 `result`|
|`(15,18)`|`[(1,6), (8,10), (15,18)]`|沒有重疊，加入 `result`|

最終返回 `[(1,6), (8,10), (15,18)]`。

---

### **時間與空間複雜度分析**

1. **排序的時間複雜度**
    
    - `sorted(intervals, key=lambda x: x.start)` 採用 Timsort，時間複雜度為 **O(n log n)**。
2. **遍歷並合併的時間複雜度**
    
    - 只需要 **O(n)** 時間，因為每個區間都會被處理一次。
3. **總體時間複雜度**
    
    - **O(n log n)**（排序）+ **O(n)**（遍歷）= **O(n log n)**。
4. **空間複雜度**
    
    - 排序時的內部儲存佔用 **O(n)**，最壞情況 `result` 也需要 **O(n)**。
    - **總體空間複雜度：O(n)**。

---

### **其他解法**

1. **使用堆 (Min Heap)**
    
    - **思路**: 先用最小堆來儲存 `end` 時間，當前區間的 `start` 小於堆頂 `end` 時則合併，否則新增區間。
    - **時間複雜度**: **O(n log n)**（排序）+ **O(n log n)**（堆操作）。
2. **掃描線算法 (Sweep Line)**
    
    - **思路**: 將區間拆分成 `(start, +1)` 和 `(end, -1)` 事件，依序掃描計算區間的開啟與關閉狀態來合併。
    - **時間複雜度**: **O(n log n)**（排序）。
3. **分治法**
    
    - **思路**: 使用類似歸併排序的方法，先拆分區間，然後合併。
    - **時間複雜度**: **O(n log n)**。

---

### **總結**

1. **排序 + 遍歷合併** 是最直觀且高效的解法，時間複雜度 **O(n log n)**。
2. **使用最小堆** 可以提供另一種優雅的解法，雖然效率相近，但適合處理連續進入的區間流 (streaming intervals)。
3. **掃描線與分治法** 也能解，但對於這類問題，直覺解法已經足夠高效。

這樣的問題核心是透過排序建立區間的順序，然後利用條件判斷來合併區間。這種模式可以用在行程管理、時間表優化、內存管理等許多應用中。