Lintcode 1355
给定一个非负整数 *numRows，生成杨辉三角的前 _numRows_ 行。

**样例 1:**
```python
"""
输入: 5
输出:
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
```
**样例 2:**
```python
"""
输入: 3
输出:
[
     [1],
    [1,1],
   [1,2,1]
]
```


```python
"""
def generate(self, num_rows: int) -> List[List[int]]:
	ret = list()
	for i in range(num_rows):
		row = list()
		for j in range(0, i + 1):
			if j == 0 or j == i:
				row.append(1)
			else:
				row.append(ret[i - 1][j] + ret[i - 1][j - 1])
		ret.append(row)
	return ret
```
pass
解釋:
step1  



**思路及解法**

杨辉三角，是二项式系数在三角形中的一种几何排列。它是中国古代数学的杰出研究成果之一，它把二项式系数图形化，把组合数内在的一些代数性质直观地从图形中体现出来，是一种离散型的数与形的结合。

杨辉三角具有以下性质：

1. 每行数字左右对称，由 1 开始逐渐变大再变小，并最终回到 1。
    
2. 第 n行（从 0开始编号）的数字有 n+1项，前 n行共有 n(n+1)/2个数。
    
3. 第 nn 行的第 mm 个数（从 00 开始编号）可表示为可以被表示为组合数 C(n,m)C(n,m)，记作 CnmCnm​ 或 (nm)(mn​)，即为从 nn 个不同元素中取 mm 个元素的组合数。我们可以用公式来表示它：Cnm=n!m!×(n−m)!Cnm​=m!×(n−m)!n!​
    
4. 每个数字等于上一行的左右两个数字之和，可用此性质写出整个杨辉三角。即第 n行的第 i 个数等于第 n−1 行的第 i−1个数和第 i 个数之和。这也是组合数的性质之一，即 Cni=Cn−1i+Cn−1i−1Cni​=Cn−1i​+Cn−1i−1​。
    
5. (a+b)n(a+b)n 的展开式（二项式展开）中的各项系数依次对应杨辉三角的第 nn 行中的每一项。
    

依据性质 4，我们可以一行一行地计算杨辉三角。每当我们计算出第 ii 行的值，我们就可以在线性时间复杂度内计算出第 i+1i+1 行的值。


# **LintCode 1355 - Pascal’s Triangle（帕斯卡三角形）**

## **題目解析**

這道題要求 **生成帕斯卡三角形的前 `num_rows` 行**，其中：

- **第 `i` 行有 `i+1` 個數字**。
- **每行的開頭與結尾都是 `1`**。
- **其他數字為前一行的相鄰兩數之和**： $\text{row}[j] = \text{row}_{\text{above}}[j] + \text{row}_{\text{above}}[j-1]$

---

## **解法解析**

### **思路**

1. **使用二維陣列存儲結果**
    
    - 用 `ret` 儲存整個帕斯卡三角形，其中 `ret[i]` 代表第 `i` 行。
    - **每行的開頭與結尾都是 `1`**。
    - **內部元素** 透過 `ret[i-1][j] + ret[i-1][j-1]` 計算。
2. **遞推關係式**
    
    - **初始條件**：
        - `ret[0] = [1]`。
    - **遞推計算每行**：
        - `row[j] = ret[i-1][j] + ret[i-1][j-1]`（當 `1 ≤ j ≤ i-1`）。
    - **時間複雜度：O(n²)**（遍歷 `num_rows` 行，每行最多計算 `i` 次）。

---

## **具體舉例**

假設 `num_rows = 5`：

|`i` (行數)|`ret[i]`|
|---|---|
|0|`[1]`|
|1|`[1, 1]`|
|2|`[1, 2, 1]`|
|3|`[1, 3, 3, 1]`|
|4|`[1, 4, 6, 4, 1]`|

### **構建過程**

1. `row[0] = 1`
2. `row[1] = 1`
3. `row[2] = row[1] + row[0] = 2`
4. `row[3] = 1`
5. `row[4] = row[2] + row[1] = 3`
6. `row[5] = row[3] + row[2] = 3`
7. `row[6] = 1`

最終 `ret`：

```python
"""
[
 [1], 
 [1, 1], 
 [1, 2, 1], 
 [1, 3, 3, 1], 
 [1, 4, 6, 4, 1]
]

```
---

## **時間與空間複雜度分析**

- **時間複雜度：O(n²)**
    
    - **遍歷 `num_rows`**：O(n)。
    - **計算每行的數值**：O(i)，總和為 `O(1 + 2 + ... + n) = O(n²)`。
    - **最終時間複雜度為 O(n²)**。
- **空間複雜度：O(n²)**
    
    - **使用二維陣列 `ret` 存儲所有數據**，大小為 **`num_rows * num_rows`**，即 `O(n²)`。

---

## **其他解法**

### **1. 優化空間為 O(n)（滾動陣列法）**

- **思路**：
    - 只保留前一行的數據，**使用一個陣列 `row` 來計算當前行**。
    - **時間複雜度：O(n²)**。
    - **空間複雜度：O(n)**（不存儲整個三角形）。

### **2. 使用組合數公式直接計算**

- **組合數公式**： C(n,k)=n!k!(n−k)!C(n, k) = \frac{n!}{k!(n-k)!}C(n,k)=k!(n−k)!n!​
- **時間複雜度：O(n²)**（但可以用動態規劃計算 `C(n, k)` 降低成本）。
- **空間複雜度：O(n)**。

---

## **LintCode 內類似題目**

這類問題通常與 **動態規劃（DP）、數學組合數、遞推關係** 相關，以下是類似題目：

|**題號**|**題目名稱**|**難度**|**關鍵技術**|
|---|---|---|---|
|**LintCode 1355**|Pascal's Triangle|⭐⭐|**動態規劃、遞推計算**|
|**LintCode 778**|Generate Parentheses|⭐⭐⭐|**遞歸 + 動態規劃**|
|**LintCode 92**|Backpack|⭐⭐⭐|**0/1 背包 DP，與 Pascal’s Triangle 遞推關係類似**|
|**LintCode 793**|Intersection of Arrays|⭐⭐|**陣列處理，與 Pascal’s Triangle 遞推類似**|
|**LintCode 534**|House Robber II|⭐⭐⭐|**與 Pascal’s Triangle 的遞推關係類似**|
|**LintCode 91**|Minimum Adjustment Cost|⭐⭐⭐|**DP 優化問題**|
|**LintCode 656**|Multiply Strings|⭐⭐⭐|**數字處理，與 Pascal’s Triangle 結構類似**|

---

## **總結**

8. **最佳解法**：使用 **O(n²) 時間、O(n²) 空間的二維 DP 陣列**。
9. **空間優化**：使用 **滾動數組 O(n) 空間** 來計算當前行的數據。
10. **進一步優化**：使用 **組合數公式 O(n²) 時間計算 Pascal’s Triangle**。
11. **這類問題通常涉及**：
    - **遞推公式**
    - **動態規劃**
    - **數學組合數計算**
    - **記憶化搜索**