Lintcode 111
假设你正在爬楼梯，需要`n`步你才能到达顶部。但每次你只能爬一步或者两步，爬到顶部的方法有多少种？

**样例 1：**
输入：
```python
n = 3
```
输出：
```python
3
```
解释：
1. 1, 1, 1
2. 1, 2
3. 2, 1
共3种

**样例 2：**
输入：
```python
n = 1
```
输出：
```python
1
```
解释：
只有一种方案


```python
def climb_stairs(self, n: int) -> int:
	if n == 0:
		return 0
	if n <= 2:
		return n
	result=[1,2]
	for i in range(n-2):
		result.append(result[-2]+result[-1])
	return result[-1]
```
pass

n=3 -> result=3
1. 1, 1, 1
2. 1, 2
3. 2, 1 共3种

解釋:
考虑最后一步走1阶还是走2阶。  
方案数Dp[n] = 最后一步走1阶的方案数 + 最后一步走2阶的方案数。  
Dp[n] = Dp[n-1] + Dp[n-2].


### **LintCode 111 - Climbing Stairs（爬樓梯）**

這道題目是典型的 **動態規劃（Dynamic Programming, DP）** 問題，與斐波那契數列非常類似。問題要求計算到達第 `n` 階的方法總數，每次可以選擇爬 **1 步或 2 步**。

---

## **解法解析**

這道題可以轉化為 **遞推關係式** 來求解。

### **思路**

1. **觀察規律**
    
    - 若 `n = 1`，只有 1 種方式：`(1)`
    - 若 `n = 2`，有 2 種方式：`(1+1), (2)`
    - 若 `n = 3`，可以從 `n=1` 爬 2 步，或從 `n=2` 爬 1 步：
        - `(1+1+1), (1+2), (2+1)` → 共 **3 種方法**
    - 若 `n = 4`，可以從 `n=2` 爬 2 步，或從 `n=3` 爬 1 步：
        - `(1+1+1+1), (1+1+2), (1+2+1), (2+1+1), (2+2)` → 共 **5 種方法**
2. **發現遞推公式**
    
    - `f(n) = f(n-1) + f(n-2)`
    - 這個公式與 **斐波那契數列（Fibonacci Sequence）** 相同，但初始條件不同：
        - `f(1) = 1`
        - `f(2) = 2`
        - `f(n) = f(n-1) + f(n-2)`
3. **代碼執行流程**
    
    - 若 `n = 1` 或 `n = 2`，直接回傳 `n`。
    - 初始化 `result = [1, 2]`，儲存 `f(1)` 和 `f(2)`。
    - **迴圈計算 `f(3) ~ f(n)`**，透過 `result[-1] + result[-2]` 更新新的 `f(n)`。
    - 最後返回 `result[-1]`。

---

## **具體舉例**

假設 `n = 5`，我們的變數變化如下：

|`i`|`result`|
|---|---|
|初始化|`[1, 2]`|
|`i = 3`|`[1, 2, 3]`（`1+2=3`）|
|`i = 4`|`[1, 2, 3, 5]`（`2+3=5`）|
|`i = 5`|`[1, 2, 3, 5, 8]`（`3+5=8`）|

最後返回 `8`，表示 `n = 5` 時，有 **8 種方法** 爬上樓梯。

---

## **時間與空間複雜度分析**

- **時間複雜度：O(n)**
    - 需要迭代 `n-2` 次，每次 `O(1)` 計算，因此時間複雜度為 **O(n)**。
- **空間複雜度：O(n)**
    - 需要一個長度 `n` 的陣列 `result` 來存儲中間結果，因此空間複雜度為 **O(n)**。

---

## **其他解法**

### **1. 動態規劃 - O(1) 空間優化**

- **思路**：
    - 只儲存 `f(n-1)` 和 `f(n-2)`，不使用 `O(n)` 陣列，而是使用兩個變數滾動更新。
- **時間複雜度**：O(n)
- **空間複雜度**：O(1)

### **2. 矩陣快速幂（O(log n) 解法）**

- **思路**：
    - 利用 **斐波那契數列的矩陣表示**，透過矩陣快速幂 `O(log n)` 時間計算 `f(n)`。
- **時間複雜度**：O(log n)
- **空間複雜度**：O(1)

### **3. 直接使用斐波那契公式（O(1) 時間）**

- **思路**：
    - 使用 **Binet's Formula**，直接計算斐波那契數列的近似值。
    - `Fn = (ϕⁿ - (1-ϕ)ⁿ) / √5`，其中 `ϕ = (1 + √5) / 2`。
- **時間複雜度**：O(1)
- **空間複雜度**：O(1)

---

## **總結**

- **最直觀的解法**：使用 `O(n)` 陣列來記錄 `f(n)`，時間 `O(n)`，空間 `O(n)`。
- **最佳解法（一般用法）**：**O(1) 空間的 DP 滾動變數解法**，時間 `O(n)`，空間 `O(1)`。
- **最佳解法（數學解法）**：**矩陣快速幂 `O(log n)`，或直接計算斐波那契公式 `O(1)`**。

如果 `n` 很大，例如 `n > 10^6`，建議使用 **O(log n) 的矩陣快速幂** 來求解，而不是 `O(n)` 的動態規劃方法。


## **LintCode 上類似的動態規劃題目（符合 DP[n] = DP[n-1] + DP[n-2] 類型）**

這類題目通常是 **狀態轉移依賴前兩步的動態規劃問題**，例如樓梯問題、解碼問題、數獨等。

|**題號**|**題目名稱**|**難度**|**說明**|
|---|---|---|---|
|**LintCode 111**|Climbing Stairs（爬樓梯）|⭐⭐|**經典 DP 問題，斐波那契數列解法**|
|**LintCode 512**|Decode Ways（解碼方式）|⭐⭐⭐|**`DP[i] = DP[i-1] + DP[i-2]`，每個數字可以獨立解碼或與前一個數組合**|
|**LintCode 513**|Perfect Squares（完全平方數）|⭐⭐⭐|**計算最少數量的平方數和，可轉換為 DP[i] = min(DP[i - j*j] + 1)**|
|**LintCode 514**|House Robber（搶劫問題）|⭐⭐⭐|**類似爬樓梯，但 `DP[i] = max(DP[i-1], DP[i-2] + nums[i])`**|
|**LintCode 515**|Paint House（油漆房子）|⭐⭐⭐|**塗房子的最小成本，需要考慮前 `i-1` 步的最小選擇**|
|**LintCode 556**|Coin Change（換硬幣）|⭐⭐⭐|**計算兌換硬幣所需的最少數量，可轉化為 `DP[i] = min(DP[i - coin] + 1)`**|
|**LintCode 563**|Backpack V（背包問題 V）|⭐⭐⭐|**類似爬樓梯，每次可以選擇不同大小的物品放入背包**|
|**LintCode 798**|Unique Paths（不同的路徑）|⭐⭐⭐|**計算從左上角走到右下角的方法數，類似爬樓梯的 DP**|
|**LintCode 629**|Minimum Path Sum（最小路徑和）|⭐⭐⭐|**類似爬樓梯，`DP[i][j]` 依賴 `DP[i-1][j]` 和 `DP[i][j-1]`**|
|**LintCode 92**|Backpack（背包問題 I）|⭐⭐⭐|**經典 0/1 背包問題，DP[i] 依賴於 DP[i-1] 和 DP[i-2]**|