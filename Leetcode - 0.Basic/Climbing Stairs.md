Lintcode 111
假设你正在爬楼梯，需要`n`步你才能到达顶部。但每次你只能爬一步或者两步，爬到顶部的方法有多少种？

**样例 1：**
输入：
```python
"""
n = 3
```
输出：
```python
3
```
解释：
	1, 1, 1
	1, 2
	2, 1
	共3种

**样例 2：**
输入：
```python
"""
n = 1
```
输出：
```python
1
```
解释：
只有一种方案


```python
def climb_stairs(self, n: int) -> int:
	if n == 0:
		return 0
	if n <= 2:
		return n
	result=[1,2]
	for i in range(n-2):
		result.append(result[-2]+result[-1])
	return result[-1]
```
pass



```python
def climb_stairs(self, n: int) -> int:
	if n == 0:
		return 0
	if n <= 2:
		return n
	result=[1,2]
	for i in range(n-2):
		result[i%2] = result[0] + result[1]
	return result[i%2]
```


n=3 -> result=3
1. 1, 1, 1
2. 1, 2
3. 2, 1 共3种

解釋:
考虑最后一步走1阶还是走2阶。  
方案数Dp[n] = 最后一步走1阶的方案数 + 最后一步走2阶的方案数。  
Dp[n] = Dp[n-1] + Dp[n-2].


### **LintCode 111 - Climbing Stairs（爬樓梯）**

這道題目是典型的 **動態規劃（Dynamic Programming, DP）** 問題，與斐波那契數列非常類似。問題要求計算到達第 `n` 階的方法總數，每次可以選擇爬 **1 步或 2 步**。

---

## **解法解析**

這道題可以轉化為 **遞推關係式** 來求解。

### **思路**

1. **觀察規律**
    
    - 若 `n = 1`，只有 1 種方式：`(1)`
    - 若 `n = 2`，有 2 種方式：`(1+1), (2)`
    - 若 `n = 3`，可以從 `n=1` 爬 2 步，或從 `n=2` 爬 1 步：
        - `(1+1+1), (1+2), (2+1)` → 共 **3 種方法**
    - 若 `n = 4`，可以從 `n=2` 爬 2 步，或從 `n=3` 爬 1 步：
        - `(1+1+1+1), (1+1+2), (1+2+1), (2+1+1), (2+2)` → 共 **5 種方法**
2. **發現遞推公式**
    
    - `f(n) = f(n-1) + f(n-2)`
    - 這個公式與 **斐波那契數列（Fibonacci Sequence）** 相同，但初始條件不同：
        - `f(1) = 1`
        - `f(2) = 2`
        - `f(n) = f(n-1) + f(n-2)`
3. **代碼執行流程**
    
    - 若 `n = 1` 或 `n = 2`，直接回傳 `n`。
    - 初始化 `result = [1, 2]`，儲存 `f(1)` 和 `f(2)`。
    - **迴圈計算 `f(3) ~ f(n)`**，透過 `result[-1] + result[-2]` 更新新的 `f(n)`。
    - 最後返回 `result[-1]`。

---

## **具體舉例**

假設 `n = 5`，我們的變數變化如下：

|`i`|`result`|
|---|---|
|初始化|`[1, 2]`|
|`i = 3`|`[1, 2, 3]`（`1+2=3`）|
|`i = 4`|`[1, 2, 3, 5]`（`2+3=5`）|
|`i = 5`|`[1, 2, 3, 5, 8]`（`3+5=8`）|

最後返回 `8`，表示 `n = 5` 時，有 **8 種方法** 爬上樓梯。

---

## **時間與空間複雜度分析**

- **時間複雜度：O(n)**
    - 需要迭代 `n-2` 次，每次 `O(1)` 計算，因此時間複雜度為 **O(n)**。
- **空間複雜度：O(n)**
    - 需要一個長度 `n` 的陣列 `result` 來存儲中間結果，因此空間複雜度為 **O(n)**。

---

## **其他解法**

### **1. 動態規劃 - O(1) 空間優化**

- **思路**：
    - 只儲存 `f(n-1)` 和 `f(n-2)`，不使用 `O(n)` 陣列，而是使用兩個變數滾動更新。
- **時間複雜度**：O(n)
- **空間複雜度**：O(1)

### **2. 矩陣快速幂（O(log n) 解法）**

- **思路**：
    - 利用 **斐波那契數列的矩陣表示**，透過矩陣快速幂 `O(log n)` 時間計算 `f(n)`。
- **時間複雜度**：O(log n)
- **空間複雜度**：O(1)

### **3. 直接使用斐波那契公式（O(1) 時間）**

- **思路**：
    - 使用 **Binet's Formula**，直接計算斐波那契數列的近似值。
    - `Fn = (ϕⁿ - (1-ϕ)ⁿ) / √5`，其中 `ϕ = (1 + √5) / 2`。
- **時間複雜度**：O(1)
- **空間複雜度**：O(1)

---

## **總結**

- **最直觀的解法**：使用 `O(n)` 陣列來記錄 `f(n)`，時間 `O(n)`，空間 `O(n)`。
- **最佳解法（一般用法）**：**O(1) 空間的 DP 滾動變數解法**，時間 `O(n)`，空間 `O(1)`。
- **最佳解法（數學解法）**：**矩陣快速幂 `O(log n)`，或直接計算斐波那契公式 `O(1)`**。

如果 `n` 很大，例如 `n > 10^6`，建議使用 **O(log n) 的矩陣快速幂** 來求解，而不是 `O(n)` 的動態規劃方法。


## **LintCode 爬楼梯类问题整理**

|**题号**|**题目名称**|**问题类型**|**解法**|
|---|---|---|---|
|**LintCode 111**|Climbing Stairs（爬楼梯）|**1D 走楼梯，每次走 1 或 2 步，求方案数**|**动态规划 DP[n] = DP[n-1] + DP[n-2]**，类似 Fibonacci 数列|
|**LintCode 512**|Decode Ways（解码方法）|**1D 字符串解码，每次解 1 或 2 个字符，求方案数**|**动态规划 DP[i] = DP[i-1] + DP[i-2]（需符合解码条件）**|
|**LintCode 514**|House Robber（抢劫房屋）|**1D 线性路径，每次跳 1 或 2 个房子，求最大收益**|**动态规划 DP[i] = max(DP[i-1], DP[i-2] + nums[i])**|
|**LintCode 602**|Russian Doll Envelopes（俄罗斯套娃信封）|**1D 排序 + LIS（最长递增子序列）**|**动态规划 + 二分查找 O(n log n)**|
|**LintCode 798**|Unique Paths（不同的路径）|**2D 网格，每次向右或向下移动，求路径数**|**动态规划 DP[i][j] = DP[i-1][j] + DP[i][j-1]**|
|**LintCode 114**|Unique Paths II（不同的路径 II）|**2D 网格，带障碍物，每次向右或向下移动，求路径数**|**动态规划 DP[i][j] = DP[i-1][j] + DP[i][j-1]，障碍物设为 0**|
|**LintCode 116**|Jump Game（跳跃游戏）|**1D 数组，每个位置 `nums[i]` 表示最多能跳的步数，判断是否能到终点**|**贪心（Greedy）+ 动态规划**|
|**LintCode 117**|Jump Game II（跳跃游戏 II）|**1D 数组，每个位置 `nums[i]` 表示最多能跳的步数，求最少跳跃次数**|**贪心（BFS 最短路径）**|
|**LintCode 630**|Knight Shortest Path（骑士最短路径）|**2D 棋盘，马走日字，求最短步数**|**BFS（广度优先搜索）**|
|**LintCode 1293**|Shortest Path in Grid with Obstacles Elimination|**2D 网格，每次向右或向下，最多能消除 k 个障碍物，求最短路径**|**BFS + 状态存储 (`(i, j, k)`)**|
|**LintCode 200**|Longest Increasing Path in a Matrix（矩阵最长递增路径）|**2D 矩阵，每次移动到递增的相邻单元格，求最长路径**|**记忆化搜索 + DFS**|
|**LintCode 152**|Best Time to Buy and Sell Stock II|**1D 数组，每天买卖股票（可以多次交易），求最大收益**|**贪心（局部最优）、动态规划**|
|**LintCode 515**|Paint House（涂房子）|**2D 动态规划，选择不同颜色最小化成本**|**动态规划 DP[i][c] = min(DP[i-1][其他颜色]) + cost[i][c]**|
|**LintCode 514**|Paint House II（涂房子 II）|**2D 动态规划，多个颜色最小化成本**|**动态规划 + 滚动数组优化**|

假设你正在爬楼梯，需要`n`步你才能到达顶部。但每次你只能爬一步,兩步或者三步，爬到顶部的方法有多少种？
```python
class Solution:
    def climb_stairs(self, n: int) -> int:
        if n == 0:
            return 1 # 基本情况：0级台阶，1种方式（不爬）
        if n == 1:
            return 1 # 基本情况：1级台阶，1种方式（走1步）
        if n == 2:
            return 2 # 基本情况：2级台阶，2种方式（1+1, 2）

        # 初始化三个变量，分别代表 dp[i-3], dp[i-2], dp[i-1]
        # 对于 i=3，我们需要 dp[0], dp[1], dp[2]
        prev_three = 1 # 对应 dp[0] 的值
        prev_two = 1   # 对应 dp[1] 的值
        prev_one = 2   # 对应 dp[2] 的值

        # 从 dp[3] 开始计算，一直到 dp[n]
        for i in range(3, n + 1):
            current_ways = prev_one + prev_two + prev_three # 计算当前 dp[i] 的值
            
            # “移位”变量，为下一次迭代做准备
            prev_three = prev_two    # 原来的 dp[i-2] 变成新的 dp[i-3]
            prev_two = prev_one      # 原来的 dp[i-1] 变成新的 dp[i-2]
            prev_one = current_ways  # 当前计算出的 dp[i] 变成新的 dp[i-1]
            
        return prev_one # 循环结束后，prev_one 就存储了 dp[n] 的值
```