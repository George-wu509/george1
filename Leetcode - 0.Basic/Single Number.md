Lintcode 82
给出 `2 * n + 1`个数字，除其中一个数字之外其他每个数字均出现两次，找到这个数字。

**样例 1：**
输入：
```python
"""
A = [1,1,2,2,3,4,4]
```
输出：
```python
"""
3
```
解释：
仅3出现一次  

**样例 2：**
输入：
```python
"""
A = [0,0,1]
```
输出：
```python
"""
1
```
解释：
仅1出现一次


```python
    def single_number(self, a):
        ans = 0;
        for x in a:
            ans = ans ^ x
        return ans
```
pass

- 异或位运算

Note:  
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?  
异或运算具有很好的性质，相同数字异或运算后为0，并且具有交换律和结合律，故将所有数字异或运算后即可得到只出现一次的数字。

# **LintCode 82 - Single Number（找出唯一數字）**

## **題目解析**

給定一個非空的數組 `A`，其中 **除了某個數字只出現一次以外，其他數字都出現兩次**，找出這個唯一的數字。

### **關鍵點**

1. **其他數字都出現兩次** → **位元運算 XOR（^）的特性適用**
2. **唯一數字只出現一次** → **可以透過 XOR 來消除重複數字**

---

## **解法解析**

### **思路**

這題的最佳解法是 **XOR（異或）運算**：

- **XOR 運算性質**：
    1. **`x ^ x = 0`**（任何數與自身 XOR 結果為 `0`）
    2. **`x ^ 0 = x`**（任何數與 `0` XOR 結果不變）
    3. **`x ^ y ^ x = y`**（順序無關，只要相同的數字 XOR 會消除）

因此，對陣列所有數字執行 XOR 運算：

- **相同的數字會互相消除（變成 `0`）**
- **剩下唯一出現一次的數字**

### **解法步驟**

1. 初始化 `ans = 0`
2. 遍歷 `A`，執行 `ans ^= x`
3. 遍歷結束後，`ans` 即為 **唯一出現一次的數字**

---

## **具體舉例**

假設 `A = [2, 3, 2, 4, 3]`，執行 XOR 運算過程如下：

|`x`|`ans ^= x` 運算|`ans` 結果|
|---|---|---|
|2|`0 ^ 2`|`2`|
|3|`2 ^ 3`|`1`|
|2|`1 ^ 2`|`3`|
|4|`3 ^ 4`|`7`|
|3|`7 ^ 3`|`4`|

最後 `ans = 4`，即為唯一的數字。

---

## **時間與空間複雜度分析**

- **時間複雜度：O(n)**
    - 只需遍歷 `A` 一次，**O(n)**。
- **空間複雜度：O(1)**
    - 只使用了 `ans` 變數，**O(1)**。

---

## **其他解法**

### **1. 使用 HashSet（雜湊集合）**

- **思路**：
    - 遍歷 `A`，用 `set()` 記錄數字的出現次數。
    - **若數字已存在，則移除；若數字不存在，則加入**。
    - 最後 `set()` 內剩下的就是唯一數字。
- **時間複雜度：O(n)**，**空間複雜度：O(n)**。

### **2. 使用排序**

- **思路**：
    - 先對 `A` 排序，然後遍歷 `A[i]`，若 `A[i] ≠ A[i+1]`，則 `A[i]` 是單一數字。
- **時間複雜度：O(n log n)**（排序），**空間複雜度：O(1)**（若使用 in-place 排序）。

### **3. 使用 Counter 計數**

- **思路**：
    - 用 `collections.Counter` 計算每個數的出現次數，然後找出 `count == 1` 的數字。
- **時間複雜度：O(n)**，**空間複雜度：O(n)**。

---

## **LintCode 內類似題目**

這類問題通常與 **位運算 XOR、雜湊表、排序、數組操作** 相關：

|**題號**|**題目名稱**|**難度**|**關鍵技術**|
|---|---|---|---|
|**LintCode 82**|Single Number|⭐⭐|**XOR（最佳解）**|
|**LintCode 84**|Single Number III|⭐⭐⭐|**變種 XOR（找出兩個不同的數）**|
|**LintCode 83**|Single Number II|⭐⭐⭐|**變種 XOR（找出出現 3 次的數字）**|
|**LintCode 142**|O(1) Check Power of 2|⭐⭐|**位運算 & 數字判斷**|
|**LintCode 136**|Swap Bits|⭐⭐|**位運算技巧**|
|**LintCode 845**|Greatest Common Divisor|⭐⭐|**數學計算**|
|**LeetCode 136**|Single Number|⭐⭐|**相同問題**|
|**LeetCode 137**|Single Number II|⭐⭐⭐|**變種 XOR 解法**|
|**LeetCode 260**|Single Number III|⭐⭐⭐|**XOR 分組異或**|

---

## **總結**

4. **最佳解法**：
    
    - **使用 XOR（異或）**，時間 `O(n)`，空間 `O(1)`。
    - 適合所有數字都重複兩次，**只有一個數字出現一次** 的情境。
5. **其他解法**：
    
    - **使用 `set()` 記錄數字**，但空間 `O(n)`。
    - **排序後遍歷**，時間 `O(n log n)`。
    - **使用 `Counter()` 計數**，時間 `O(n)`，空間 `O(n)`。
6. **這類題目常見於**：
    
    - **找出唯一數字（異或運算）**
    - **找出只出現 `k` 次的數**
    - **數組中的位元運算應用**
    - **數學計算（位操作 & 進制）**

🚀 XOR 解法是最優解，適用於「數組中 **只有一個數字出現一次，其他都出現兩次**」的問題！