


| **题目编号**                   | **题目名称 (英文/中文)**                                        | **题目简述 (中文)**                                                | **样例**                                                                                                                                      | **解法**                                                                                                                                                          |
| -------------------------- | ------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 433<br>**<br>(e)           | 岛屿的个数 [[Number of Islands]]                             | 给定一个二维网格，计算其中岛屿的数量。                                          | 输入：<br>[<br>  [1,1,0,0,0],<br>  [0,1,0,0,1],<br>  [0,0,0,1,1],<br>  [0,0,0,0,0],<br>  [0,0,0,0,1]<br>]<br><br>输出：<br>3                      | 使用 BFS 遍历每个岛屿，将相邻陆地标记为已访问。                                                                                                                                      |
| 15<br>**<br>(m)<br><br>PR  | 全排列 <br>[[Permutations]]                                | 给定一个没有重复数字的数组，返回所有可能的排列。                                     | 输入：<br>[1,2,3]<br><br>输出：[<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1] ]                             | 使用 DFS 和回溯生成所有排列组合。                                                                                                                                             |
| 457<br><br>(e)             | [[Classical Binary Search]]<br>经典二分查找问题                 | 在排序数组中找target，返回该数出现的任意位置，如果不存在，返回 -1。                       | 输入: <br>nums = <br>[1,2,2,3,4,4]<br>target=2<br><br>输出: <br>1 or 2                                                                          | Array從頭尾開始用雙指針start, end取中位數mid比較target.然後取左半邊array或右半邊array繼續逼近, 最後start, end應該落在target區間的左右                                                                   |
| 56<br>**<br>(e)            | [[Two Sum]]<br>两数之和                                     | 在数组中找到两个数，使得它们的和等于目标值，返回它们的下标。                               | 输入: <br>[2, 7, 11, 15]<br>target = 9 <br><br>输出: [0, 1]<br><br>O(nlogn),O(n)                                                                | 先排序然後用雙指針從左右往中間, 和target比較決定往右往左                                                                                                                                |
| 156<br>**<br>(e)           | [[Merge Intervals]]<br>合并区间                             | 给定一组区间，合并所有重叠的区间。                                            | 输入: <br>[(1,3),(2,6),<br>(8,10),(15,18)]<br> <br>输出: [(1,6),<br>(8,10),(15,18)]                                                             | 按区间起点排序，遍历并合并重叠区间。                                                                                                                                              |
| 13<br>*<br>(e)             | [[Implement strStr]]字符串查找                               | 实现 `strStr()` 函数，返回子字符串在母字符串中首次出现的索引，若不存在则返回 -1。             | 输入: <br>source = "abcdabcdefg", <br>target = "bcd" <br><br>输出: 1<br><br>暴力匹配（Brute Force）<br>O(m*n),O(1)                                    | 使用双指针從0,0出發遍历源字符串，检查目标字符串是否匹配                                                                                                                                   |
| **138**<br>*<br>(e)        | [[Subarray Sum]]<br>子数组之和为零                             | 给定一个整数数组，找到和为零的子数组，返回第一个出现的子数组的起始和结束下标。                      | 输入: <br>[-3, 1, 2, -3, 4] <br><br>输出: <br>[0, 2]<br><br>(和為0 [-3, 1, 2])<br>O(n)                                                            | 使用前缀和数组，记录每个前缀和第一次出现的位置，若再次出现相同的前缀和，则表示子数组和为零。                                                                                                                  |
| 35<br>*<br>(e)             | [[Reverse Linked List]]翻转链表                             | 反转一个链表。                                                      | 输入: <br>1->2->3->null <br><br>输出: <br>3->2->1->null                                                                                         | 使用迭代或递归方法反转链表。迭代方法中，遍历链表，将当前节点的 next 指向前一个节点。递归方法中，递归反转子链表，然后调整指针。                                                                                              |
| 494<br>*<br>(e)            | [[Implement Stack using Queues]]双队列实现栈                  | 使用队列实现栈，支持 `push(x)`、`pop()`、`top()` 和 `empty()` 操作。         | 输入：<br>push(1)<br>pop()<br>push(2)<br>isEmpty() // return false<br>top() // return 2<br>pop()<br>isEmpty() // return true                   | 使用两个队列实现栈功能：一个队列用于存储元素，另一个队列用于辅助反转元素顺序。每次插入元素时，将新元素添加到辅助队列，然后将主队列的所有元素依次移动到辅助队列，交换主辅队列。                                                                         |
| 1206<br><br>(e)            | [[Next Greater Element I]]<br>下一个更大元素 I                 | 给定两个数组 `nums1` 和 `nums2`，找出 `nums1` 中每个元素在 `nums2` 中的下一个更大元素 | 输入:  <br>nums1 = [4,1,2]<br>nums2 = [1,3,4,2]<br><br>输出: [-1,3,-1]                                                                          | 使用 单调递减栈 来找到 nums2 中每个元素的下一个更大值, 使用 哈希表记录每个元素的下一个更大值，方便在nums1中查找                                                                                                |
| 3542<br><br>(e)            | 非负前缀和 [[Non-Negative Prefix Sum]]                       | 给定一个环形整数数组 nums，其长度为 n. 计算该环形数组的前缀和，有多少个下标可以使得该前缀和的所有元素均为非负数 | 输入:  <br>nums = <br>[-3,5,1,2]<br><br>输出: 2                                                                                                 | 将nums复制一份并接在给定的nums之后做前缀和处理                                                                                                                                     |
| 124<br>*<br>(m)            | [[Longest Consecutive Sequence]]最长连续序列                  | 给定一个未排序的整数数组，找出最长连续序列的长度。                                    | 输入:  <br>nums = <br>[100,4,200,1,3,2]  <br><br>输出:  <br>4 (1,2,3,4)                                                                         | 使用哈希表记录数组中的数字，动态扩展连续序列的长度。                                                                                                                                      |
| 67<br>*<br>(e)             | [[Binary Tree Inorder Traversal]]- 二叉树的中序遍历             | 返回二叉树的中序遍历结果。                                                | 输入:  <br>root = <br>[1,null,2,3]  <br><br>输出:  <br>[1,3,2]                                                                                  | 使用递归或栈完成中序遍历操作。                                                                                                                                                 |
|                            |                                                         |                                                              |                                                                                                                                             |                                                                                                                                                                 |
| 2                          |                                                         |                                                              |                                                                                                                                             |                                                                                                                                                                 |
|                            |                                                         |                                                              |                                                                                                                                             |                                                                                                                                                                 |
| 8<br>*<br>(e)              | [[Rotate String]]旋转字符数组                                 | 给定一个字符串和一个偏移量，根据偏移量旋转字符串。                                    | 输入: <br>"abcdefg"<br>offset = 3 <br><br>输出: <br>"efgabcd"<br><br>O(n),O(n)                                                                  | 将字符串分为两部分，分别反转，然后再整体反转。                                                                                                                                         |
| 647<br>*<br>(m)            | [[Find All Anagrams in a String]]子串字谜                   | 在字符串中找到目标字符串所有变位词的起始索引                                       | 输入:  <br>s = "cbaebabacd"  <br>p = "abc" <br> <br>输出:  [0,6] <br><br>("cba","bac")                                                          | 使用滑动窗口和哈希表记录字符频率。                                                                                                                                               |
| 1844<br>*<br>(m)           | [[Subarray Sum Equals to K II]] 子数组和为K的最短子数组            | 给定一个整数数组和一个整数k，你需要找到和为k的最短非空子数组，并返回它的长度。                     | 输入:  <br>nums = [1, 1, 1, 2], k = 3  <br>输出: 2  <br><br>(**和為0找最短**[1,2])<br>O(n),O(n)                                                      | 使用前缀和与哈希表记录出现的和，通过快速查找加速匹配和为K的子数组数量。(用Two pointers?)                                                                                                            |
| 460<br>*<br>(m)            | [[Find K Closest Elements]]<br>在排序数组中找最接近的K个数           | 在升序排列A中找与target最接近的k个整数                                      | 输入: <br>A = [1, 2, 3]<br>target = 2<br>k = 3<br><br>输出: <br>[2, 1, 3]                                                                       | 先利用Binary Search找到最接近target的數, 然後用雙指針向左向右尋找最接近target直到找到k個                                                                                                      |
| 58<br>**<br>(m)            | 四数之和  [[4Sum]]                                          | 给一个包含n个数的整数数组S，在S中找到所有使得和为给定整数target四元组(a, b, c, d)          | 输入:  <br>numbers = [2,7,11,15], <br>target=3<br><br>输出: []<br><br>O(n^3),O(1)                                                               | 固定两个点，然后用双指针的做法，扫描一下后续数组，记录答案即可。                                                                                                                                |
| 112<br><br>(e)<br>         | [[Remove Duplicates from Sorted List]]删除排序链表中的重复元素      | 删除排序链表中的重复元素，使每个元素只出现一次。                                     | 输入: <br>1->1->2-><br>3->3->null <br><br>输出: <br>1->2->3->null                                                                               | 遍历链表，删除重复的节点。                                                                                                                                                   |
| 40<br><br>(m)              | [[Implement Queue by Two Stacks]]用栈实现队列                 | 使用两个栈实现队列，支持 `push(element)`、`pop()` 和 `top()` 操作。           | 队列操作 = <br>    push(1)<br>    pop()    <br>    push(2)<br>    push(3)<br>    top()    <br>    pop()                                         | 使用两个栈实现队列功能：一个栈用于入队操作，另一个栈用于出队操作。当出队栈为空时，将入队栈的所有元素依次弹出并压入出队栈，然后从出队栈弹出元素以实现队列的先进先出特性。                                                                            |
| 362<br>**<br>(h)           | [[Sliding Window Maximum]]滑动窗口的最大值                      | 给定一个整数数组和滑动窗口大小，找出每个窗口中的最大值。                                 | 输入: <br>nums = <br>[1,3,-1,-3,<br>5,3,6,7]<br><br>k = 3 <br>输出: <br>[3,3,5,5,6,7]                                                           | 使用双端队列（deque）维护当前窗口的最大值索引。遍历数组时，移除队列中不在当前窗口范围内的元素，并移除队列中小于当前元素的所有元素，然后将当前元素索引添加到队列。当前元素索引大于等于窗口大小时，队首即为当前窗口最大值。                                                 |
| 611<br>**<br>(m)<br><br>PR | 骑士的最短路线 [[Knight Shortest Path]]                        | 在棋盘上从起点移动到终点，返回骑士所需的最小步数。                                    | 输入:<br>[ [0,0,0],<br> [0,0,0],<br> [0,0,0] ]<br>source = [2, 0] <br>destination <br>= [2, 2] <br><br>输出: 2                                  | 使用 BFS 搜索骑士的合法移动路径，记录访问状态以避免重复。                                                                                                                                 |
| 17<br>**<br>(m)<br><br>PR  | 子集 <br>[[Subsets]]                                      | 给定一个没有重复元素的数组，返回所有可能的子集。                                     | 輸入<br>[1,2,3]<br><br>輸出<br>[ [], [1], [1, 2],<br> [1, 2, 3], [1, 3], <br>[2], [2, 3], [3] ]                                                 | 使用 DFS 生成所有可能的组合，逐步扩展路径。                                                                                                                                        |
| 363<br>**<br>(m)           | [[Trapping Rain Water]]接雨水                              | 计算柱状图中能够存储的雨水总量。                                             | 输入:  <br>height = <br>[0,1,0,2,1,0,<br>1,3,2,1,2,1]  <br><br>输出:  <br>6                                                                     | 使用双指针和单调栈记录左右最大高度，计算每个位置的雨水。                                                                                                                                    |
| 128<br>**<br>(m)           | 哈希函数 [[Hash Function]]                                  | 设计一个简单的哈希函数，将字符串映射到指定大小的哈希表。                                 | 输入:  <br>key = "hello" <br>HASH_SIZE = 10 <br> <br>输出: 2                                                                                    | 使用字符串的ASCII值结合哈希表大小进行取模运算。                                                                                                                                      |
| 70<br>*<br>(m)<br>         | [[Binary Tree Level Order Traversal II]]二叉树的层次遍历 II     | 返回二叉树的层次遍历结果（从底层到顶层）。                                        | 输入:  <br>root = <br>[3,9,20,null,<br>null,15,7]  <br><br>输出:  <br>[ [15,7],<br>[9,20],[3] ]                                                 | 使用队列按层遍历节点，结果反转。                                                                                                                                                |
| 597<br>**<br>(e)           | 具有最大平均数的子树 [[Subtree with Maximum Average]]             | 找出二叉树中具有最大平均数的子树。                                            | 输入:  <br>root = <br>[1,-5,11,1,2,4,-2]  <br><br>输出: [11,4,-2]                                                                               | 使用递归后序遍历计算子树的节点和和节点数，动态更新最大平均值。                                                                                                                                 |
| 93<br>*<br>(e)             | 平衡二叉树 [[Balanced Binary Tree]]                          | 判断一棵二叉树是否为平衡二叉树（每个节点的左右子树高度差不超过 1）。                          | 输入:  <br>root = <br>[3,9,20,null,null,15,7]  <br><br>输出: true                                                                               | 使用递归计算每个节点的高度，检查左右子树的高度差，若所有节点满足条件则为平衡二叉树。                                                                                                                      |
|                            |                                                         |                                                              |                                                                                                                                             |                                                                                                                                                                 |
| 3                          |                                                         |                                                              |                                                                                                                                             |                                                                                                                                                                 |
| 111<br>*<br>(e)            | [[Climbing Stairs]]爬楼梯                                  | 一次可以爬 1 步或 2 步，求爬到第 n阶台阶的总方法数。                               | 输入: <br>n = 3 <br><br>输出: 3<br><br>O(n)                                                                                                     | 使用动态规划或斐波那契数列公式递推计算方法数。                                                                                                                                         |
| 171<br>**<br>(m)           | 乱序字符串 [[Anagrams]]                                      | 给定一个字符串列表，找出其中所有乱序的字符串组。                                     | 输入:  <br>strs = <br>["eat", "tea", "tan", <br>"ate", "nat", "bat"]  <br><br>输出: <br>[ ["eat","tea","ate"],<br>["tan","nat"],["bat"] ]       | 将字符串排序后作为key存入字典，按key分组。                                                                                                                                        |
| 406<br>*<br>(m)            | [[Minimum Size Subarray Sum]] 子数组和大於K的最短子数组             | 找出数组中和大于或等于 S 的最小连续子数组长度。                                    | 输入:  <br>nums = <br>[2,3,1,2,4,3]<br>s = 7  <br><br>输出: 2  <br>([4,3])<br><br>(**和大於S找最短**)                                                 | 使用滑动窗口动态调整窗口范围，记录最短长度。(最長最短用Two pointers.)                                                                                                                      |
| 1507<br>*<br>(h)           | 和至少为 K 的最短子数组 [[Shortest Subarray with Sum at Least K]] | 给定一个整数数组，找到和至少为K的最短子数组长度，若不存在返回-1。                           | 输入:  <br>nums = <br>[2,3,1,2,4,3]<br>s = 7  <br><br>输出: 2  <br>([4,3])                                                                      | 使用单调队列记录前缀和，动态检查当前子数组和是否满足条件并更新最短长度。                                                                                                                            |
| 463<br>*<br>(e)            | 整數排序 [[Classical Sort Integers]]                        | 对给定的整数数组进行排序，并返回排序后的数组。                                      | 输入:  <br>nums = <br>[3,2,1,4,5]  <br><br>输出: <br>[1,2,3,4,5]<br><br>O(nlogn),O(n)                                                           | 使用快速排序或内置排序方法对数组进行排序。                                                                                                                                           |
| 366<br><br>(e)             | [[Fibonacciseries]]<br>斐波纳契数列                           | 斐波纳契数列是指：前2个数是 0 和 1 。第 i 个数是第 i-1 个数和第i-2 个数的和              | 输入: <br>series=<br>0, 1, 1, 2, <br>3, 5, 8, 13, <br>21, 34..                                                                                | 尋找Fibonacci數列的第N的數. 可以建立一個fib=[0,1]. for迴圈從2開始到n+1. i=2時0+1=1更新成[1,1],i=3時更新成[1,2], i=4時更新成[3,2]. 其中1+2=array[3]使用fib[i%2] = fib[0]+fib[1]更新數值輪流存在fib[0]跟fib[1] |
| 604<br>*<br>(e)            | 滑动窗口内数的和 [[Window Sum]]                                 | 给定一个数组和窗口大小 k，返回每个窗口的元素和。                                    | 输入:  <br>nums = <br>[1,2,3,4,5]<br>k = 3  <br><br>输出: [6,9,12]                                                                              | 使用双指针滑动窗口计算每个窗口的和，避免重复计算。                                                                                                                                       |
| 362<br>**<br>(h)           | [[Sliding Window Maximum]]滑动窗口的最大值                      | 给定一个整数数组和滑动窗口大小，找出每个窗口中的最大值。                                 | 输入: <br>nums = <br>[1,3,-1,-3,<br>5,3,6,7] <br>k = 3 <br><br>输出: <br>[3,3,5,5,6,7]                                                          | 使用双端队列（deque）维护当前窗口的最大值索引。遍历数组时，移除队列中不在当前窗口范围内的元素，并移除队列中小于当前元素的所有元素，然后将当前元素索引添加到队列。当前元素索引大于等于窗口大小时，队首即为当前窗口最大值。                                                 |
| 616<br>*<br>(m)            | 课程表 II [[Course Schedule II]]                           | 判断是否可以完成所有课程，并返回完成课程的顺序。你只要返回一种就可以了。                         | 输入: <br>n = 4,<br>prerequisites = <br>[ [1,0],[2,0],<br>[3,1],[3,2] ] <br><br>输出: <br>[0,1,2,3] or <br>[0,2,1,3]                            | 使用 BFS 实现**拓扑排序**，记录节点的入度，依次完成课程。                                                                                                                               |
| 152<br><br>(m)             | [[Combinations]]组合                                      | 找到从 n 个数字中选择 k 个数字的所有组合。                                     | 输入:  <br>n = 4  ([1,2,3,4])<br>k = 2  <br><br>输出:  <br>[ [2,4],[3,4],<br>[2,3],[1,2],<br>[1,3],[1,4] ]<br>                                  | 使用回溯法和哈希表记录每次选择的数字。                                                                                                                                             |
| 368<br>*<br>(h)            | 表达式求值 [[Expression Evaluation]]                         | 给一个用字符串表示的表达式数组，求出这个表达式的值。                                   |                                                                                                                                             | 使用递归的方法，先处理 +-<br>再处理 */最后再处理括号。                                                                                                                                |
| 1274<br><br>(m)<br>        | [[Find K Pairs with Smallest Sum]]查找和最小的K对数字            | 找到两个已排序数组中和最小的 k 对数对。                                        | 输入:  <br>nums1 = [1,7,11]  <br>nums2 = [2,4,6]  <br><br>k = 3  <br>输出:  <br>[ [1,2],[1,4],<br>[1,6] ]                                       | 使用最小堆或单调栈动态生成数对并维护大小。                                                                                                                                           |
| 547<br>**<br>(e)           | 两数组的交集 [[Intersection of Two Arrays]]                   | 给定两个数组，返回它们的交集，结果中不包含重复元素。                                   | 输入:  <br>nums1 = <br>[1,2,2,1], <br>nums2 = [2,2]  <br><br>输出: [2]                                                                          | 使用哈希表记录第一个数组的元素，遍历第二个数组时检查是否存在于哈希表中。                                                                                                                            |
| 589<br>*<br>(m)            | 连接图 [[Connecting Graph]]                                | 判断图中两个节点是否连通，并支持动态合并节点。                                      | 输入:<br>ConnectingGraph(5)<br>query(1, 2)<br>connect(1, 2)<br>query(1, 3) <br>connect(2, 4)<br>query(1, 4) <br><br>输出:<br>[false,false,true] | 使用并查集维护节点连通关系，查询时检查根节点是否相同。                                                                                                                                     |
| 540<br><br>(m)<br>         | [[Zigzag Iterator]]左旋右旋迭代器                              | 给定两个列表，实现一个迭代器，以之字形顺序输出两个列表的元素。                              | 输入:  <br>v1 = [1,2]  <br>v2 = [3,4,5,6]  <br><br>输出:  <br>[1,3,2,4,5,6]                                                                     | 使用队列存储非空列表的迭代器，按顺序依次访问。                                                                                                                                         |
| 480<br>**<br>(e)           | 二叉树的<br>所有路径 <br>[[Binary Tree Paths]] <br>             | 找出二叉树中从根到叶子的所有路径。                                            | 输入：<br>{1,2}<br><br>输出：<br>["1->2"]                                                                                                         | 使用 DFS 遍历所有路径，记录从根到叶子的每条路径。                                                                                                                                     |
| 88<br>**<br>(m)            | 最近公共祖先 [[Lowest Common Ancestor (LCA)]]                 | 找出二叉树中两个节点的最近公共祖先，节点一定存在树中。                                  | 输入:  <br>root = <br>{4,3,7,#,#,5,6}<br>p = 3, <br>q = 5  <br><br>输出: 3                                                                      | 递归检查左右子树是否包含目标节点，结合二叉树特性优化查找。                                                                                                                                   |
| 612<br>*<br>(m)            | [[K Closest Points]] K个最近的点                             | 找到离原点最近的 k 个点。                                               | 输入:  <br>points = <br>[ [1,3], [-2,2],<br>[2,-2] ]  <br>k = 2 <br> <br>输出:  <br>[ [-2,2],[2,-2] ]                                           | 使用最大堆存储 k 个最近的点，动态比较并维护堆的大小。                                                                                                                                    |
| 77<br>**<br>(m)<br>        | 最长公共子序列 [[Longest Common Subsequence]]                  | 找到两个字符串的最长公共子序列长度。                                           | 输入:  <br>text1 = "abcde"<br>text2 = "ace"  <br><br>输出: 3                                                                                    | 使用二维动态规划表记录两个字符串的匹配情况，逐步更新最长子序列长度。                                                                                                                              |
| 149<br>*<br>(m)            | [[Best Time to Buy and Sell Stock]]买卖股票的最佳时机            | 找到最大利润，允许一次买入和一次卖出股票。                                        | 输入:  <br>prices = [7,1,5,3,6,4]  <br>输出:  <br>5                                                                                             | 使用哈希表记录最低价格和当前利润。                                                                                                                                               |

