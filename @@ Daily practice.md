


| **题目编号**                   | **题目名称 (英文/中文)**                                    | **题目简述 (中文)**                                                | **样例**                                                                                                                    | **解法**                                                                                        |
| -------------------------- | --------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------- |
| 433<br>**<br>(e)           | 岛屿的个数 [[Number of Islands]]                         | 给定一个二维网格，计算其中岛屿的数量。                                          | 输入：<br>[<br>  [1,1,0,0,0],<br>  [0,1,0,0,1],<br>  [0,0,0,1,1],<br>  [0,0,0,0,0],<br>  [0,0,0,0,1]<br>]<br><br>输出：<br>3    | 使用 BFS 遍历每个岛屿，将相邻陆地标记为已访问。                                                                    |
| 15<br>**<br>(m)<br><br>PR  | 全排列 <br>[[Permutations]]                            | 给定一个没有重复数字的数组，返回所有可能的排列。                                     | 输入：<br>[1,2,3]<br><br>输出：[<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1] ]           | 使用 DFS 和回溯生成所有排列组合。                                                                           |
| 457<br><br>(e)             | [[Classical Binary Search]]<br>经典二分查找问题             | 在排序数组中找target，返回该数出现的任意位置，如果不存在，返回 -1。                       | 输入: <br>nums = <br>[1,2,2,3,4,4]<br>target=2<br><br>输出: <br>1 or 2                                                        | Array從頭尾開始用雙指針start, end取中位數mid比較target.然後取左半邊array或右半邊array繼續逼近, 最後start, end應該落在target區間的左右 |
| 56<br>**<br>(e)            | [[Two Sum]]<br>两数之和                                 | 在数组中找到两个数，使得它们的和等于目标值，返回它们的下标。                               | 输入: <br>[2, 7, 11, 15]<br>target = 9 <br><br>输出: [0, 1]<br><br>O(nlogn),O(n)                                              | 先排序然後用雙指針從左右往中間, 和target比較決定往右往左                                                              |
| 156<br>**<br>(e)           | [[Merge Intervals]]<br>合并区间                         | 给定一组区间，合并所有重叠的区间。                                            | 输入: <br>[(1,3),(2,6),<br>(8,10),(15,18)]<br> <br>输出: [(1,6),<br>(8,10),(15,18)]                                           | 按区间起点排序，遍历并合并重叠区间。                                                                            |
| 13<br>*<br>(e)             | [[Implement strStr]]字符串查找                           | 实现 `strStr()` 函数，返回子字符串在母字符串中首次出现的索引，若不存在则返回 -1。             | 输入: <br>source = "abcdabcdefg", <br>target = "bcd" <br><br>输出: 1<br><br>暴力匹配（Brute Force）<br>O(m*n),O(1)                  | 使用双指针從0,0出發遍历源字符串，检查目标字符串是否匹配                                                                 |
| **138**<br>*<br>(e)        | [[Subarray Sum]]<br>子数组之和为零                         | 给定一个整数数组，找到和为零的子数组，返回第一个出现的子数组的起始和结束下标。                      | 输入: <br>[-3, 1, 2, -3, 4] <br><br>输出: <br>[0, 2]<br><br>(和為0 [-3, 1, 2])<br>O(n)                                          | 使用前缀和数组，记录每个前缀和第一次出现的位置，若再次出现相同的前缀和，则表示子数组和为零。                                                |
| 35<br>*<br>(e)             | [[Reverse Linked List]]翻转链表                         | 反转一个链表。                                                      | 输入: 1->2->3->null 输出: 3->2->1->null                                                                                       | 使用迭代或递归方法反转链表。迭代方法中，遍历链表，将当前节点的 next 指向前一个节点。递归方法中，递归反转子链表，然后调整指针。                            |
| 494<br>*<br>(e)            | [[Implement Stack using Queues]]双队列实现栈              | 使用队列实现栈，支持 `push(x)`、`pop()`、`top()` 和 `empty()` 操作。         | 输入：<br>push(1)<br>pop()<br>push(2)<br>isEmpty() // return false<br>top() // return 2<br>pop()<br>isEmpty() // return true | 使用两个队列实现栈功能：一个队列用于存储元素，另一个队列用于辅助反转元素顺序。每次插入元素时，将新元素添加到辅助队列，然后将主队列的所有元素依次移动到辅助队列，交换主辅队列。       |
| 1206<br><br>(e)            | [[Next Greater Element I]]<br>下一个更大元素 I             | 给定两个数组 `nums1` 和 `nums2`，找出 `nums1` 中每个元素在 `nums2` 中的下一个更大元素 | 输入:  <br>nums1 = [4,1,2], nums2 = [1,3,4,2].<br>输出: [-1,3,-1]                                                             | 使用 单调递减栈 来找到 nums2 中每个元素的下一个更大值, 使用 哈希表记录每个元素的下一个更大值，方便在nums1中查找                              |
| 124<br>*<br>(m)            | [[Longest Consecutive Sequence]]最长连续序列              | 给定一个未排序的整数数组，找出最长连续序列的长度。                                    | 输入:  <br>nums = [100,4,200,1,3,2]  <br>输出:  <br>4 (1,2,3,4)                                                               | 使用哈希表记录数组中的数字，动态扩展连续序列的长度。                                                                    |
| 67<br>*<br>(e)             | [[Binary Tree Inorder Traversal]]- 二叉树的中序遍历         | 返回二叉树的中序遍历结果。                                                | 输入:  <br>root = [1,null,2,3]  <br>输出:  <br>[1,3,2]                                                                        | 使用递归或栈完成中序遍历操作。                                                                               |
|                            |                                                     |                                                              |                                                                                                                           |                                                                                               |
| 8<br>*<br>(e)              | [[Rotate String]]旋转字符数组                             | 给定一个字符串和一个偏移量，根据偏移量旋转字符串。                                    | 输入: <br>"abcdefg"<br>offset = 3 <br><br>输出: <br>"efgabcd"<br><br>O(n),O(n)                                                | 将字符串分为两部分，分别反转，然后再整体反转。                                                                       |
| 647<br>*<br>(m)            | [[Find All Anagrams in a String]]子串字谜               | 在字符串中找到目标字符串所有变位词的起始索引                                       | 输入:  <br>s = "cbaebabacd"  <br>p = "abc" <br> <br>输出:  [0,6] <br><br>("cba","bac")                                        | 使用滑动窗口和哈希表记录字符频率。                                                                             |
| 1844<br>*<br>(m)           | [[Subarray Sum Equals to K II]] 子数组和为K的最短子数组        | 给定一个整数数组和一个整数k，你需要找到和为k的最短非空子数组，并返回它的长度。                     | 输入:  <br>nums = [1, 1, 1, 2], k = 3  <br>输出: 2  <br><br>(**和為0找最短**[1,2])<br>O(n),O(n)                                    | 使用前缀和与哈希表记录出现的和，通过快速查找加速匹配和为K的子数组数量。(用Two pointers?)                                          |
| 460<br>*<br>(m)            | [[Find K Closest Elements]]<br>在排序数组中找最接近的K个数       | 在升序排列A中找与target最接近的k个整数                                      | 输入: <br>A = [1, 2, 3]<br>target = 2<br>k = 3<br><br>输出: <br>[2, 1, 3]                                                     | 先利用Binary Search找到最接近target的數, 然後用雙指針向左向右尋找最接近target直到找到k個                                    |
| 58<br>**<br>(m)            | 四数之和  [[4Sum]]                                      | 给一个包含n个数的整数数组S，在S中找到所有使得和为给定整数target四元组(a, b, c, d)          | 输入:  <br>numbers = [2,7,11,15], target=3<br>输出: []<br>O(n^3),O(1)                                                         | 固定两个点，然后用双指针的做法，扫描一下后续数组，记录答案即可。                                                              |
| 112<br><br>(e)<br>         | [[Remove Duplicates from Sorted List]]删除排序链表中的重复元素  | 删除排序链表中的重复元素，使每个元素只出现一次。                                     | 输入: 1->1->2->3->3->null 输出: 1->2->3->null                                                                                 | 遍历链表，删除重复的节点。                                                                                 |
| 40<br><br>(m)              | [[Implement Queue by Two Stacks]]用栈实现队列             | 使用两个栈实现队列，支持 `push(element)`、`pop()` 和 `top()` 操作。           | 队列操作 = <br>    push(1)<br>    pop()    <br>    push(2)<br>    push(3)<br>    top()    <br>    pop()                       | 使用两个栈实现队列功能：一个栈用于入队操作，另一个栈用于出队操作。当出队栈为空时，将入队栈的所有元素依次弹出并压入出队栈，然后从出队栈弹出元素以实现队列的先进先出特性。          |
| 1276<br>*<br>(e)<br>       | [[Sum of Two Integers]]两整数之和                        | 使用位运算计算两个整数的和，而不能使用 `+` 和 `-` 操作符。                           | 输入:  <br>a = 1, b = 2  <br>输出:  <br>3                                                                                     | 使用位运算模拟加法过程，按位计算进位和当前位值。                                                                      |
| 611<br>**<br>(m)<br><br>PR | 骑士的最短路线 [[Knight Shortest Path]]                    | 在棋盘上从起点移动到终点，返回骑士所需的最小步数。                                    | 输入:<br>[ [0,0,0],<br> [0,0,0],<br> [0,0,0] ]<br>source = [2, 0] <br>destination <br>= [2, 2] <br><br>输出: 2                | 使用 BFS 搜索骑士的合法移动路径，记录访问状态以避免重复。                                                               |
| 17<br>**<br>(m)<br><br>PR  | 子集 <br>[[Subsets]]                                  | 给定一个没有重复元素的数组，返回所有可能的子集。                                     | 輸入<br>[1,2,3]<br><br>輸出<br>[ [], [1], [1, 2],<br> [1, 2, 3], [1, 3], <br>[2], [2, 3], [3] ]                               | 使用 DFS 生成所有可能的组合，逐步扩展路径。                                                                      |
| 12<br>*<br>(m)             | [[Min Stack]]带最小值操作的栈                               | 设计一个支持常数时间内获取最小值的栈，支持 `push`、`pop` 和 `getMin` 操作。            | 输入:  <br>stack.push(-2)  <br>stack.push(0)  <br>stack.push(-3)  <br>stack.getMin()  <br>输出: -3                            | 使用两个栈，一个存储元素，一个存储最小值，更新最小值时同步操作。                                                              |
| 363<br>**<br>(m)           | [[Trapping Rain Water]]接雨水                          | 计算柱状图中能够存储的雨水总量。                                             | 输入:  <br>height = [0,1,0,2,1,0,1,3,  <br>2,1,2,1]  <br>输出:  <br>6                                                         | 使用双指针和单调栈记录左右最大高度，计算每个位置的雨水。                                                                  |
| 128<br>**<br>(m)           | 哈希函数 [[Hash Function]]                              | 设计一个简单的哈希函数，将字符串映射到指定大小的哈希表。                                 | 输入:  <br>key = "hello", HASH_SIZE = 10  <br>输出: 2                                                                         | 使用字符串的ASCII值结合哈希表大小进行取模运算。                                                                    |
| 70<br>*<br>(m)<br>         | [[Binary Tree Level Order Traversal II]]二叉树的层次遍历 II | 返回二叉树的层次遍历结果（从底层到顶层）。                                        | 输入:  <br>root = [3,9,20,null,null,15,7]  <br>输出:  <br>[[15,7],[9,20],[3]]                                                 | 使用队列按层遍历节点，结果反转。                                                                              |
| 597<br>**<br>(e)           | 具有最大平均数的子树 [[Subtree with Maximum Average]]         | 找出二叉树中具有最大平均数的子树。                                            | 输入:  <br>root = [1,-5,11,1,2,4,-2]  <br>输出: [11,4,-2]                                                                     | 使用递归后序遍历计算子树的节点和和节点数，动态更新最大平均值。                                                               |
| 130<br><br>(m)             | [[Heapify]] 堆化                                      | 给定一个未排序的数组，将其调整为堆（最小堆或最大堆）。                                  | 输入:  <br>nums = [3,2,1,4,5]  <br>输出:  <br>[1,2,3,4,5]                                                                     | 使用下沉操作构建堆，从最后一个非叶节点向上调整堆。                                                                     |
| 93<br>*<br>(e)             | 平衡二叉树 [[Balanced Binary Tree]]                      | 判断一棵二叉树是否为平衡二叉树（每个节点的左右子树高度差不超过 1）。                          | 输入:  <br>root = [3,9,20,null,null,15,7]  <br>输出: true                                                                     | 使用递归计算每个节点的高度，检查左右子树的高度差，若所有节点满足条件则为平衡二叉树。                                                    |