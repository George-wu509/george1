Lintcode 89
给定 `n` 个不同的正整数，整数 `k`(k≤n)(k≤n)以及一个目标数字 `target`。在这 `n` 个数里面找出 `k` 个数，使得这 `k` 个数的和等于目标数字，求问有多少种方案？

Example:
**样例 1：**
输入：
```python
A = [1,2,3,4]
k = 2
target = 5
```
输出：
```python
2
```
解释：
1 + 4 = 2 + 3 = 5  

**样例 2：**
输入：
```python
A = [1,2,3,4,5]
k = 3
target = 6
```
输出：
```python
1
```
解释：
只有这一种方案。 1 + 2 + 3 = 6

```python
class Solution:
    def kSum(self, A, k, target):
        n = len(A)
        dp = [
            [[0] * (target + 1) for _ in range(k + 1)],
            [[0] * (target + 1) for _ in range(k + 1)],
        ]
        
        # dp[i][j][s]
        # 前 i 个数里挑出 j 个数，和为 s
		# Example: k=2, target = 3
        # dp = [
		#		[[0,0,0,0],[0,0,0,0],[0,0,0,0]]
		#		[[0,0,0,0],[0,0,0,0],[0,0,0,0]]]

        dp[0][0][0] = 1
        for i in range(1, n + 1):
            dp[i % 2][0][0] = 1
            for j in range(1, min(k + 1, i + 1)):
                for s in range(1, target + 1):
                    dp[i % 2][j][s] = dp[(i - 1) % 2][j][s]
                    if s >= A[i - 1]:
                        dp[i % 2][j][s] += dp[(i - 1) % 2][j - 1][s - A[i - 1]]
                        
        return dp[n % 2][k][target]
```
pass


# **LintCode 89: K Sum（选出 k 个数之和等于 target 的方案数）**

---

## **问题描述**

给定一个整数数组 `A`，一个整数 `k` 和一个目标值 `target`，找出 **恰好 `k` 个数的和等于 `target` 的方案数**。

---

## **示例**

`输入: A = [1,2,3,4] k = 2 target = 5  输出: 2`

**解释**

`可能的方案有: 1. 选 [1,4]，1+4=5 2. 选 [2,3]，2+3=5 总共有 2 种方案`

---

## **解法：动态规划（DP）**

### **核心思路**

本题类似于 **"0/1 背包问题"**，需要用 **动态规划** 来求解：

1. **定义状态 `dp[i][j][s]`**
    - **`dp[i][j][s]` 表示**：前 `i` 个数中，**恰好选 `j` 个数**，它们的和等于 `s` 的方案数。
    - 我们要计算 `dp[n][k][target]`，即：
        - 在 **前 `n` 个数** 里
        - **恰好选 `k` 个数**
        - **使它们的和等于 `target`**

---

2. **状态转移方程**
    - 不选 `A[i-1]`（当前数）：
   
        `dp[i][j][s] = dp[i-1][j][s]`
        
    - 选 `A[i-1]`（当前数）：

        `if s >= A[i-1]:  # 只有当 s >= A[i-1] 时才能选择     dp[i][j][s] += dp[i-1][j-1][s - A[i-1]]`
        

---

1. **初始化**
    - **`dp[0][0][0] = 1`**（空集合选 0 个数，和为 0，方案数为 1）。
    - **`dp[i][0][0] = 1`**（从前 `i` 个数中选 0 个，和为 0，方案数为 1）。
    - **其余 `dp[i][j][s] = 0`**（默认无方案）。

---

2. **优化空间**
    - 由于 `dp[i]` 仅依赖于 `dp[i-1]`，我们可以 **滚动数组优化**，只用 `dp[2]` 来存储数据。

## **执行过程**

**输入**

`A = [1,2,3,4] k = 2 target = 5`

---

### **Step 1: 初始化 DP 数组**

- `dp[0][0][0] = 1`
- 其他 `dp[i][j][s] = 0`

---

### **Step 2: 递推计算**

#### **第 1 个数 `1`**

`dp[1][1][1] = 1   # 选 1 作为 1 个数，和为 1`

---

#### **第 2 个数 `2`**

`dp[2][1][2] = 1   # 选 2 作为 1 个数，和为 2 dp[2][2][3] = 1   # 选 [1,2] 作为 2 个数，和为 3`

---

#### **第 3 个数 `3`**

`dp[3][1][3] = 1   # 选 3 作为 1 个数，和为 3 dp[3][2][4] = 1   # 选 [1,3] 作为 2 个数，和为 4 dp[3][2][5] = 1   # 选 [2,3] 作为 2 个数，和为 5 ✅`

---

#### **第 4 个数 `4`**

`dp[4][1][4] = 1   # 选 4 作为 1 个数，和为 4 dp[4][2][5] = 1   # 选 [1,4] 作为 2 个数，和为 5 ✅`

---

### **最终结果**

`dp[4][2][5] = 2`，即有 **2 种方案**：

3. 选 `[1,4]`
4. 选 `[2,3]`

---

## **时间与空间复杂度分析**

### **时间复杂度**

- 三重循环：
    - **遍历 `n` 个数** → `O(n)`
    - **遍历 `k`（选取的个数）** → `O(k)`
    - **遍历 `target`（可能的目标和）** → `O(target)`
- **总时间复杂度**： O(n×k×target)

### **空间复杂度**

- `dp[2][k+1][target+1]` 使用滚动数组，节省 `O(n)`
- **总空间复杂度**： O(2×k×target)=O(k×target)
---

## **其他解法**

### **1. 递归回溯（暴力法）**

- **思路**
    - 遍历所有可能的子集，检查是否满足 `k` 和 `target`。
    - **时间复杂度 `O(2^n)`，适用于小规模数据**。

### **2. 记忆化搜索**

- **思路**
    - 递归求解 `dp[i][j][s]`，使用哈希表存储已计算的结果。
    - **时间复杂度 `O(n × k × target)`，空间 `O(n × k × target)`**。

---

## **方法比较**

|方法|思路|时间复杂度|空间复杂度|适用情况|
|---|---|---|---|---|
|**动态规划（当前解法）**|**滚动数组优化 DP**|`O(n × k × target)`|`O(k × target)`|**适用于大数据集**|
|**递归回溯**|**遍历所有可能子集**|`O(2^n)`|`O(k)`|**适用于小规模数据**|
|**记忆化搜索**|**递归 + 记忆化存储**|`O(n × k × target)`|`O(n × k × target)`|**适用于数据适中**|

---

## **总结**

- **最优解** ✅ **动态规划 `O(n × k × target)`**
- **数据较小时可用 `O(2^n)` 的回溯**
- **如果 `n` 适中，可用记忆化搜索**

🚀 **"DP 滚动数组" 是最优解，适用于大规模数据！**