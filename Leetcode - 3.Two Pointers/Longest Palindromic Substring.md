
给出一个字符串（假设长度最长为1000），求出它的最长回文子串，你可以假定只有一个满足条件的最长回文串。

**样例1**
```python
输入:"abcdzdcab"
输出:"cdzdc"
```

**样例2**
```python
输入:"aba"
输出:"aba"
```


```python
class Solution:
    """
    @param s: input string
    @return: a string as the longest palindromic substring
    """
    def longest_palindrome(self, s: str) -> str:
        if not s:
            return ""
        
        def expand_center(left, right):
            while left >= 0 and right < len(s) and s[left] == s[right]:
                left -= 1
                right += 1
            return left + 1, right - 1

        start, end = 0, 0
        for i in range(len(s)):
            # 奇數長度回文
            l1, r1 = expand_center(i, i)
            # 偶數長度回文
            l2, r2 = expand_center(i, i + 1)
            
            # 更新最長回文子串
            if r1 - l1 > end - start:
                start, end = l1, r1
            if r2 - l2 > end - start:
                start, end = l2, r2

        return s[start:end + 1]
```
pass

解釋
Step1:
從最左端開始往右移, 這個位置是回文的中心點. 有兩種可能回文的方式, (1. 奇數長度)中心點譬如id=3可能是任何數, 中心點的左端id=2跟右端id=4是相同. 另一種(2. 偶數長度)是中心點的左右側(id=2,3)都一樣. 在每個中心點都測試這兩個方式


### **問題描述**

給定一個字符串 `s`，尋找其中的**最长回文子串**。回文子串是指從左到右與從右到左讀起來相同的子串。

---

### **雙指針法：中心擴展**

#### **1. 解法思路**

1. **中心擴展的觀點**：
    
    - 每個回文串都有一個**中心**，這個中心可以是：
        - 單個字符（如 "aba" 的中心是 'b'）。
        - 兩個字符之間的空隙（如 "abba" 的中心是 'bb' 之間的空隙）。
    - 因此，對於每個可能的中心，我們可以向左右擴展，直到無法構成回文。
2. **雙指針的應用**：
    
    - 將雙指針分別指向中心，並同時向兩邊擴展。
    - 當左指針 `left` 和右指針 `right` 指向的字符相等時，擴展範圍。
    - 當擴展到不符合回文條件時，記錄下當前的回文區間。
3. **遍歷所有可能的中心**：
    
    - 假設字符串長度為 `n`，共有 `2n-1` 個中心需要檢查（包括每個字符及每對相鄰字符間的空隙）。
4. **更新結果**：
    
    - 每次擴展結束後，檢查當前回文子串是否比之前的結果更長，若是則更新最長回文子串的起點和終點。

---

#### **2. 代碼分解與步驟詳解**
```python
def longest_palindrome(self, s: str) -> str:
    if not s:  # 處理空字符串的特殊情況
        return ""
    
    def expand_center(left, right):
        # 擴展中心，直到不滿足回文條件為止
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1  # 左指針向左移
            right += 1  # 右指針向右移
        # 返回回文子串的起點和終點（注意：left+1 和 right-1 才是有效區間）
        return left + 1, right - 1

    start, end = 0, 0  # 初始化最長回文子串的起點和終點

    for i in range(len(s)):
        # 奇數長度回文（以 s[i] 為中心）
        l1, r1 = expand_center(i, i)
        # 偶數長度回文（以 s[i] 和 s[i+1] 之間為中心）
        l2, r2 = expand_center(i, i + 1)
        
        # 更新最長回文子串
        if r1 - l1 > end - start:  # 如果奇數回文更長
            start, end = l1, r1
        if r2 - l2 > end - start:  # 如果偶數回文更長
            start, end = l2, r2

    # 返回最長回文子串
    return s[start:end + 1]

```

---

#### **3. 例子分析**

##### 輸入：

`s = "babad"`

##### 運行過程：

1. **初始設置**：
    
    - `start = 0, end = 0`，回文子串初始化為第一個字符。
2. **遍歷每個中心**：
    
    - **中心 0 (`s[0] = 'b'`)**：
        
        - 奇數回文：擴展後為 "b"，範圍 `[0, 0]`。
        - 偶數回文：無效，範圍 `[1, 0]`。
        - 更新結果：最長回文子串為 "b"。
    - **中心 1 (`s[1] = 'a'`)**：
        
        - 奇數回文：擴展後為 "aba"，範圍 `[0, 2]`。
        - 偶數回文：無效，範圍 `[2, 1]`。
        - 更新結果：最長回文子串為 "aba"。
    - **中心 2 (`s[2] = 'b'`)**：
        
        - 奇數回文：擴展後為 "bab"，範圍 `[0, 2]`。
        - 偶數回文：無效，範圍 `[3, 2]`。
        - 更新結果：最長回文子串仍為 "aba"。
    - **中心 3 (`s[3] = 'a'`)**：
        
        - 奇數回文：擴展後為 "aba"，範圍 `[2, 4]`。
        - 偶數回文：無效，範圍 `[4, 3]`。
        - 更新結果：最長回文子串仍為 "aba"。
    - **中心 4 (`s[4] = 'd'`)**：
        
        - 奇數回文：擴展後為 "d"，範圍 `[4, 4]`。
        - 偶數回文：無效，範圍 `[5, 4]`。
        - 更新結果：最長回文子串仍為 "aba"。

##### 最終結果：

`"aba"` 或 `"bab"`（同樣長度的回文子串）。

---

#### **4. 時間與空間複雜度分析**

1. **時間複雜度**：
    
    - 對於每個中心（共有 `2n-1` 個中心），執行一次線性擴展，最多需檢查 `O(n)` 個字符。
    - 總時間複雜度為 **`O(n^2)`**。
2. **空間複雜度**：
    
    - 只使用了常數空間來存儲指針和變量。
    - 總空間複雜度為 **`O(1)`**。








### **問題描述**

找到字符串 `s` 中的**最长回文子串**。回文子串指的是從左到右和從右到左讀起來相同的字符串。

---

### **解法：動態規劃（非雙指針）**

此解法使用**動態規劃**的方式來計算。雙指針法會在後面列出。

#### **1. 思路**

1. **動態規劃的核心**：
    
    - 定義 `dp[i][j]` 表示子串 `s[i:j+1]` 是否為回文串。
    - 狀態轉移方程：
        - 當 `s[i] == s[j]` 時，檢查內部子串 `s[i+1:j-1]` 是否是回文： dp[i][j]=(s[i]==s[j])∧dp[i+1][j−1]dp[i][j] = (s[i] == s[j]) \land dp[i+1][j-1]dp[i][j]=(s[i]==s[j])∧dp[i+1][j−1]
        - 初始條件：單字符子串 `s[i]` 一定是回文，即 `dp[i][i] = True`。
2. **構造解法**：
    
    - 遍歷所有子串的長度（由短到長）。
    - 如果 `dp[i][j]` 為真，更新最長回文子串的起始位置和長度。

---

#### **2. 代碼詳解**

以下是代碼的邏輯逐步分解：
```python
def longest_palindrome(self, s: str) -> str:
    if not s:  # 空字符串直接返回空結果
        return ""
        
    n = len(s)  # 字符串長度
    dp = [[False] * n for _ in range(n)]  # 初始化動態規劃表
    
    # 所有單個字符都是回文串
    for i in range(n):
        dp[i][i] = True
        
    # 初始化相鄰字符的情況
    for i in range(1, n):
        dp[i][i - 1] = True  # 空串視為回文
    
    longest, start, end = 1, 0, 0  # 記錄當前最長回文子串的長度和起始位置

    # 遍歷所有子串長度
    for length in range(1, n):  # 子串長度由 1 到 n-1
        for i in range(n - length):  # 子串起始位置
            j = i + length  # 子串結束位置
            # 檢查是否為回文
            dp[i][j] = s[i] == s[j] and dp[i + 1][j - 1]
            # 如果是回文且長度更長，更新最長子串信息
            if dp[i][j] and length + 1 > longest:
                longest = length + 1
                start, end = i, j
    
    return s[start:end + 1]  # 返回最長回文子串

```

---

#### **3. 例子：逐步運行**

##### 輸入：

`s = "babad"`

##### 運行過程：

1. **初始化**：
    
    - `n = 5`，`dp` 表初始化為全 `False`。
    - 單字符初始化：`dp[i][i] = True`。
2. **長度為 1 的子串**：
    
    - `s[i:i+1]`（每個單字符）是回文，`longest = 1`，`start = 0, end = 0`。
3. **長度為 2 的子串**：
    
    - 檢查每個相鄰字符是否相等，例如 `s[0:1] = "ba"` 不是回文，`dp[0][1] = False`。
4. **長度為 3 的子串**：
    
    - 檢查 `s[0:2] = "bab"`，因為 `s[0] == s[2]` 且 `dp[1][1] = True`，所以 `dp[0][2] = True`。
    - 更新 `longest = 3`，`start = 0, end = 2`。
5. **長度為 4 的子串**：
    
    - 檢查 `s[0:3] = "baba"`，不是回文，`dp[0][3] = False`。
6. **長度為 5 的子串**：
    
    - 檢查 `s[0:4] = "babad"`，不是回文。

##### 最終結果：

`longest = 3`，`start = 0, end = 2`，回文子串為 `"bab"`。

---

#### **4. 時間與空間複雜度分析**

1. **時間複雜度**：
    
    - 外層遍歷子串長度 `O(n)`。
    - 內層遍歷子串起點 `O(n)`。
    - 每次檢查轉移方程需要 `O(1)` 時間。
    - 總時間複雜度為 **`O(n^2)`**。
2. **空間複雜度**：
    
    - 需要一個 `n x n` 的 DP 表，空間複雜度為 **`O(n^2)`**。

---
