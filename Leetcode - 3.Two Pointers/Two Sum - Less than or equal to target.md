Lintcode 609
给定一个整数数组，找出这个数组中有多少个不同的下标对，满足下标对中的两个下标所对应元素之和小于或等于目标值。返回下标对数。

样例
例1:
```python
"""
输入: nums = [2, 7, 11, 15], target = 24. 
输出: 5. 
解释:
2 + 7 < 24
2 + 11 < 24
2 + 15 < 24
7 + 11 < 24
7 + 15 < 24
```
例2:
```python
"""
输入: nums = [1], target = 1. 
输出: 0. 
```


```python
class Solution:
    # @param nums {int[]} an array of integer
    # @param target {int} an integer
    # @return {int} an integer
    def twoSum5(self, nums, target):
        # Write your code here
        l, r = 0, len(nums)-1
        cnt = 0
        nums.sort()
        while l < r:
            value = nums[l] + nums[r]
            if value > target:
                r -= 1
            else:
                cnt += r - l
                l += 1
        return cnt
```
pass

解釋為何用cnt+=r-l:
step1:  [ l, r ] = [ 0, 3 ]  value=17 ---> cnt+=3 代表 [ 0, 3 ], [ 0, 2 ], [ 0, 1 ]
step2:  [ l, r ] = [ 1, 3 ]  value=22 ---> cnt+=3 代表 [ 1, 3 ], [ 1, 2 ]


# **LintCode 609: Two Sum - Less than or Equal to Target（两数之和小于等于目标值的对数）**

---

## **问题描述**

给定一个整数数组 `nums` 和一个整数 `target`，找到数组中 **所有满足 `nums[i] + nums[j] ≤ target` 的数对 `(i, j)`**，返回**这样的数对数量**。

---

## **解法：双指针**

### **核心思路**

1. **先对数组进行排序**
    
    - 这样可以 **保证 `nums[l]` 最小，`nums[r]` 最大**，从而方便使用 **双指针遍历**。
2. **双指针 `l` 和 `r` 分别指向数组首尾**
    
    - **如果 `nums[l] + nums[r] > target`**：
        - 说明 `nums[r]` 太大了，**右指针左移 `r -= 1`**，尝试更小的数。
    - **如果 `nums[l] + nums[r] ≤ target`**：
        - 说明 **`nums[l]` 可以和 `[l+1, r]` 之间的所有数匹配**，即 **有 `r - l` 组数对**。
        - 计算 `cnt += r - l`。
        - **左指针右移 `l += 1`**，继续检查下一组匹配。

---

## **执行过程**

### **变量表**

|变量|说明|
|---|---|
|`nums`|经过排序的数组|
|`l`|左指针（最小值）|
|`r`|右指针（最大值）|
|`cnt`|统计满足条件的数对数目|

---

### **Step 1: 先排序**

假设输入：

`nums = [2, 7, 5, 3, 8] target = 10`

排序后：

`nums = [2, 3, 5, 7, 8]`

---

### **Step 2: 使用双指针**

#### **初始状态**

|变量|值|
|---|---|
|`l`|0|
|`r`|4|
|`cnt`|0|

---

#### **第一轮：检查 `nums[0] + nums[4] = 2 + 8 = 10`**

- `10 ≤ target (10)`，**符合条件**。
- **`l=0` 可以和 `[1, 2, 3, 4]` 匹配（4 组数对）**，`cnt += 4`。
- 右移 `l = 1`。

---

#### **第二轮：检查 `nums[1] + nums[4] = 3 + 8 = 11`**

- `11 > target (10)`，**不符合条件**。
- 左移 `r = 3`。

---

#### **第三轮：检查 `nums[1] + nums[3] = 3 + 7 = 10`**

- `10 ≤ target (10)`，**符合条件**。
- **`l=1` 可以和 `[2, 3]` 匹配（2 组数对）**，`cnt += 2`。
- 右移 `l = 2`。

---

#### **第四轮：检查 `nums[2] + nums[3] = 5 + 7 = 12`**

- `12 > target (10)`，**不符合条件**。
- 左移 `r = 2`，循环结束。

---

### **最终结果**

ini

複製編輯

`cnt = 4 + 2 = 6`

返回 `6`，即 `6` 组满足条件的数对。

---

## **时间与空间复杂度分析**

### **时间复杂度**

|操作|复杂度|说明|
|---|---|---|
|**排序 `nums`**|`O(n log n)`|需要排序数组|
|**双指针查找**|`O(n)`|每个元素最多访问一次|
|**总复杂度**|`O(n log n)`|由于排序占主导，最终复杂度 `O(n log n)`|

### **空间复杂度**

- 仅使用常数额外空间，**`O(1)`**。

---

## **其他解法**

### **1. 暴力法（O(n²)）**

- **思路**
    - 直接遍历所有 `i, j` 组合，检查 `nums[i] + nums[j] ≤ target`。
- **时间复杂度**
    - **`O(n²)`**，适用于小数据集。

### **2. 二分查找（O(n log n)）**

- **思路**
    - 固定 `nums[i]`，用 **二分查找** 找出 `j` 使得 `nums[i] + nums[j] ≤ target`。
- **时间复杂度**
    - `O(n log n)`（排序） + `O(n log n)`（二分查找） = **`O(n log n)`**。

---

## **方法比较**

|方法|思路|时间复杂度|空间复杂度|适用情况|
|---|---|---|---|---|
|**双指针（当前解法）**|**排序 + 左右指针**|`O(n log n)`|`O(1)`|**适用于大规模数据**|
|**暴力法**|**两层循环遍历**|`O(n²)`|`O(1)`|**适用于小数据集**|
|**二分查找**|**固定 `nums[i]`，用 `O(log n)` 二分查找 `j`**|`O(n log n)`|`O(1)`|**适用于 `n` 适中**|

---

## **总结**

- **最优解** ✅ **双指针 `O(n log n)`**
- **数据较小时可用 `O(n²)` 暴力法**
- **如果 `find()` 操作多，可用 `O(n log n)` 二分查找**

🚀 **"双指针 + 排序" 是最优解，适用于大规模数据！**