Lintcode 58
给一个包含`n`个数的整数数组`S`，在`S`中找到所有使得和为给定整数`target`的四元组`(a, b, c, d)`。

Example
**样例 1：**
输入：
```python
"""```
numbers = [2,7,11,15]
target = 3
```
输出：
```python
"""
[]
```
解释：
2 + 7 + 11 + 15 ！= 3，不存在满足条件的四元组。  

**样例 2：**
输入：
```python
"""
numbers = [1,0,-1,0,-2,2]
target = 0
```
输出：
```python
"""
[[-1, 0, 0, 1],[-2, -1, 1, 2],[-2, 0, 0, 2]]
```
解释：
有3个不同的四元组满足四个数之和为0。


```python
def four_sum(self, nums, target):
	nums.sort()
	res = []
	length = len(nums)
	for i in range(0, length - 3):
		if i and nums[i] == nums[i - 1]:
			continue
		for j in range(i + 1, length - 2):
			if j != i + 1 and nums[j] == nums[j - 1]:
				continue
			sum = target - nums[i] - nums[j]
			left, right = j + 1, length - 1
			while left < right:
				if nums[left] + nums[right] == sum:
					res.append([nums[i], nums[j], nums[left], nums[right]])
					right -= 1
					left += 1
					while left < right and nums[left] == nums[left - 1]:
						left += 1
					while left < right and nums[right] == nums[right + 1]:
						right -= 1
				elif nums[left] + nums[right] > sum:
					right -= 1
				else:
					left += 1
	return res
```
pass


# **LintCode 58: 4Sum（四数之和）**

---

## **问题描述**

给定一个整数数组 `nums` 和一个整数 `target`，找出所有 **不重复** 的 **四元组 `(a, b, c, d)`**，使得：

a+b+c+d=targeta + b + c + d = targeta+b+c+d=target

**注意：**

- **不能包含重复解**。
- **四元组 `(a, b, c, d)` 必须按升序排列**。

---

## **解法：排序 + 双指针**

### **核心思路**

1. **先对数组进行排序**
    
    - 这样可以 **保证四元组按升序排列**，方便去重处理。
2. **双层循环，固定前两个数 `nums[i], nums[j]`，用双指针 `left` 和 `right` 找 `c + d = target - (a + b)`**
    
    - `i` 遍历 `nums`，固定 `a`。
    - `j` 遍历 `nums[i+1:]`，固定 `b`。
    - `left` 指向 `j+1`，`right` 指向 `len(nums)-1`，双指针寻找 `c + d = target - (a + b)`。
3. **跳过重复元素**
    
    - **`nums[i] == nums[i-1]` 时跳过**，避免 `a` 重复。
    - **`nums[j] == nums[j-1]` 时跳过**，避免 `b` 重复。
    - **`nums[left] == nums[left-1]`，或 `nums[right] == nums[right+1]` 时跳过**，避免 `(c, d)` 重复。

---

## **执行过程**

### **变量表**

|变量|说明|
|---|---|
|`nums`|经过排序的数组|
|`i`|第一层循环，固定 `a`|
|`j`|第二层循环，固定 `b`|
|`left`|指向 `c` 的左指针|
|`right`|指向 `d` 的右指针|
|`sum`|`c + d` 需要满足 `sum = target - (a + b)`|
|`res`|存储满足条件的四元组|

---

### **Step 1: 先排序**

假设输入：

python

複製編輯

`nums = [1, 0, -1, 0, -2, 2] target = 0`

排序后：

ini

複製編輯

`nums = [-2, -1, 0, 0, 1, 2]`

---

### **Step 2: 使用双层循环 + 双指针**

#### **第一轮：固定 `i = 0`（`a = -2`），固定 `j = 1`（`b = -1`），寻找 `c + d = 3`**

|变量|值|
|---|---|
|`i`|0|
|`j`|1|
|`left`|2|
|`right`|5|
|`sum`|`3`|

- `nums[2] + nums[5] = 0 + 2 = 2`，小于 `3`，右移 `left = 3`。
- `nums[3] + nums[5] = 0 + 2 = 2`，小于 `3`，右移 `left = 4`。
- `nums[4] + nums[5] = 1 + 2 = 3`，**找到解 `[-2, -1, 1, 2]`**，记录到 `res`。

---

#### **第二轮：固定 `i = 0`（`a = -2`），固定 `j = 2`（`b = 0`），寻找 `c + d = 2`**

- `nums[3] + nums[5] = 0 + 2 = 2`，**找到解 `[-2, 0, 0, 2]`**。

---

#### **第三轮：固定 `i = 0`（`a = -2`），固定 `j = 3`（跳过）**

- `nums[3] == nums[2]`，跳过 `j = 3`，避免重复。

---

#### **第四轮：固定 `i = 1`（`a = -1`），固定 `j = 2`（`b = 0`），寻找 `c + d = 1`**

- `nums[3] + nums[4] = 0 + 1 = 1`，**找到解 `[-1, 0, 0, 1]`**。

---

### **最终结果**

lua

複製編輯

`res = [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]`

返回：

python

複製編輯

`[[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]`

---

## **时间与空间复杂度分析**

### **时间复杂度**

|操作|复杂度|说明|
|---|---|---|
|**排序 `nums`**|`O(n log n)`|需要排序数组|
|**三重循环遍历 `i, j, left, right`**|`O(n^3)`|`O(n)` 查找 `c + d`，`O(n^2)` 固定 `a, b`|
|**总复杂度**|`O(n^3)`|由于排序占主导，最终复杂度 `O(n^3)`|

### **空间复杂度**

- 仅使用常数额外空间，**`O(1)`**（不计 `res` 输出）。

---

## **其他解法**

### **1. 哈希表（O(n^2)）**

- **思路**
    - 计算 **所有 `a + b` 的和**，存入哈希表。
    - **查找 `target - (a + b)` 是否存在**。
- **时间复杂度**
    - `O(n^2) + O(n^2) = O(n^2)`。

### **2. 递归回溯（O(n^4)）**

- **思路**
    - 递归选择 `a, b, c, d`，找到和为 `target` 的组合。
- **时间复杂度**
    - `O(n^4)`，适用于小规模数据。

---

## **方法比较**

|方法|思路|时间复杂度|空间复杂度|适用情况|
|---|---|---|---|---|
|**双指针（当前解法）**|**排序 + 固定 `a, b` + 双指针找 `c, d`**|`O(n^3)`|`O(1)`|**最优解，适用于大数据**|
|**哈希表**|**存储 `a + b`，查找 `c + d`**|`O(n^2)`|`O(n^2)`|**适用于 `c + d` 变化快的情况**|
|**递归回溯**|**暴力搜索所有四元组**|`O(n^4)`|`O(1)`|**适用于小规模数据**|

---

## **总结**

- **最优解** ✅ **双指针 `O(n^3)`**
- **如果 `c + d` 变化快，可用 `O(n^2)` 哈希表**
- **如果 `n` 适中，可用 `O(n^4)` 递归回溯**