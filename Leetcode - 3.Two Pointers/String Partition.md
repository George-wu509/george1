
给出一个字符串，均为大写字母，将这个字符串划分成尽可能多的部分，使每种字母只会出现一个部分中。最后返回一个数组，这个数组包含每个部分的长度。

**样例 1：**
```python
输入：
"MPMPCPMCMDEFEGDEHINHKLIN"
输出：
[9,7,8]
解释：
"MPMPCPMCM"
"DEFEGDE"
"HINHKLIN"
```


```python
def split_String(self, s):
	n = len(s)
	st = ed = -1
	last = [0 for _ in range(26)]
	ans = []
	for i in range(n):
		last[ord(s[i]) - 65] = i
	for i in range(n):
		if ed == -1:
			st = i
			ed = last[ord(s[i]) - 65]
			if st == ed:
				ans.append(1)
				ed = -1
		elif i == ed:
			ans.append(ed - st + 1)
			ed = -1
		else:
			ed = max(ed, last[ord(s[i]) - 65])
	return ans

```
pass

s = "MPMPCPMCMDEFEGDEHINHKLIN"

解釋:
step1: 先遍歷s然後得到從A到Z在s出現的最後一個位置得到last.
last = [ _,_,_,10,13,12,14 ......... ]

step2: 將last的最後位置按照s的字元列出:
[8,9,9,9,9,9,9,9,9,16,13,12,13,14,16,16,17,24,22,22,23,24,24,24]

step3: 
在for loop中譬如到i=9的位置, 之前的數字都沒有大於9的, 則這一段為一個區間partition.



## **解法：雙指針**

### **核心思路**

1. **紀錄每個字母的最後出現位置**
    
    - 我們需要確保一個子字符串內所有字母不會出現在其他子字符串中。因此，應該知道每個字母最後出現的位置，以確定當前區間的邊界。
2. **雙指針遍歷字符串**
    
    - 設置 `st`（當前區段的起點）和 `ed`（當前區段的終點）。
    - 當 `i` 達到 `ed` 時，意味著該區段內的所有字母都不會在後面出現，可以確定一個子字符串的長度。

---

### **代碼解析**
```python
def split_String(self, s):
    n = len(s)
    st = ed = -1  # `st` 起始位置, `ed` 目前區間的最遠邊界
    last = [0 for _ in range(26)]  # 紀錄每個字母最後出現的位置
    ans = []

    # **步驟 1**：建立 `last` 陣列，存儲每個字母的最後出現位置
    for i in range(n):
        last[ord(s[i]) - 65] = i  # 65 是 'A' 的 ASCII 編碼
    
    # **步驟 2**：使用雙指針遍歷字符串並劃分區間
    for i in range(n):
        if ed == -1:  # 當前區間無效，啟動新的區段
            st = i
            ed = last[ord(s[i]) - 65]  # 設置 `ed` 為當前字母的最後出現位置
            if st == ed:  # 只有一個字母的區間，直接確定一個部分
                ans.append(1)
                ed = -1  # 重置 `ed` 開始下一個區段
        elif i == ed:  # 當 `i` 到達 `ed` 時，當前區段確定
            ans.append(ed - st + 1)
            ed = -1  # 重置 `ed` 開始下一個區段
        else:
            ed = max(ed, last[ord(s[i]) - 65])  # 更新 `ed`，擴展區段範圍

    return ans

```

---

## **逐步執行分析**

**輸入：** `"MPMPCPMCMDEFEGDEHINHKLIN"`

### **步驟 1：建立 `last` 陣列**

遍歷 `s`，存儲每個字母的最後出現位置：


```mathematica
last = [  _,  _,  _,  10,  13,  12,  14,  17,  20,  21,  23,  24,  8,  16,  9,  7,  5,  22,  6,  11,  _,  _,  _,  _,  _]
(A-Z)  B   C   D   E   F   G   H   I   K   L   M   N   O   P   Q   R   S   T   U   V   W   X   Y   Z

```
### **步驟 2：使用雙指針劃分區間**

|`i`|當前字母|`st`|`ed`|`ans`|
|---|---|---|---|---|
|0|M|0|8||
|1|P||9||
|2|M||9||
|3|P||9||
|4|C||9||
|5|P||9||
|6|M||9||
|7|C||9||
|8|M||9||
|9|D|9|16|`9` (確定區間)|
|10|E||13||
|11|F||12||
|12|E||13||
|13|G||14||
|14|D||16||
|15|E||16||
|16|H||17|`7` (確定區間)|
|17|I|17|24||
|18|N||22||
|19|H||22||
|20|K||23||
|21|L||24||
|22|I||24||
|23|N||24||
|24|(終止)|||`8` (確定區間)|

### **輸出結果**

`[9,7,8]`

---

## **時間與空間複雜度分析**

1. **時間複雜度：`O(n)`**
    
    - **第一步** 遍歷字符串建立 `last` 陣列，時間複雜度為 `O(n)`。
    - **第二步** 遍歷字符串進行區間劃分，時間複雜度為 `O(n)`。
    - 總時間複雜度為 `O(n)`。
2. **空間複雜度：`O(1)`**
    
    - `last` 陣列大小為 26（字母數），視為常數空間 `O(1)`。
    - `ans` 陣列的大小最多為 `O(n)`，但輸出部分劃分結果可忽略。

---

## **其他解法**

### **1. 暴力法（O(n^2)）**

- 遍歷每個字母，檢查當前區間內是否還有該字母的出現。
- 當所有字母的最後出現位置都小於當前 `i` 時，確定區間。
- **缺點**：時間複雜度 `O(n^2)`，效率低。

### **2. 使用 `OrderedDict` 儲存出現範圍**

- 用 `OrderedDict` 記錄字母的第一和最後出現位置。
- 遍歷 `OrderedDict` 按序檢查區間重疊並合併。
- **優點**：易讀性好。
- **缺點**：較慢，`O(n log n)`。

---

## **總結**

1. **最優解**：使用雙指針 `O(n)` 解法：
    
    - **第一步** 記錄每個字母的最後出現位置。
    - **第二步** 遍歷字符串，利用雙指針劃分區間。
    - **第三步** 當 `i == ed` 時，確定子字符串。
2. **為何雙指針適合這題？**
    
    - 可以快速擴展區間 `ed`，確保字母不重複出現在不同區間。
    - 只需要遍歷 `s` 一次即可確定分割位置，時間複雜度 `O(n)`。