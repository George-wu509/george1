Lintcode 610
给定一个排序后的整数数组，找到两个数的 `差` 等于目标值。  
你需要返回一个包含两个数字的列表 `[num1, num2]`, 使得 `num1` 与 `num2` 的差为 `target`，同时 `num1` 必须小于 `num2`。

例1:
```python
输入: nums = [2, 7, 15, 24], target = 5 
输出: [2, 7] 
解释:
(7 - 2 = 5)
```
例2:
```python
输入: nums = [1, 1], target = 0
输出: [1, 1] 
解释:
(1 - 1 = 0)
```


```python
    def two_Sum7(self, nums, target):
        n = len(nums)
        if target < 0:
            target = -target
        j = 0
        for i in range(n):
            if i == j:
                j += 1
            while j < n and nums[j] - nums[i] < target:
                j += 1
            if j < n and nums[j] - nums[i] == target:
                return [nums[i],nums[j]]
```
pass


# **LintCode 610: Two Sum - Difference Equals to Target（两数之差等于目标值）**

---

## **问题描述**

给定一个**递增排序**的整数数组 `nums`，以及一个**正整数 `target`**，找出数组中 **两个数 `(a, b)`，满足 `b - a = target`**，返回 `[a, b]`。

---

## **解法：双指针**

### **核心思路**

1. **使用双指针 `i` 和 `j`**
    
    - `i` 指向**较小的数**（左侧）。
    - `j` 指向**较大的数**（右侧）。
    - **目标：`nums[j] - nums[i] = target`**
2. **遍历数组，同时移动 `i` 和 `j`**
    
    - 如果 `nums[j] - nums[i] < target`，说明 `j` 还不够大，**右移 `j++`**。
    - 如果 `nums[j] - nums[i] > target`，说明 `j` 过大，或者 `i` 需要前进，**左移 `i++`**。
    - 如果 `nums[j] - nums[i] == target`，**找到答案**，返回 `[nums[i], nums[j]]`。

---

## **执行过程**

### **变量表**

|变量|说明|
|---|---|
|`nums`|递增排序的数组|
|`i`|左指针（较小数）|
|`j`|右指针（较大数）|
|`target`|目标差值|

---

### **Step 1: 处理负数 `target`**

- 如果 `target < 0`，转换为 **正数** `target = abs(target)`。
- **假设输入**

python

複製編輯

`nums = [1, 3, 5, 7, 10] target = 4`

---

### **Step 2: 使用双指针**

#### **初始状态**

|变量|值|
|---|---|
|`i`|0|
|`j`|1|
|`target`|4|

---

#### **第一轮：检查 `nums[1] - nums[0] = 3 - 1 = 2`**

- `2 < target (4)`，**不满足**。
- **右移 `j = 2`**。

---

#### **第二轮：检查 `nums[2] - nums[0] = 5 - 1 = 4`**

- `4 == target (4)`，**找到解 `[1, 5]`**。

---

### **最终结果**

python

複製編輯

`[1, 5]`

---

## **时间与空间复杂度分析**

### **时间复杂度**

|操作|复杂度|说明|
|---|---|---|
|**遍历 `nums`**|`O(n)`|`i` 和 `j` 最多各遍历 `n` 次|
|**总复杂度**|`O(n)`|线性时间复杂度|

### **空间复杂度**

- 仅使用常数额外空间，**`O(1)`**。

---

## **其他解法**

### **1. 哈希表（O(n)）**

- **思路**
    - 遍历 `nums`，存入 `set`。
    - 对于 `nums[i]`，查找 `nums[i] + target` 是否在 `set` 中。

---

### **2. 二分查找（O(n log n)）**

- **思路**
    - 对于 `nums[i]`，**用二分查找** 找 `nums[j] = nums[i] + target`。
    - **时间复杂度 `O(n log n)`**，适用于较大 `n`。

---

## **方法比较**

|方法|思路|时间复杂度|空间复杂度|适用情况|
|---|---|---|---|---|
|**双指针（当前解法）**|**左右指针寻找差值**|`O(n)`|`O(1)`|**适用于大规模数据**|
|**哈希表**|**存储已遍历值，查找 `nums[i] + target`**|`O(n)`|`O(n)`|**适用于查找操作多**|
|**二分查找**|**固定 `nums[i]`，二分查找 `nums[i] + target`**|`O(n log n)`|`O(1)`|**适用于已排序数组**|

---

## **总结**

- **最优解** ✅ **双指针 `O(n)`**
- **如果查找操作多，可用 `O(n)` 哈希表**
- **如果 `n` 适中，可用 `O(n log n)` 二分查找**

🚀 **"双指针" 是最优解，适用于大规模数据！**