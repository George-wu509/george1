
Lintcode 443
给一组整数，问能找出多少对整数，他们的和大于一个给定的目标值。请返回答案。

**样例 1:**
```python
输入: [2, 7, 11, 15], target = 24
输出: 1
解释: 11 + 15 是唯一的一对
```
**样例 2:**
```python
输入: [1, 1, 1, 1], target = 1
输出: 6
```

```python
    def two_sum2(self, nums, target):
        n = len(nums)
        if n < 2:
            return 0
        
        nums.sort()
        
        res = 0
        l, r = 0, n - 1
        while l < r:
            if nums[l] + nums[r] <= target:
                l += 1
            else:
                res += r - l
                r -= 1
                
        return res
```
pass

# **LintCode 443: Two Sum - Greater than Target（两数之和大于目标值的对数）**

---

## **问题描述**

给定一个整数数组 `nums` 和一个整数 `target`，找到数组中 **所有满足 `nums[i] + nums[j] > target` 的数对 `(i, j)`**，返回**这样的数对数量**。

---

## **解法：双指针**

### **核心思路**

1. **先对数组进行排序**
    
    - 这样可以 **保证 `nums[l]` 最小，`nums[r]` 最大**，从而方便使用 **双指针遍历**。
2. **双指针 `l` 和 `r` 分别指向数组首尾**
    
    - **如果 `nums[l] + nums[r] ≤ target`**：
        - 说明 `nums[l]` 太小了，**左指针右移 `l += 1`**，尝试更大的数。
    - **如果 `nums[l] + nums[r] > target`**：
        - 说明 **`nums[r]` 可以和 `[l, r-1]` 之间的所有数匹配**，即 **有 `r - l` 组数对**。
        - 计算 `res += r - l`。
        - **右指针左移 `r -= 1`**，继续检查下一组匹配。

---

## **执行过程**

### **变量表**

|变量|说明|
|---|---|
|`nums`|经过排序的数组|
|`l`|左指针（最小值）|
|`r`|右指针（最大值）|
|`res`|统计满足条件的数对数目|

---

### **Step 1: 先排序**

假设输入：

python

複製編輯

`nums = [2, 7, 5, 3, 8] target = 10`

排序后：

ini

複製編輯

`nums = [2, 3, 5, 7, 8]`

---

### **Step 2: 使用双指针**

#### **初始状态**

|变量|值|
|---|---|
|`l`|0|
|`r`|4|
|`res`|0|

---

#### **第一轮：检查 `nums[0] + nums[4] = 2 + 8 = 10`**

- `10 ≤ target (10)`，**不符合条件**。
- 右移 `l = 1`。

---

#### **第二轮：检查 `nums[1] + nums[4] = 3 + 8 = 11`**

- `11 > target (10)`，**符合条件**。
- **`r=4` 可以和 `[1, 2, 3]` 匹配（3 组数对）**，`res += 3`。
- 左移 `r = 3`。

---

#### **第三轮：检查 `nums[1] + nums[3] = 3 + 7 = 10`**

- `10 ≤ target (10)`，**不符合条件**。
- 右移 `l = 2`。

---

#### **第四轮：检查 `nums[2] + nums[3] = 5 + 7 = 12`**

- `12 > target (10)`，**符合条件**。
- **`r=3` 可以和 `[2]` 匹配（1 组数对）**，`res += 1`。
- 左移 `r = 2`，循环结束。

---

### **最终结果**

ini

複製編輯

`res = 3 + 1 = 4`

返回 `4`，即 `4` 组满足条件的数对。

---

## **时间与空间复杂度分析**

### **时间复杂度**

|操作|复杂度|说明|
|---|---|---|
|**排序 `nums`**|`O(n log n)`|需要排序数组|
|**双指针查找**|`O(n)`|每个元素最多访问一次|
|**总复杂度**|`O(n log n)`|由于排序占主导，最终复杂度 `O(n log n)`|

### **空间复杂度**

- 仅使用常数额外空间，**`O(1)`**。

---

## **其他解法**

### **1. 暴力法（O(n²)）**

- **思路**
    - 直接遍历所有 `i, j` 组合，检查 `nums[i] + nums[j] > target`。
- **时间复杂度**
    - **`O(n²)`**，适用于小数据集。

### **2. 二分查找（O(n log n)）**

- **思路**
    - 固定 `nums[i]`，用 **二分查找** 找出 `j` 使得 `nums[i] + nums[j] > target`。
- **时间复杂度**
    - `O(n log n)`（排序） + `O(n log n)`（二分查找） = **`O(n log n)`**。

---

## **方法比较**

|方法|思路|时间复杂度|空间复杂度|适用情况|
|---|---|---|---|---|
|**双指针（当前解法）**|**排序 + 左右指针**|`O(n log n)`|`O(1)`|**适用于大规模数据**|
|**暴力法**|**两层循环遍历**|`O(n²)`|`O(1)`|**适用于小数据集**|
|**二分查找**|**固定 `nums[i]`，用 `O(log n)` 二分查找 `j`**|`O(n log n)`|`O(1)`|**适用于 `n` 适中**|

---

## **总结**

- **最优解** ✅ **双指针 `O(n log n)`**
- **数据较小时可用 `O(n²)` 暴力法**
- **如果 `find()` 操作多，可用 `O(n log n)` 二分查找**

🚀 **"双指针 + 排序" 是最优解，适用于大规模数据！**