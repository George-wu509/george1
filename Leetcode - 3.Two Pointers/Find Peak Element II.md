390
给定一个整数矩阵 `A`, 它有如下特性:

- 相邻的整数不同
- 矩阵有 `n` 行 `m` 列，n和m不会小于3。
- 对于所有的 `i < n`, 都有 `A[i][0] < A[i][1] && A[i][m - 2] > A[i][m - 1]`
- 对于所有的 `j < m`, 都有 `A[0][j] < A[1][j] && A[n - 2][j] > A[n - 1][j]`

我们定义一个位置 `[i,j]` 是峰值, 当且仅当它满足
找到该矩阵的一个峰值元素, 返回它的坐标.

**样例 1:**
```python
输入: 
    [
      [1, 2, 3, 6,  5],
      [16,41,23,22, 6],
      [15,17,24,21, 7],
      [14,18,19,20,10],
      [13,14,11,10, 9]
    ]
输出: [1,1]
解释: [2,2] 也是可以的. [1,1] 的元素是 41, 大于它四周的每一个元素 (2, 16, 23, 17).
```
**样例 2:**
```python
输入: 
    [
      [1, 5, 3],
      [4,10, 9],
      [2, 8, 7]
    ]
输出: [1,1]
解释: 只有这一个峰值
```


```python
class Solution:
   
    def findPeakII(self, matrix) -> tuple:
        
        m, n, = len(matrix), len(matrix[0])
        
        lo, hi = 1, n-2
        while lo <= hi:
            mid = (lo+hi) // 2
            col_max, row_index = matrix[0][mid], 0
            for i in range(1, m-1):
                if matrix[i][mid] > col_max:
                    col_max = matrix[i][mid]
                    row_index = i 
            if matrix[row_index][mid] < matrix[row_index][mid-1]:
                hi = mid - 1
            elif matrix[row_index][mid] < matrix[row_index][mid+1]:
                lo = mid + 1
            else:
                return (row_index, mid)
```
pass


# **LintCode 390: Find Peak Element II（寻找二维峰值）**

---

## **问题描述**

给定一个 `m x n` 的二维矩阵 `matrix`，其中 **相邻元素不同**。找到 **一个峰值元素的位置 `(i, j)`**，

**注意**

- **边界不能作为峰值**（只考虑 `1 ≤ i ≤ m-2, 1 ≤ j ≤ n-2`）。
- **可能存在多个峰值，返回任意一个即可**。

---

## **解法：二分查找（Binary Search on Columns）**

### **核心思路**

1. **使用二分查找选取中间列 `mid`**
    
    - **二分范围** `lo=1, hi=n-2`（不考虑边界）。
    - 选取 **当前列 `mid = (lo + hi) // 2`** 作为参考列。
2. **找到该列 `mid` 中的最大元素**
    
    - 遍历 **所有行 `i`**，找到 **`col_max = matrix[row_index][mid]`**。
3. **判断 `col_max` 是否是峰值**
    
    - **如果 `matrix[row_index][mid]` 小于左侧 `matrix[row_index][mid-1]`，则峰值一定在左侧，向左二分**。
    - **如果 `matrix[row_index][mid]` 小于右侧 `matrix[row_index][mid+1]`，则峰值一定在右侧，向右二分**。
    - **否则，`matrix[row_index][mid]` 就是峰值，返回 `(row_index, mid)`**。

---

## **执行过程**

### **变量表**

|变量|说明|
|---|---|
|`m`|矩阵行数|
|`n`|矩阵列数|
|`lo`|二分查找左边界|
|`hi`|二分查找右边界|
|`mid`|当前查找的中间列|
|`col_max`|`mid` 列中最大值|
|`row_index`|`col_max` 所在的行索引|

---

### **Step 1: 初始化**

假设输入：

```python
"""
matrix = [
    [1,  2,  3,  6,  5],
    [16, 41, 23, 22, 6],
    [15, 17, 24, 21, 7],
    [14, 18, 19, 20, 10],
    [13, 14, 11, 10, 9]
]

```
初始化：

|变量|值|
|---|---|
|`m`|`5`|
|`n`|`5`|
|`lo`|`1`|
|`hi`|`3`|

---

### **Step 2: 选择 `mid = 2` 作为二分查找列**

|`i`|`matrix[i][2]`|
|---|---|
|`0`|`3`|
|`1`|`23`|
|`2`|`24` ✅（最大值）|
|`3`|`19`|
|`4`|`11`|

最大值 `col_max = 24` 在 `(2, 2)`。

---

### **Step 3: 判断 `col_max` 是否是峰值**

- **`matrix[2][2] = 24`**
- **左侧 `matrix[2][1] = 17`**
- **右侧 `matrix[2][3] = 21`**

24>17,24>2124 > 17, \quad 24 > 2124>17,24>21

`24` 是 **峰值**，返回 `(2, 2)`。

---

## **时间与空间复杂度分析**

### **时间复杂度**

|操作|复杂度|说明|
|---|---|---|
|**二分查找列**|`O(log n)`|每次二分范围缩小一半|
|**遍历列寻找最大值**|`O(m)`|遍历 `m` 行找到 `col_max`|
|**总复杂度**|`O(m log n)`|由于 `log n` 次二分，每次遍历 `m`|

### **空间复杂度**

- 仅使用常数额外空间，**`O(1)`**。

---

## **其他解法**

### **1. 暴力法（O(mn)）**

- **思路**
    - 遍历 `matrix` 的所有 `i, j`，找到所有符合 **峰值定义** 的点。
- **时间复杂度**
    - **`O(mn)`**，适用于 `n, m` 较小时。

### **2. 二分查找（Binary Search on Rows，O(n log m)）**

- **思路**
    - 先对 **行 `mid` 进行二分**，找到行 `mid` 的最大值 `row_max`。
    - 再判断 `row_max` 是否是峰值，否则继续二分。
- **时间复杂度**
    - **`O(n log m)`**，适用于 `m > n` 的情况。

---

## **方法比较**

|方法|思路|时间复杂度|空间复杂度|适用情况|
|---|---|---|---|---|
|**二分查找列（当前解法）**|**对列二分，寻找最大值**|`O(m log n)`|`O(1)`|**适用于 `m > n` 的矩阵**|
|**暴力法**|**遍历所有元素找峰值**|`O(mn)`|`O(1)`|**适用于小矩阵**|
|**二分查找行**|**对行二分，寻找最大值**|`O(n log m)`|`O(1)`|**适用于 `n > m` 的矩阵**|

---

## **总结**

- **最优解** ✅ **二分查找列 `O(m log n)`**
- **如果 `m > n`，使用 `O(m log n)` 二分查找列**
- **如果 `n > m`，使用 `O(n log m)` 二分查找行**
- **如果 `n, m` 较小，可用 `O(mn)` 暴力解法**

🚀 **"二分查找列" 是最优解，适用于大规模数据！**