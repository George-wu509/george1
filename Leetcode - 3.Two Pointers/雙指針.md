
**Knowledge**

1. 三種雙指針算法: A 相向雙指針(判斷回文串),  時間複雜度:  O(N)


B 背向雙指針(最長回文串)

C 同向雙指針

2. A相向雙指針的分類:  Reverse型(題目不多)

- 翻轉字符串

- 判斷回文串

TwoSum型

-  兩數之和

-  三數之和

Partition型

-  快速排序

-  顏色排序

3. B 背向雙指針的分類:  中心線枚舉算法

Find K closest elements

4. C 同向雙指針的分類:  滑動窗口類 Sliding window

快慢指針類 Fasr & Slow pointers

## **Lintcode模板 - 双指针 Two Pointers**

## **使用条件**

- 滑动窗口（90%）
- 时间复杂度要求 O(n)_O_(_n_) （80%是双指针）
- 要求原地操作，只可以使用交换，不能使用额外空间（80%）
- 有子数组 `subarray` / 子字符串 `substring` 的关键词（50%）
- 有回文 `Palindrome` 关键词（50%）

## **复杂度**

- 时间复杂度：_O_(_n_)
    - 时间复杂度与最内层循环主体的执行次数有关
    - 与有多少重循环无关
- 空间复杂度：_O_(1)
    - 只需要分配两个指针的额外内存

**代码模板**
![[Pasted image 20240914164330.png]]![[Pasted image 20240914164359.png]]

![[summary.jpg]]
Sorting
1. 經典的雙指針, 兩個指針可以重合. 用While left <= right


Binary Search
1. 從左右慢慢逼近到接近target的兩個相鄰數然後stop, 所以使用While start+1 <=end


Two Sum
1. 從左右開始用兩個指針搜尋兩個數字的和, 所以不能重合. 用While left < right




| **题目编号**             | **题目名称 (英文/中文)**                                                            | **题目简述 (中文)**                                       | **样例**                                                                                                                             | **解法**                                     |
| -------------------- | --------------------------------------------------------------------------- | --------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------ |
| 607<br>*<br>(e)      | 两数之和 III [[Two Sum III]]                                                    | 实现一个数据结构支持插入数字和查询是否存在两个数字和等于目标值。                    | 输入:  <br>add(1), add(3), add(5), find(4), find(7)  <br>输出: true, false<br><br>O(n),O(n)                                            | 使用哈希表存储数字及其出现次数，遍历检查目标差值是否存在。              |
| 56<br>**<br>(e)      | [[Two Sum]]两数之和                                                             | 在数组中找到两个数，使得它们的和等于目标值，返回它们的下标。                      | 输入: numbers = [2, 7, 11, 15], target = 9 输出: [0, 1]<br><br>O(nlogn),O(n)                                                           | 先排序然後用雙指針從左右往中間, 和target比較決定往右往左           |
| 609<br>*<br>(m)      | 两数和 - 小于或等于目标值 [[Two Sum - Less than or equal to target]]                   | 找出数组中所有和小于或等于目标值的两数组合个数。                            | 输入:  <br>nums = [2,7,11,15], target = 24  <br>输出: 5<br>O(nlogn),O(1)                                                               | 先排序数组，使用双指针计算符合条件的组合个数。                    |
| 443<br>*<br>(m)      | 两数之和 II [[Two Sum - Greater than target]]                                   | 找出数组中所有和大于目标值的两数组合个数。                               | 输入:  <br>nums = [2,7,11,15], target = 10  <br>输出: 4<br>O(nlogn),O(1)                                                               | 先排序数组，使用双指针计算符合条件的组合个数。                    |
| 610<br>*<br>(m)      | 两数和 - 差等于目标值 [[Two Sum - Difference equals to target]]                      | 找到数组中两个数，其差等于目标值，返回它们的索引。                           | 输入:  <br>nums = [2,7,11,15], target = 5  <br>输出: [0,1]<br>O(n),O(1)                                                                | 使用哈希表记录遍历过的数字，查找是否存在与当前数的差等于目标值的数。         |
| 57<br>**<br>(m)      | 三数之和 [[3Sum]]                                                               | 找到数组中所有和为零的三元组，结果不能包含重复的三元组。                        | 输入:  <br>nums = [-1,0,1,2,-1,-4]  <br>输出: [ [-1,-1,2], [-1,0,1] ]<br>O(n^2),O(1)                                                   | 先排序数组，再固定一个数字，使用双指针寻找剩余两个数字的组合。            |
| 58<br>**<br>(m)      | 四数之和  [[4Sum]]                                                              | 给一个包含n个数的整数数组S，在S中找到所有使得和为给定整数target四元组(a, b, c, d) | 输入:  <br>numbers = [2,7,11,15], target=3<br>输出: []<br>O(n^3),O(1)                                                                  | 固定两个点，然后用双指针的做法，扫描一下后续数组，记录答案即可。           |
| 976<br>*<br>(m)      | 四数之和 II [[4Sum II]]                                                         | 找出数组中所有和为目标值的四元组，结果不能包含重复的四元组。                      | 输入:  <br>nums = [1,0,-1,0,-2,2], target = 0  <br>输出: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]<br>O(n^2),O(n^2)                          | 先排序数组，固定两个数字，使用双指针查找剩余两个数字的组合。             |
| 689<br>*<br>(m)      | [[Two Sum IV]] - Input is a BST两数之和 - BST版本                                 | 在二叉搜索树中找到两个节点，使它们的和等于目标值。                           | 输入:  <br>root = [5,3,6,2,4,null,7]  <br>target = 9  <br>输出:  <br>true<br>O(n),O(n)                                                 | 使用中序遍历获取节点值并查找目标值，或使用哈希表记录访问的节点值。          |
| 89<br>*<br>(h)<br>!! | K数之和 [[KSum]]                                                               | 找出数组中和等于目标值的 k 个数的组合。                               | 输入:  <br>nums = [1,0,-1,0,-2,2], target = 0, k = 4  <br>输出: [ [-2,-1,1,2],[-2,0,0,2],[-1,0,0,1] ]<br><br>O(n×k×target),O(k×target) | 用DP遍歷不同方案                                  |
| 90<br>*<br>(m)       | K数之和 II [[k Sum II]]                                                        | 找出数组中和等于目标值的 k 个数的所有组合，每个数只能使用一次。                   | 输入:  <br>nums = [10,1,2,7,6,1,5], target = 8, k = 2  <br>输出: [ [1,7],[2,6] ]<br><br>O(2^n),O(k)                                    | 使用DFS遞歸遍歷所有可能的子集，過程中剪枝以提高效率                |
|                      | **滑動窗口**                                                                    |                                                     |                                                                                                                                    |                                            |
| 604<br>*<br>(e)      | 滑动窗口内数的和 [[Window Sum]]                                                     | 给定一个数组和窗口大小 k，返回每个窗口的元素和。                           | 输入:  <br>nums = [1,2,3,4,5], k = 3  <br>输出: [6,9,12]                                                                               | 使用双指针滑动窗口计算每个窗口的和，避免重复计算。                  |
| 32<br>**<br>(m)      | 最小子串覆盖 [[Minimum Window Substring]]                                         | 找到字符串中包含目标字符的最小子串。                                  | 输入:  <br>s = "adobecodebanc", t = "abc"  <br>输出: "banc"                                                                            | 使用滑动窗口（双指针）维护窗口的字符计数，动态更新最小子串。             |
| 1246<br>**<br>(m)    | 替换后的最长重复字符 [[Longest Repeating Character Replacement]]                      | 给定一个字符串和一个数字 k，找到替换 k 个字符后最长的重复子串长度。                | 输入:  <br>s = "AABABBA", k = 1  <br>输出: 4                                                                                           | 使用滑动窗口记录窗口内的字符频率，动态调整窗口大小并计算最大长度。          |
| 386<br>*<br>(m)      | 最多有 k 个不同字符的最长子字符串 [[Longest Substring with At Most K Distinct Characters]] | 找出字符串中包含最多 k 个不同字符的最长子串长度。                          | 输入:  <br>s = "eceba", k = 2  <br>输出: 3                                                                                             | 使用滑动窗口记录窗口内的字符频率，动态调整窗口大小并计算最大长度。          |
| 1375<br>*<br>(m)     | 至少 K 个不同字符的子串 [[Substring With At Least K Distinct Characters]]             | 找到字符串中包含至少 K 个不同字符的子串的数量。                           | 输入:  <br>s = "abcabc", k = 2  <br>输出: 10                                                                                           | 使用滑动窗口维护窗口内的字符计数，动态更新子串数量。                 |
| 328<br>*<br>(m)      | 字符串划分 [[String Partition]]                                                  | 将字符串分割为多个部分，使得每个部分只包含一种字符。                          | 输入:  <br>s = "abacbc"  <br>输出: ["aba","cbc"]<br>O(n),O(1)                                                                          | 使用双指针记录当前字符范围，找到每段分割点，动态更新结果。              |
| 1849<br>*<br>(m)     | 爱生气的书店老板 [[Grumpy Bookstore Owner]]                                         | 给定书店顾客满意度和老板是否生气的记录，找到可以让最多顾客满意的时间段。                | 输入:  <br>customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3  <br>输出: 16<br>O(n),O(n)                                 | 使用滑动窗口记录满意度的变化量，动态调整窗口大小，计算最大满意度。          |
| 1643<br>*<br>(m)     | 摘水果 [[Pick Fruits]]                                                         | 找到连续摘取两种水果的最大数量。                                    | 输入:  <br>fruits = [1,2,1,2,3,2,1]  <br>输出: 4                                                                                       | 使用滑动窗口记录当前水果种类和数量，动态调整窗口范围，找到最大长度。         |
|                      |                                                                             |                                                     |                                                                                                                                    |                                            |
|                      | **分割數組**                                                                    |                                                     |                                                                                                                                    |                                            |
| 539<br>**<br>(e)     | 移动零 [[Move Zeroes]]                                                         | 将数组中的所有零移动到末尾，同时保持非零元素的相对顺序。                        | 输入:  <br>nums = [0,1,0,3,12]  <br>输出: [1,3,12,0,0]                                                                                 | 使用双指针，一个指针遍历数组，另一个指针指向下一个非零元素的位置。          |
| 31<br>**<br>(m)      | 分割数组 [[Partition Array]]                                                    | 给定一个数组和目标值，将数组分割成两部分，使得左边的所有数小于目标值，右边的所有数大于等于目标值。   | 输入:  <br>nums = [3,2,2,1], target = 2  <br>输出: [1,2,2,3]                                                                           | 使用双指针，从两端向中间移动，将小于目标值的数移到左边，大于等于目标值的数移到右边。 |
| 373<br>*<br>(e)      | 奇偶分割数组 [[Partition Array by Odd and Even]]                                  | 将数组分割为奇数在前，偶数在后，同时保持它们的相对顺序。                        | 输入:  <br>nums = [1,4,2,3,5,6]  <br>输出: [1,3,5,4,2,6]                                                                               | 使用双指针，从两端向中间移动，将奇数和偶数交换位置。                 |
| 49<br>*<br>(e)       | 字符大小写排序 [[Sort Letters by Case]]                                            | 给定一个字符串，将其中的小写字母排在前面，大写字母排在后面。                      | 输入:  <br>s = "abCDeF"  <br>输出: "abeCDF"                                                                                            | 使用双指针从两端向中间移动, 分别找到未排小写字母和大写字母，交换位置，保持顺序。  |
|                      |                                                                             |                                                     |                                                                                                                                    |                                            |
| 64<br>*<br>(e)       | 合并排序数组（简单版） [[Merge Sorted Array (easy version)]]                           | 将两个已排序数组合并为一个排序数组。                                  | 输入<br>A = [1,2,3], m = 3<br>B = [4,5], n = 2<br>输出:<br>[1,2,3,4,5]                                                                 | 从两个数组的末尾开始比较，将较大元素依次插入 nums1 的后半部分。        |
| 6<br>*<br>(e)        | 合并排序数组 [[Merge Two Sorted Arrays]]                                          | 将两个已排序数组合并为一个排序数组。                                  | 输入<br>A = [1,2,3,4]<br>B = [2,4,5,6]<br>输出:<br>[1,2,2,3,4,4,5,6]                                                                   | 从两个数组的末尾开始比较，将较大元素依次插入 nums1 的后半部分。        |
|                      | Others                                                                      |                                                     |                                                                                                                                    |                                            |
| 1219<br>*<br>(m)     | 加热器 [[Heaters]]                                                             | 给定房屋和加热器的位置，找到每个房屋需要的最小加热半径，使所有房屋都能被覆盖。             | 输入:  <br>houses = [1,2,3,4], heaters = [1,4]  <br>输出: 1                                                                            | 对房屋和加热器排序，使用双指针找到每个房屋的最近加热器，计算最大半径。        |
| 382<br>*<br>(m)      | 三角形计数 [[Triangle Count]]                                                    | 找出数组中满足三角形条件的三元组个数。                                 | 输入:  <br>nums = [4,2,3,4]  <br>输出: 4                                                                                               | 先排序数组，固定一边长，使用双指针查找满足条件的三元组。               |
| 200<br>**<br>(m)     | 最长回文子串 [[Longest Palindromic Substring]]                                    | 找到字符串中的最长回文子串。                                      | 输入:  <br>s = "babad"  <br>输出: "bab" 或 "aba"                                                                                        | 使用双指针扩展中心，判断两侧字符是否相等，更新最长回文子串。             |
| 1870<br>*<br>(m)     | 全零子串的数量 [[Number of Substrings with All Zeroes]]                            | 找出字符串中只包含 0 的子串数量。                                  | 输入:"00010011"<br>输出:9                                                                                                              | 使用双指针统计连续 0 的长度，计算包含的所有子串数量。               |
| 521<br>*<br>(e)      | 去除重复元素 [[Remove Duplicate Numbers in Array]]                                | 从数组中去除所有重复元素，返回剩余的数组长度。                             | 输入:  <br>nums = [1,1,2,2,3]  <br>输出: 3                                                                                             | 使用双指针遍历数组，将未重复的元素移到数组前部。                   |
| 390<br>*<br>(h)      | 寻找峰值 II [[Find Peak Element II]]                                            | 找到二维数组中的一个峰值位置，峰值是指元素大于其上下左右的邻居值。                   | 输入: <br>    [<br>      [1, 5, 3],<br>      [4,10, 9],<br>      [2, 8, 7]<br>    ]<br>输出: [1,1]<br>解释: 只有这一个峰值                      | 使用双指针逐步缩小矩阵范围，找到峰值位置。                      |






