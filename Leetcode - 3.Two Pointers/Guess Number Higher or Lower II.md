
我们正在玩猜数游戏, 游戏内容如下:  
我在 1到 n 的范围内选择一个数作为待猜的数, 你需要来猜这个数。  
每次你猜错的时候, 我会告诉你我选择的这个数是比你说的数要高还是低。  
但是, 当你猜这个数为 x 并且猜错的时候你需要支付 $x. 当你猜到我选择的数时, 你将赢得这场游戏。  
给一个具体的大于等于 1 的数 n, 计算你需要多少钱才可以保证赢。

**样例1**
```python
输入： 10
输出： 16
解释：
给出 n = 10, 我选择的数为 2
第一轮: 你猜测为 7, 我告诉你待猜的值要更小一些. 你需要支付 $7
第二轮: 你猜测为 3, 我告诉你待猜的值要更小一些. 你需要支付 $3
第三轮: 你猜测为 1, 我告诉你待猜的值要更大一些. 你需要支付 $1
游戏结束. 2 是我选择的待猜数. 
你最终需要支付 $7 + $3 + $1 = $11

给出 n = 10, 我选择的数为 4
第一轮: 你猜测为 7, 我告诉你待猜的值要更小一些. 你需要支付 $7
第二轮: 你猜测为 3, 我告诉你待猜的值要更大一些. 你需要支付 $3
第三轮: 你猜测为 5, 我告诉你待猜的值要更小一些. 你需要支付 $5
游戏结束. 4 是我选择的待猜数. 
你最终需要支付 $7 + $3 + $5 = $15

给出 n = 10, 我选择的数为 8
第一轮: 你猜测为 7, 我告诉你待猜的值要更大一些. 你需要支付 $7
第二轮: 你猜测为 9, 我告诉你待猜的值要更小一些. 你需要支付 $9
游戏结束. 8 是我选择的待猜数. 
你最终需要支付 $7 + $9 = $16

所以对于 n = 10, 答案为 16.
```
**样例2**
```python
输入： 5
输出： 6
```


```python
class Solution:
    def get_money_amount(self, n: int) -> int:
        dp = [[0 for _ in range(n + 1)] for __ in range(n + 1)]
        for len in range(2, n + 1):
            for start in range(1, n - len + 2):
                import sys
                temp = sys.maxsize
                for k in range(start + (len - 1) // 2, start + len - 1):
                    left, right = dp[start][k - 1], dp[k + 1][start + len - 1]
                    temp = min(k + max(left, right), temp)
                    if left > right:
                        break
                dp[start][start + len - 1] = temp

        return dp[1][n]
```
pass

设dp[i][j]表示从区间[i,j]中猜中待猜数所需要的最小花费。  
dp[i][j]=min{k+max(dp[i][k−1],dp[k+1][j])∣∣i≤k≤j}dp[i][j]=min{k+max(dp[i][k−1],dp[k+1][j])∣∣i≤k≤j}


### **问题描述**

题目编号 666 (猜数游戏 II) 是一个动态规划问题：玩家要在 1 到 n 的数字范围内猜一个数字，目标是找到一个最小的代价，使得无论选择哪个数字，都能保证找到目标数字。

- 猜某个数字 k 的代价是 k。
- 玩家要通过选择数字 k 来将问题分成两部分：左边的范围 [start, k−1]和右边的范围 [ k+1, end ]，并选择更大的子问题代价作为当前代价。
- 求在最坏情况下找到目标数字的最小代价。

---

### **代码详细步骤解析**

#### 初始化动态规划表
```python
dp = [[0 for _ in range(n + 1)] for __ in range(n + 1)]
```
- 创建一个二维数组 `dp`，其中 `dp[start][end]` 表示在数字范围 $[start, end]$中猜中数字的最小代价。
- 边界条件：
    - 如果范围只有一个数字（即 start=end），则不需要猜数字，因此代价为 0，即 $dp[start][end]=0$  

---

#### 动态规划递推公式

外层循环：
```python
for len in range(2, n + 1):
```
- `len` 表示当前子问题的区间长度，从长度为 2 开始（因为长度为 1 的区间代价为 0）。

内层循环：
```python
for start in range(1, n - len + 2):
```
- `start` 表示当前区间的起点，范围是从 1 到 n−len+1n - len + 1n−len+1。

核心计算逻辑：
```python
temp = sys.maxsize
for k in range(start + (len - 1) // 2, start + len - 1):
    left, right = dp[start][k - 1], dp[k + 1][start + len - 1]
    temp = min(k + max(left, right), temp)
    if left > right:
        break
dp[start][start + len - 1] = temp
```

- 对于区间 $[start, start+len-1]$，尝试每个数字 k 作为猜测点。
- 计算猜测代价：
    - 如果猜测点为 k，左区间代价为 $dp[start][k-1]$，右区间代价为 $dp[k+1][start+len-1]$。
    - 代价为 k+max⁡(左区间代价,右区间代价)，表示最坏情况下的代价。
- 为了加速收敛，当左区间代价 dp[start][k−1]dp[start][k-1]dp[start][k−1] 大于右区间代价 dp[k+1][start+len−1]dp[k+1][start+len-1]dp[k+1][start+len−1] 时，提前停止循环。

---

#### 返回结果

`return dp[1][n]`

- 最终结果存储在 dp[1][n]dp[1][n]dp[1][n]，表示在整个区间 [1,n][1, n][1,n] 内猜中数字的最小代价。

---

### **运行实例**

假设 n=5n = 5n=5，以下是逐步计算过程：

#### 初始化

创建一个 6x6 的二维数组 dpdpdp，所有元素初始化为 0。

#### 计算区间长度为 2 的情况

- len=2len = 2len=2
    - start=1start = 1start=1，范围为 [1,2][1, 2][1,2]，猜测点为 1：
        - 左区间为空（代价为 0），右区间代价为 dp[2][2]=0dp[2][2] = 0dp[2][2]=0。
        - 总代价为 1+max⁡(0,0)=11 + \max(0, 0) = 11+max(0,0)=1。
        - dp[1][2]=1dp[1][2] = 1dp[1][2]=1。
    - start=2start = 2start=2，范围为 [2,3][2, 3][2,3]，猜测点为 2：
        - 类似计算，dp[2][3]=2dp[2][3] = 2dp[2][3]=2。
    - 依此类推，完成所有长度为 2 的区间。

#### 计算区间长度为 3 的情况

- len=3len = 3len=3
    - start=1start = 1start=1，范围为 [1,3][1, 3][1,3]，尝试猜测点：
        - k=2k = 2k=2：代价为 2+max⁡(dp[1][1],dp[3][3])=2+1=32 + \max(dp[1][1], dp[3][3]) = 2 + 1 = 32+max(dp[1][1],dp[3][3])=2+1=3。
        - 更新 dp[1][3]=3dp[1][3] = 3dp[1][3]=3。
    - 类似计算完成其他区间。

---

### **时间复杂度分析**

1. 外层循环（区间长度）：O(n)O(n)O(n)。
2. 内层循环（起点）：O(n)O(n)O(n)。
3. 每个区间尝试猜测点：O(n)O(n)O(n)。

综合时间复杂度：O(n3)O(n^3)O(n3)。

---

### **其他解法**

1. **递归 + 记忆化搜索**：
    
    - 使用递归函数求解子问题，同时使用缓存避免重复计算。
    - 时间复杂度：与动态规划类似，O(n3)O(n^3)O(n3)。
2. **优化动态规划**：
    
    - 使用二分法选择猜测点，减少猜测范围。
    - 时间复杂度可以优化到 O(n2log⁡n)O(n^2 \log n)O(n2logn)。