
给定一个整数数组，在该数组中，寻找三个数，分别代表三角形三条边的长度，问，可以寻找到多少组这样的三个数来组成三角形？
```python
输入: [3, 4, 6, 7]
输出: 3
解释:
可以组成的是 (3, 4, 6), 
           (3, 6, 7),
           (4, 6, 7)
```

```python
输入: [4, 4, 4, 4]
输出: 4
解释:
任何三个数都可以构成三角形
所以答案为 C(3, 4) = 4
```



```python
    def triangleCount(self, S):
        S.sort()
        
        ans = 0
        for i in range(len(S)):
            left, right = 0, i - 1
            while left < right:
                if S[left] + S[right] > S[i]:
                    ans += right - left
                    right -= 1
                else:
                    left += 1
        return ans

```
pass

解釋:
Step1: 先排序s = [3,4,6,7], 再從左到右3->4->6->7.是三角形的最長邊. 譬如是7, 剩下的部分則用雙指針, Left = 3, Right = 6. 如果可以符合3+6>7則加入答案. 接著Right往左移(sum 減小) . 如果加起來沒有超過最大邊則是Left往右移(sum 增大) 



以下是用雙指針方法求解 LintCode 382「三角形计数」的詳細中文解釋，包括解法思路、逐步操作、具體例子、時間與空間複雜度分析，以及其他解法簡述。

---

### **問題描述**

給定一個包含非負整數的數組 `S`，返回該數組中可以組成三角形的三元組 `(i, j, k)` 的數量，使得： S[i]+S[j]>S[k]S[i] + S[j] > S[k]S[i]+S[j]>S[k] 並且 `i < j < k`。

---

### **雙指針解法：逐步解釋**

#### **1. 解法思路**

1. **三角形的性質**：
    
    - 三邊長滿足三角形條件時，必須滿足 **兩邊之和大於第三邊**。
    - 如果已經將數組排序，那麼只需檢查最大的邊（如 `S[k]`），看是否滿足 `S[i] + S[j] > S[k]`。
2. **排序與雙指針**：
    
    - 將數組 `S` 升序排序，確保 `S[i] ≤ S[j] ≤ S[k]`。
    - 固定第三條邊（`S[i]` 為最大邊），然後使用雙指針檢查前兩條邊是否能組成三角形：
        - **左指針 `left`**：指向最小的邊。
        - **右指針 `right`**：指向第二大的邊。
3. **檢查條件**：
    
    - 如果 `S[left] + S[right] > S[i]`：
        - 說明從 `left` 到 `right` 的所有組合都滿足條件，因為數組已排序。
        - 將符合條件的三元組數量增加 `right - left`，並將右指針向左移動以嘗試更短的第二邊。
    - 否則，移動左指針以增加邊的長度，看看是否滿足條件。
4. **返回結果**：
    
    - 對每個可能的最大邊進行上述過程，最終累計所有三元組的數量。

---

#### **2. 代碼分解與步驟詳解**

```python
def triangleCount(self, S):
    # 1. 排序數組
    S.sort()
    
    # 2. 初始化答案
    ans = 0
    
    # 3. 遍歷每個可能的最大邊
    for i in range(len(S)):
        # 左右指針初始化
        left, right = 0, i - 1  # 左指針最小，右指針次大
        
        # 4. 使用雙指針檢查是否滿足條件
        while left < right:
            # 如果前兩邊之和大於最大邊
            if S[left] + S[right] > S[i]:
                # 增加符合條件的三元組數量
                ans += right - left
                # 減小右指針以嘗試更短的第二邊
                right -= 1
            else:
                # 增加左指針以嘗試更長的第一邊
                left += 1
    
    # 5. 返回累計的三元組數量
    return ans

```
---

#### **3. 例子分析**

##### 輸入：

`S = [2, 2, 3, 4]`

##### 運行過程：

1. **排序數組**：
    
    - 排序後 `S = [2, 2, 3, 4]`。
2. **遍歷每個最大邊 `S[i]`**：
    
    - **`i = 0`**（`S[i] = 2`）：
        - 沒有可用的前兩條邊，跳過。
    - **`i = 1`**（`S[i] = 2`）：
        - 同樣沒有可用的前兩條邊，跳過。
    - **`i = 2`**（`S[i] = 3`）：
        - 初始化 `left = 0, right = 1`：
            - `S[left] + S[right] = 2 + 2 = 4 > 3`，符合條件。
                - 增加 `ans += right - left = 1`，`ans = 1`。
            - 移動 `right -= 1`，退出循環。
    - **`i = 3`**（`S[i] = 4`）：
        - 初始化 `left = 0, right = 2`：
            - `S[left] + S[right] = 2 + 3 = 5 > 4`，符合條件。
                - 增加 `ans += right - left = 2`，`ans = 3`。
            - 移動 `right -= 1`，`right = 1`：
                - `S[left] + S[right] = 2 + 2 = 4 > 4` 不成立。
                - 移動 `left += 1`，退出循環。

##### 結果：

`ans = 3`（三元組為 `[2, 3, 4]`、`[2, 2, 3]`、`[2, 2, 4]`）。

---

#### **4. 時間與空間複雜度分析**

1. **時間複雜度**：
    
    - 排序步驟：`O(n log n)`。
    - 遍歷每個 `i`（可能的最大邊）：`O(n)`。
    - 對於每個 `i`，雙指針操作最多需要 `O(n)`。
    - 總時間複雜度為 **`O(n^2)`**。
2. **空間複雜度**：
    
    - 排序操作為原地進行，雙指針只使用常數額外空間。
    - 總空間複雜度為 **`O(1)`**。

---

### **其他解法簡述**

1. **暴力法**：
    
    - 枚舉所有三元組 `(i, j, k)`，檢查是否滿足 `S[i] + S[j] > S[k]`。
    - 時間複雜度：`O(n^3)`，非常低效，不適合大數據。
2. **數學推導法**：
    
    - 在數組排序的基礎上，使用數學不等式縮減範圍。
    - 雖然可以進一步優化，但實現復雜度較高，且多數情況下與雙指針法相近。

---

### **總結**

- **雙指針法**：
    - 高效且易於實現，適合處理這類三角形計數問題。
- **暴力法**：
    - 易於理解，但不適合大數據規模。