1849
有一个书店，在接下来的n天中的第i天会有customer[i]个顾客到来，并且在这一天结束后离开。但是书店老板的脾气时好时坏，我们用一个数组grumpy表示他每一天的脾气好坏，若grumpy[i]=1, 则表示第i天老板的脾气很不好；若grumpy[i]=0, 则表示第i天老板的脾气很好。

若某一天书店老板的脾气不好，则会导致所有当天来的所有顾客会给书店差评。但如果某一天脾气好，那么当天所有顾客都会给书店好评。老板想要尽量增加给书店好评的人数数量，想了一个方法。他可以保持连续XX天的好脾气。但这个方法只能使用一次。

那么在这n天这个书店最多能有多少人离开时给书店好评？

**样例 1:**
```python
"""
输入:
customer = [1,0,1,2,1,1,7,5]
grumpy   = [0,1,0,1,0,1,0,1]
x = 3
输出: 
16
解释: 
书店老板在最后3天保持好脾气。
感到满意的最大客户数量 = 1 + 1 + 1 + 1 + 7 + 5 = 16.
```


```python
    def max_satisfied(customers, grumpy, x):
        n = len(customers)
        not_satisfied = customers[:]
        ans = 0
        for i in range(n):
            not_satisfied[i] = customers[i] * grumpy[i]
            ans += customers[i] * (1 - grumpy[i])
        now_sum = 0
        left = 0
        right = x - 1
                
        for i in range(right + 1):
            now_sum += not_satisfied[i]
        
        maximum = now_sum
        
        while right + 1 < n:
            now_sum -= not_satisfied[left]
            left += 1 
            right += 1
            now_sum += not_satisfied[right]
            
            
            maximum = max(maximum, now_sum)
        
        ans += maximum
        return ans
```
pass


# **LintCode 1849: Grumpy Bookstore Owner（书店老板的顾客满意度）**

---

## **问题描述**

一个书店的老板有 `n` 天的销售数据：

- `customers[i]` 代表 **第 `i` 天的顾客数量**。
- `grumpy[i] == 1` 代表 **老板当天生气，会赶走所有顾客**，`grumpy[i] == 0` 代表 **老板当天不生气**。
- 书店老板有一个**连续 `X` 天的冷静技巧**，可以让这 `X` 天内的顾客不受影响。

**目标**：计算 **最多能让多少顾客满意**。

---

## **解法：滑动窗口**

### **核心思路**

1. **计算所有本来就满意的顾客**
    
    - **当 `grumpy[i] == 0`，说明顾客本来就能买书**，将他们的数量直接累加到 `ans`。
2. **计算 `grumpy[i] == 1` 的损失**
    
    - **记录 `grumpy[i] == 1` 时的顾客数量 `not_satisfied[i]`**，代表因老板生气而流失的顾客数。
3. **使用滑动窗口找到 `X` 天内最大可挽回的顾客**
    
    - **滑动窗口窗口大小为 `X`**，计算 `X` 天能恢复的最多顾客数量 `maximum`。
    - **从 `left=0, right=x-1` 开始，向右滑动，找到最大 `maximum`**。
4. **最终结果**
    
    - `ans`（本来满意的顾客）+ `maximum`（通过 `X` 天冷静期挽回的顾客）。

---

## **执行过程**

### **变量表**

|变量|说明|
|---|---|
|`customers`|顾客数量数组|
|`grumpy`|老板是否生气|
|`not_satisfied`|记录 `grumpy == 1` 时流失的顾客|
|`ans`|本来就满意的顾客总数|
|`now_sum`|当前窗口 `X` 天内能挽回的顾客数|
|`maximum`|`X` 天内最多可挽回的顾客数|

---

### **Step 1: 计算 `not_satisfied` 和 `ans`**

**输入**

python

複製編輯

`customers = [1, 0, 1, 2, 1, 1, 7, 5] grumpy =    [0, 1, 0, 1, 0, 1, 0, 1] x = 3`

计算 `not_satisfied` 和 `ans`：

ini

複製編輯

`not_satisfied = [0, 0, 0, 2, 0, 1, 0, 5] ans = 1 + 1 + 1 + 7 = 10  # (天 0, 2, 4, 6 是不生气的)`

---

### **Step 2: 计算前 `X=3` 天可挽回的顾客**

窗口 `X=3` 初始值：

ini

複製編輯

`now_sum = not_satisfied[0] + not_satisfied[1] + not_satisfied[2] = 0 + 0 + 0 = 0 maximum = 0`

---

### **Step 3: 滑动窗口寻找最大 `X` 天可挽回的顾客**

#### **第 1 次滑动**

|`left`|`right`|`now_sum`|`maximum`|
|---|---|---|---|
|`0`|`2`|`0`|`0`|
|`1`|`3`|`2`|`2`|

#### **第 2 次滑动**

|`left`|`right`|`now_sum`|`maximum`|
|---|---|---|---|
|`2`|`4`|`0`|`2`|

#### **第 3 次滑动**

|`left`|`right`|`now_sum`|`maximum`|
|---|---|---|---|
|`3`|`5`|`3`|`3`|

#### **第 4 次滑动**

|`left`|`right`|`now_sum`|`maximum`|
|---|---|---|---|
|`4`|`6`|`1`|`3`|

#### **第 5 次滑动**

|`left`|`right`|`now_sum`|`maximum`|
|---|---|---|---|
|`5`|`7`|`6`|`6`|

---

### **Step 4: 计算最终答案**

matlab

複製編輯

`ans + maximum = 10 + 6 = 16`

---

## **时间与空间复杂度分析**

### **时间复杂度**

|操作|复杂度|说明|
|---|---|---|
|**计算 `not_satisfied` 和 `ans`**|`O(n)`|遍历 `customers` 计算满意顾客|
|**计算 `X` 天窗口内最大 `maximum`**|`O(n)`|滑动窗口遍历 `customers`|
|**总复杂度**|`O(n)`|线性时间复杂度|

### **空间复杂度**

- 需要 `O(n)` 存储 `not_satisfied`，最终 **`O(n)`**。

---

## **其他解法**

### **1. 暴力法（O(n²)）**

- **思路**
    - **遍历所有可能的 `X` 天窗口**，计算每个窗口可挽回的顾客数。
- **时间复杂度**
    - **`O(n²)`**，适用于小数据。

---

### **2. 前缀和（O(n)）**

- **思路**
    - 计算 `not_satisfied` 的 **前缀和**，快速查询 `X` 天窗口内的和。
- **时间复杂度**
    - **`O(n)`**，适用于需要多次查询的情况。

---

## **方法比较**

|方法|思路|时间复杂度|空间复杂度|适用情况|
|---|---|---|---|---|
|**滑动窗口（当前解法）**|**计算 `X` 天窗口最大恢复顾客数**|`O(n)`|`O(n)`|**最优解，适用于大数据**|
|**暴力法**|**遍历所有窗口**|`O(n²)`|`O(1)`|**适用于小数据**|
|**前缀和**|**计算 `not_satisfied` 的前缀和**|`O(n)`|`O(n)`|**适用于多次查询**|

---

## **总结**

- **最优解** ✅ **滑动窗口 `O(n)`**
- **如果 `n` 较小，可用 `O(n²)` 暴力解法**
- **如果需要多次查询，可用 `O(n)` 前缀和**

🚀 **"滑动窗口" 是最优解，适用于所有大规模数据！**


