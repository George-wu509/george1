Lintcode 689
给一棵二叉搜索树以及一个整数 `n`, 在树中找到和为 `n` 的两个数字。无法找到解时返回 null。

Example:
```python
输入：
{4,2,5,1,3}
3
输出： [1,2] (or [2,1])
解释：
二叉搜索树如下：
    4
   / \
  2   5
 / \
1   3
```

```python
输入：
{4,2,5,1,3}
5
输出： [2,3] (or [3,2] or [1,4] or [4,1])
```

```python
import collections
class Solution:
    """
    @param: : the root of tree
    @param: : the target sum
    @return: two numbers from tree which sum is n
    """
    def __init__(self):
        self.s = set()

    def twoSum(self, root, n):
        # write your code here
        if not root:
            return None
        s = set()
        q = collections.deque([root])
        while q:
            node = q.popleft()
            if n - node.val in s:
                return [node.val, n - node.val]
            s.add(node.val)
            if node.left:
                q.append(node.left)
            if node.right:
                q.append(node.right)
        return None
```
pass

# **LintCode 689: Two Sum IV（BST 中的两数之和）**

---

## **问题描述**

给定一个二叉搜索树（BST）和一个目标值 `n`，在树中找到 **两个不同的节点**，使它们的和等于 `n`，并返回这两个节点的值。如果找不到，返回 `None`。

---

## **解法：哈希集合 + 层序遍历（BFS）**

### **核心思路**

1. **使用 `set` 存储已经访问的节点值**
    
    - 遍历 BST 时，记录所有访问过的节点值 `val`。
    - 对于当前节点 `val`，检查 `n - val` 是否已经在 `set` 中。
    - **如果存在 `n - val`，则找到了两个数 `val, n - val`，返回 `[val, n - val]`**。
2. **使用 BFS（层序遍历）**
    
    - BFS 适用于 **非平衡 BST**，可以更快找到解。
    - **队列 `queue`** 存储当前待遍历的节点。
    - 逐层遍历 BST，并将左右子节点加入队列。

---

## **执行过程**

### **变量表**

|变量|说明|
|---|---|
|`s`|存储已访问节点值的哈希集合|
|`q`|BFS 队列（存储待访问的节点）|

---

### **Step 1: 初始化**

假设输入：

python

複製編輯

      `5      / \     3   6    / \   \   2   4   7 target = 9`

初始化：

|变量|值|
|---|---|
|`s`|`{}`（空集合）|
|`q`|`[5]`（队列初始化）|

---

### **Step 2: 层序遍历**

#### **第一轮（处理 `5`）**

- `n - 5 = 4` **不在 `s`**，将 `5` 加入 `s`。
- 加入左右子节点 `3, 6`。

|变量|值|
|---|---|
|`s`|`{5}`|
|`q`|`[3, 6]`|

---

#### **第二轮（处理 `3`）**

- `n - 3 = 6` **不在 `s`**，将 `3` 加入 `s`。
- 加入左右子节点 `2, 4`。

|变量|值|
|---|---|
|`s`|`{3, 5}`|
|`q`|`[6, 2, 4]`|

---

#### **第三轮（处理 `6`）**

- `n - 6 = 3` **在 `s`**，**返回 `[6, 3]`**。

---

### **最终结果**

`[6, 3]`

---

## **时间与空间复杂度分析**

### **时间复杂度**

|操作|复杂度|说明|
|---|---|---|
|**遍历 BST**|`O(n)`|最坏情况下需遍历所有节点|
|**查找 `set`**|`O(1)`|哈希查找|
|**总复杂度**|`O(n)`|线性时间复杂度|

### **空间复杂度**

- 需要 `O(n)` 额外空间存储 `set` 和 `queue`。

---

## **其他解法**

### **1. DFS + 哈希集合（O(n)）**

- **思路**
    - 使用 **递归** 遍历 BST，存入 `set`，检查 `n - val` 是否存在。
- **时间复杂度**
    - **`O(n)`**（最坏情况需遍历所有节点）。

---

### **2. 双指针（O(n)）**

- **思路**
    - **中序遍历** BST，将所有值存入数组 `arr`（升序排列）。
    - **使用双指针 `l, r`** 在 `arr` 中查找 `arr[l] + arr[r] = target`。
- **时间复杂度**
    - **`O(n)`**（中序遍历 + `O(n)` 双指针）。

---

## **方法比较**

|方法|思路|时间复杂度|空间复杂度|适用情况|
|---|---|---|---|---|
|**BFS + `set`（当前解法）**|**层序遍历 + 哈希集合**|`O(n)`|`O(n)`|**适用于非平衡 BST**|
|**DFS + `set`**|**递归遍历 + 哈希集合**|`O(n)`|`O(n)`|**适用于小规模 BST**|
|**双指针**|**中序遍历 + 双指针查找**|`O(n)`|`O(n)`|**适用于平衡 BST**|

---

## **总结**

- **最优解** ✅ **BFS + `set` `O(n)`**
- **如果 BST 是** **平衡树**，可用 **`O(n)` 双指针**
- **如果 `n` 较小，可用 `O(n)` 递归 DFS**