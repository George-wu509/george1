
LintCode第66题“二叉树的前序遍历”要求我们按照**前序遍历**的顺序输出二叉树的所有节点值。

---

### 问题描述

#### 什么是前序遍历？

前序遍历是一种遍历二叉树的方法，按以下顺序访问节点：

1. 访问根节点；
2. 前序遍历左子树；
3. 前序遍历右子树。

#### 输入示例：

输入的二叉树为：

`tree = {1,2,3,4,5,#,7,8}`

对应的树结构：

```markdown
         1
       /   \
      2     3
     / \      \
    4   5      7
   /
  8

```
前序遍历的输出为：

`[1, 2, 4, 8, 5, 3, 7]`

---

### 解法1：递归法

#### 思路

递归法直接利用函数调用栈实现前序遍历。我们按照前序遍历的顺序递归访问每个节点。

#### 详细步骤

1. 如果当前节点为空，则直接返回（递归的结束条件）。
2. 访问当前节点并将其值加入结果数组。
3. 递归前序遍历左子树。
4. 递归前序遍历右子树。

---

#### Python代码实现

```python
class TreeNode:
    def __init__(self, val=0):
        self.val = val
        self.left = None
        self.right = None

def preorderTraversal(root):
    result = []

    def dfs(node):
        if not node:
            return
        result.append(node.val)  # 访问根节点
        dfs(node.left)           # 遍历左子树
        dfs(node.right)          # 遍历右子树

    dfs(root)
    return result

```

---

### 解法2：迭代法（栈）

#### 思路

迭代法通过显式使用栈来模拟递归调用。利用栈的**后进先出**特性，按前序遍历的顺序依次处理节点。

#### 详细步骤

1. 初始化一个栈，先将根节点入栈。
2. 循环处理栈内节点：
    - 弹出栈顶节点，记录其值。
    - 如果右子节点存在，先将右子节点入栈（因为右子树后遍历）。
    - 如果左子节点存在，再将左子节点入栈。
3. 栈为空时，结束遍历。

---

#### Python代码实现
```python
def preorderTraversal(root):
    if not root:
        return []

    result = []
    stack = [root]

    while stack:
        node = stack.pop()      # 弹出栈顶节点
        result.append(node.val) # 访问当前节点

        if node.right:
            stack.append(node.right) # 右子节点先入栈
        if node.left:
            stack.append(node.left)  # 左子节点后入栈

    return result

```

---

### 具体例子：`tree = {1,2,3,4,5,#,7,8}`

#### 输入树结构：
```markdown
         1
       /   \
      2     3
     / \      \
    4   5      7
   /
  8

```

```python
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)
root.right.right = TreeNode(7)
root.left.left.left = TreeNode(8)

```

---

#### 解法1：递归法详细过程

1. 开始遍历：
    - 从根节点`1`开始，加入结果：`result = [1]`。
2. 遍历左子树：
    - 访问节点`2`，加入结果：`result = [1, 2]`。
    - 访问节点`4`，加入结果：`result = [1, 2, 4]`。
    - 访问节点`8`，加入结果：`result = [1, 2, 4, 8]`。
3. 回溯到节点`2`，访问右子树：
    - 访问节点`5`，加入结果：`result = [1, 2, 4, 8, 5]`。
4. 回溯到根节点`1`，遍历右子树：
    - 访问节点`3`，加入结果：`result = [1, 2, 4, 8, 5, 3]`。
    - 访问节点`7`，加入结果：`result = [1, 2, 4, 8, 5, 3, 7]`。
5. 遍历结束。

#### 输出：

csharp

複製程式碼

`[1, 2, 4, 8, 5, 3, 7]`

---

#### 解法2：迭代法详细过程

1. 初始化：
    - `stack = [1]`，`result = []`。
2. 第一次循环：
    - 弹出`1`，加入结果：`result = [1]`。
    - 将`3`和`2`入栈：`stack = [3, 2]`。
3. 第二次循环：
    - 弹出`2`，加入结果：`result = [1, 2]`。
    - 将`5`和`4`入栈：`stack = [3, 5, 4]`。
4. 第三次循环：
    - 弹出`4`，加入结果：`result = [1, 2, 4]`。
    - 将`8`入栈：`stack = [3, 5, 8]`。
5. 第四次循环：
    - 弹出`8`，加入结果：`result = [1, 2, 4, 8]`。
6. 第五次循环：
    - 弹出`5`，加入结果：`result = [1, 2, 4, 8, 5]`。
7. 第六次循环：
    - 弹出`3`，加入结果：`result = [1, 2, 4, 8, 5, 3]`。
    - 将`7`入栈：`stack = [7]`。
8. 第七次循环：
    - 弹出`7`，加入结果：`result = [1, 2, 4, 8, 5, 3, 7]`。
9. 栈为空，结束遍历。

#### 输出：

csharp

複製程式碼

`[1, 2, 4, 8, 5, 3, 7]`

---

### 总结

- **递归法**：
    
    - 简单直观，代码简洁，但对于深度过大的树可能会导致栈溢出。
    - 时间复杂度：O(n)，空间复杂度：O(h)（递归栈深度为树的高度）。
- **迭代法**：
    
    - 显式使用栈，避免递归栈溢出，适合更大的树。
    - 时间复杂度：O(n)，空间复杂度：O(h)（显式栈占用空间为树的高度）。

希望这些讲解清楚地帮助你理解二叉树的前序遍历！如果有问题，请随时提问！