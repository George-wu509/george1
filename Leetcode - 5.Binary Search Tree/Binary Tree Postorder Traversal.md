LintCode第68题“Binary Tree Postorder Traversal（二叉树的后序遍历）”要求按**后序遍历**的顺序返回二叉树的所有节点值。

---

### 什么是后序遍历？

后序遍历是一种遍历二叉树的方法，按以下顺序访问节点：

1. 遍历左子树；
2. 遍历右子树；
3. 访问根节点。

---

### 输入示例

**输入：**

`tree = {1,2,3,4,5,#,7,8}`

对应的二叉树结构如下：

```markdown
         1
       /   \
      2     3
     / \      \
    4   5      7
   /
  8

```

**输出：**

`[8, 4, 5, 2, 7, 3, 1]`

---

### 解法1：递归法

#### 思路

递归是解决树遍历问题的经典方法。我们按照后序遍历的规则递归访问每个节点。

#### 步骤

1. 如果当前节点为空，则直接返回（递归的结束条件）。
2. 递归遍历左子树；
3. 递归遍历右子树；
4. 访问当前节点并将其值加入结果数组。

---

#### Python实现代码
```python
class TreeNode:
    def __init__(self, val=0):
        self.val = val
        self.left = None
        self.right = None

def postorderTraversal(root):
    result = []

    def dfs(node):
        if not node:
            return
        dfs(node.left)           # 遍历左子树
        dfs(node.right)          # 遍历右子树
        result.append(node.val)  # 访问当前节点

    dfs(root)
    return result

```

---

### 解法2：迭代法（栈）

#### 思路

迭代法显式使用栈来模拟递归过程。由于后序遍历的顺序是"左子树 -> 右子树 -> 根节点"，我们可以反转为“根节点 -> 右子树 -> 左子树”的顺序处理节点（类似于前序遍历）。然后再将结果数组倒置。

#### 步骤

1. 初始化一个栈`stack`和结果数组`result`。
2. 将根节点压入栈。
3. 循环处理栈内节点：
    - 弹出栈顶节点，将其值插入结果数组的开头；
    - 如果左子节点存在，将其压入栈；
    - 如果右子节点存在，将其压入栈。
4. 栈为空时，遍历结束。
5. 返回结果。

---

#### Python实现代码
```python
def postorderTraversal(root):
    if not root:
        return []

    stack = [root]
    result = []

    while stack:
        node = stack.pop()
        result.insert(0, node.val)  # 逆序插入当前节点值

        if node.left:
            stack.append(node.left)
        if node.right:
            stack.append(node.right)

    return result

```

---

### 示例：`tree = {1,2,3,4,5,#,7,8}`

#### 输入二叉树结构：

```markdown
         1
       /   \
      2     3
     / \      \
    4   5      7
   /
  8

```
#### 构造树代码：
```python
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)
root.right.right = TreeNode(7)
root.left.left.left = TreeNode(8)

```

---

### 解法1：递归法详细过程

1. 从根节点`1`开始：
    - 遍历左子树：
        - 节点`2`的左子树：
            - 节点`4`的左子树：
                - 访问节点`8`，结果：`[8]`。
            - 返回节点`4`，结果：`[8, 4]`。
        - 节点`2`的右子树：
            - 访问节点`5`，结果：`[8, 4, 5]`。
        - 返回节点`2`，结果：`[8, 4, 5, 2]`。
    - 遍历右子树：
        - 节点`3`的右子树：
            - 访问节点`7`，结果：`[8, 4, 5, 2, 7]`。
        - 返回节点`3`，结果：`[8, 4, 5, 2, 7, 3]`。
    - 返回根节点`1`，结果：`[8, 4, 5, 2, 7, 3, 1]`。

#### 输出：

csharp

複製程式碼

`[8, 4, 5, 2, 7, 3, 1]`

---

### 解法2：迭代法详细过程

1. 初始化：
    
    - `stack = [1]`，`result = []`。
2. 第一步：处理根节点`1`：
    
    - 弹出节点`1`，插入到结果开头：`result = [1]`。
    - 将节点`2`（左子树）和节点`3`（右子树）压入栈：`stack = [2, 3]`。
3. 第二步：处理节点`3`：
    
    - 弹出节点`3`，插入到结果开头：`result = [3, 1]`。
    - 将节点`7`压入栈：`stack = [2, 7]`。
4. 第三步：处理节点`7`：
    
    - 弹出节点`7`，插入到结果开头：`result = [7, 3, 1]`。
    - `stack = [2]`。
5. 第四步：处理节点`2`：
    
    - 弹出节点`2`，插入到结果开头：`result = [2, 7, 3, 1]`。
    - 将节点`4`（左子树）和节点`5`（右子树）压入栈：`stack = [4, 5]`。
6. 第五步：处理节点`5`：
    
    - 弹出节点`5`，插入到结果开头：`result = [5, 2, 7, 3, 1]`。
    - `stack = [4]`。
7. 第六步：处理节点`4`：
    
    - 弹出节点`4`，插入到结果开头：`result = [4, 5, 2, 7, 3, 1]`。
    - 将节点`8`压入栈：`stack = [8]`。
8. 第七步：处理节点`8`：
    
    - 弹出节点`8`，插入到结果开头：`result = [8, 4, 5, 2, 7, 3, 1]`。
    - `stack = []`。
9. 栈为空，结束遍历。
    

#### 输出：

csharp

複製程式碼

`[8, 4, 5, 2, 7, 3, 1]`

---

### 总结

- **递归法**：
    
    - 简单直观，但对于深度过大的树可能导致栈溢出。
    - 时间复杂度：O(n)，空间复杂度：O(h)（递归栈的深度为树的高度）。
- **迭代法**：
    
    - 显式使用栈，适合深度大的树，避免递归栈溢出问题。
    - 时间复杂度：O(n)，空间复杂度：O(h)。

希望这些详细解释对你理解后序遍历有所帮助！如果还有疑问，请随时提问！
