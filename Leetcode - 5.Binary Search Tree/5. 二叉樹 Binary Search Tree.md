二分树

二分樹深度: 有三層→ 深度=3

---

1. **二叉樹**有三種遍歷:  先序遍历Pre-order,  中序遍历In-order,

后序遍历Post-order（分治法）

2. **二叉樹定義:** 每個節點最多有兩個子樹的樹結構, 树是没有环的图

3. class TreeNode:

Def **init**(self, val):

Self.val = val

Self.left, self.right = None, None

4. **二叉樹種類:**

a. 空二叉樹 empty

b. 退化二叉樹 degenerate

c. 完全二叉樹 complete 如果除了最後一層節點其它為滿二叉樹, 且最後一層節點依次從左到右

d. 滿二叉樹 full 如果除了葉子節點, 其他節點數都是2

e. 完美二叉樹 perfect 每個節點數都是2

f. 平衡二叉樹 balanced   左右子树的高度之差<= 1 (AVL tree = 平衡+二叉搜索樹)

g. 二叉搜索樹 Binary Search Tree   左子樹所有節點小於根結點, 右子樹所有節點大於根結點

**5. 分治法Divide & Conquer :        二叉树的大部分题都可以使用分治法解决**

归并排序，快速排序，都是基于数组的分治法

6. 二叉树考点剖析:    (考點本質:   深度优先搜索)

二叉树上求值，求路径                    - Q597具有最大平均数的子树

二叉树结构变化                                 - Q175  翻转二叉树

二叉查找树（Binary Search Tree）- Q95  验证二叉查找树

二分搜索树

---

7  **二分搜索树（Binary Search Tree）定義:**

节点的左子树中的值要严格小于该节点的值。

- 节点的右子树中的值要严格大于该节点的值。
- 左右子树也必须是二叉查找树。
- 一个节点的树也是二叉查找树。

8  二分搜索树（Binary Search Tree）    先序遍历的顺序是：根->左->右。 Binary Tree Preorder

![[Pasted image 20240914165952.png]]

## **Lintcode模板 - 二叉树分治 Binary Tree Divide & Conquer**

## **使用条件**

- 二叉树相关的问题（99%）
- 可以一分为二去分别处理之后再合并结果（100%）
- 数组相关的问题（10%）

## **复杂度**

- 时间复杂度：_O_(_n_)
- 空间复杂度：_O_(_n_) （含递归调用的栈空间最大耗费）
- ![[Pasted image 20240914170030.png]]

## **Lintcode模板 - 二叉搜索树非递归 BST Iterator**

## **使用条件**

- 用非递归的方式（`Non-recursion` / `Iteration`）实现二叉树的中序遍历
- 常用于 `BST` 但不仅仅可以用于 `BST`

## **复杂度**

- 时间复杂度：_O_(_n_)
- 空间复杂度：_O_(_n_)

**代码模板**
![[Pasted image 20240914170140.png]]
## 我的模板

Divider conquer版本的DFS
![[Pasted image 20240914170226.png]]


