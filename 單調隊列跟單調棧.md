

單調佇列（Monotonic Queue）和單調棧（Monotonic Stack）都是常用的資料結構優化技巧，它們的核心思想都是維護一個內部元素**單調有序**的集合。然而，由於它們底層資料結構（佇列 vs 棧）的特性，它們在功能和應用場景上存在顯著差異。

![[Pasted image 20250624123616.png]]

---

## 單調佇列 (Monotonic Queue)

### 意義與特性

- **底層結構：** 通常使用 **雙端佇列 (deque)** 來實現。這使得它能夠在**兩端高效地進行插入和刪除**操作（O(1) 時間複雜度）。
- **單調性維護：** 佇列中的元素始終保持單調性（遞增或遞減）。
    - 當**新元素入隊**時，它會從**隊尾**移除所有破壞單調性的元素，直到新元素能保持單調性，然後將新元素添加到隊尾。
- **關鍵操作：**
    1. **從隊尾添加新元素，並維護單調性。**
    2. **從隊頭移除元素** (這通常用於滑動視窗問題中，移除超出視窗範圍的舊元素)。
    3. **直接訪問隊頭元素** (通常是當前視窗或區間的最值)。

### 典型應用場景

單調佇列主要用於處理**區間最值問題**，特別是**滑動視窗 (Sliding Window)** 相關的問題，以及一些可以轉化為區間最值問題的動態規劃優化。

- **滑動視窗最大/最小值 (Sliding Window Maximum/Minimum)：** 這是最經典的應用。給定一個陣列和一個固定大小的滑動視窗，要求找出每個視窗中的最大值或最小值。
    - 例如：LeetCode 239. Sliding Window Maximum (滑動窗口最大值)。
- **最短子陣列和 (Shortest Subarray with Sum at Least K)：** 如您之前提供的例子，它需要尋找滿足特定和條件的最短子陣列。透過維護前綴和的單調佇列來實現。
- **優化動態規劃 (Dynamic Programming Optimization)：** 當DP轉移方程呈現 `dp[i] = max/min(dp[j] + cost[j])` 且 `j` 的取值範圍是一個滑動區間時，可以使用單調佇列將 O(N×K) 或 O(N2) 的時間複雜度優化到 O(N)。

---

## 單調棧 (Monotonic Stack)

### 意義與特性

- **底層結構：** 通常使用 **棧 (list/vector)** 來實現。它只支援在**一端 (棧頂)** 進行插入和刪除操作（O(1) 時間複雜度）。
- **單調性維護：** 棧中的元素始終保持單調性（遞增或遞減）。
    - 當**新元素入棧**時，它會從**棧頂**移除所有破壞單調性的元素，直到新元素能保持單調性，然後將新元素推入棧頂。
- **關鍵操作：**
    1. **從棧頂添加新元素，並維護單調性。**
    2. **從棧頂移除元素** (這是因為不符合單調性或這些元素已經找到了它們「右側」的第一個更大/更小元素)。
    3. **訪問棧頂元素** (通常是當前元素「左側」的第一個更大/更小元素)。

### 典型應用場景

單調棧主要用於查找每個元素**左側或右側第一個比它大/小的元素**，以及基於這些關係衍生出的問題。它處理的是**鄰近元素關係**。

- **下一個更大/更小元素 (Next Greater/Smaller Element)：** 找出陣列中每個元素右側（或左側）第一個比它大（或小）的元素。
    - 例如：LeetCode 496. Next Greater Element I (下一個更大元素 I)。
- **直方圖中的最大矩形 (Largest Rectangle in Histogram)：** 找出直方圖中能形成的最大矩形面積。這需要找到每個柱子左右兩側第一個比它小的柱子，以確定其能延伸的寬度。
    - 例如：LeetCode 84. Largest Rectangle in Histogram。
- **接雨水 (Trapping Rain Water)：** 計算兩個柱子之間能接多少雨水。這需要找到每個位置左右兩側最高的柱子。
    - 例如：LeetCode 42. Trapping Rain Water。
- **移除重複字母 (Remove Duplicate Letters)：** 在保證相對順序的情況下去除字符串中的重複字母，並使結果字符串在字典序上最小。
- **最大子矩陣 (Maximal Rectangle)：** 在二維二進制矩陣中找出最大的全 1 矩形。這通常可以轉化為多次應用「直方圖中的最大矩形」問題。

---

## 主要區別總結

|特徵|單調佇列 (Monotonic Queue)|單調棧 (Monotonic Stack)|
|:--|:--|:--|
|**底層**|`collections.deque` (雙端隊列)|`list` (模擬棧)|
|**出隊/棧**|隊頭和隊尾都可以出隊 (popleft, pop)，通常隊頭用於移除過期元素|只能從棧頂出棧 (pop)，通常用於處理不符合單調性的元素|
|**應用**|**區間最值** (尤其是滑動視窗問題)，DP優化|查找**鄰近元素關係** (如左右第一個更大/更小)，矩陣問題|
|**維護**|隊頭通常是當前考慮區間的最值。|棧頂通常是當前元素**左側**或**右側**的第一個相關元素。|
|**時間複雜度**|O(N)，每個元素最多入隊一次、出隊一次|O(N)，每個元素最多入棧一次、出棧一次|

匯出到試算表

---

## 總結

簡而言之，**單調佇列**更側重於在**變動的區間**（如滑動視窗）中快速查詢最值。而**單調棧**則更側重於查找每個元素左右兩側的**第一個符合特定條件的元素**，並基於此解決問題。雖然兩者都利用了單調性來優化時間複雜度，但它們處理的問題類型和內部的操作模式有所不同。







![[Pasted image 20250217145851.png]]
heights = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]

[h=0]id=0, stack = [0] 
[h=1]id=1, stack = [1]
[h=0]id=2, stack = [1,2], 
[h=2]id=3, stack = [3], width=1, height=1  --> pop() 1跟2
[h=1]id=4, stack = [3,4]
[h=0]id=5, stack = [3,4,5]
[h=1]id=6, stack = [3,4,6], width=1, height=1  --> pop() 5
[h=3]id=7, stack = [7], width=3, height=1  --> pop() 3跟4,跟6
[h=2]id=8, stack = [7,8]
[h=1]id=9, stack = [7,8,9]
[h=2]id=10, stack = [7,8,10], width=1, height=1  --> pop() 9
[h=1]id=11, stack = [7,8,10,11]

單調佇列的意義並不是簡單地儲存比當前數值更大或更小的數值。更精確地說，單調佇列是用來**維護一個有序的候選元素集合**，這個集合中的元素在某個屬性上（例如數值大小或索引）是**嚴格單調遞增或遞減**的。

它的核心思想是：當我們遍歷一個序列時，對於當前處理的元素，我們移除佇列中那些**不可能再成為最佳解**的舊元素。這些「不可能成為最佳解」的元素通常是因為它們：

1. **已經過期** (例如，在滑動視窗問題中，它們已經超出了視窗範圍)。
2. **不再具有競爭力** (例如，存在一個比它們更優且位置更合適的新元素)。

## 單調佇列 (Monotonic Queue) 的資料結構選擇

在使用單調佇列 (Monotonic Queue) 時，最適合的資料結構是 **`collections.deque`** (雙端佇列)。

### 為何 `deque` 是最佳選擇？

單調佇列的核心操作包括：

1. **從頭部 (left) 移除元素 (popleft)**：為了移除不再相關的舊元素。
2. **從尾部 (right) 移除元素 (pop)**：為了維護單調性，移除不符合條件的元素。
3. **從尾部 (right) 添加元素 (append)**：添加新的元素。

- **`list` (列表)**：雖然 `list` 可以實現這些操作，但 `pop(0)` (從列表開頭移除元素) 的時間複雜度是 O(N)，因為它需要移動所有後續元素。這會導致整體演算法的時間複雜度從 O(N) 惡化到 O(N2)。因此，`list` 不適合用於需要頻繁從開頭移除元素的單調佇列。
    
- **`queue.Queue` (佇列)**：`queue.Queue` 主要設計用於多執行緒環境下的執行緒安全佇列，它只支援 `put()` (入佇列，通常是從尾部) 和 `get()` (出佇列，從頭部)。它不支援從尾部移除元素的操作，因此無法用來維護單調性。
    
- **`collections.deque` (雙端佇列)**：`deque` 是一個雙端佇列，它支援在兩端高效地（O(1) 時間複雜度）添加和移除元素 (`append()`, `appendleft()`, `pop()`, `popleft()`)。這正是單調佇列所需的所有操作，因此 `deque` 是實現單調佇列的理想選擇。
    
- **`stack` (堆疊)**：`stack` 通常指只支援 LIFO (後進先出) 的資料結構，即只能從一端添加和移除元素。雖然你可以用 `list` 來模擬堆疊，但它通常也不提供從兩端高效操作的能力，因此不適合用於單調佇列。
    

**結論：** 為了確保單調佇列演算法的效率為 O(N)，**`collections.deque`** 是唯一且最佳的選擇。

---

## 單調佇列的意義

單調佇列的意義並不是簡單地儲存比當前數值更大或更小的數值。更精確地說，單調佇列是用來**維護一個有序的候選元素集合**，這個集合中的元素在某個屬性上（例如數值大小或索引）是**嚴格單調遞增或遞減**的。

它的核心思想是：當我們遍歷一個序列時，對於當前處理的元素，我們移除佇列中那些**不可能再成為最佳解**的舊元素。這些「不可能成為最佳解」的元素通常是因為它們：

1. **已經過期** (例如，在滑動視窗問題中，它們已經超出了視窗範圍)。
2. **不再具有競爭力** (例如，存在一個比它們更優且位置更合適的新元素)。

以您提供的 `shortest_subarray` 例子來說，單調佇列 `mono_queue` 儲存的是 `(prefix_sum, index)` 對，並且其 `prefix_sum` 部分是**單調遞增**的。

- `while mono_queue and mono_queue[-1][0] >= prefix_sum:` 這段程式碼的目的就是維持 `mono_queue` 的**前綴和部分是嚴格遞增的**。如果當前 `prefix_sum` 小於或等於佇列尾部的前綴和，那麼佇列尾部的元素就沒有「競爭力」了，因為：
    - 它的值更大或相等。
    - 它的索引更靠前。
    - 如果將來需要一個特定的前綴和 `X` 來計算子陣列和，那麼使用當前更小 `prefix_sum` 的這個元素會比佇列尾部更大的那個元素導致一個更短的子陣列。因此，我們移除「劣勢」的元素以保持佇列的單調性。

---

## 經典的單調佇列 (Monotonic Queue) 問題 (LintCode 類比)

單調佇列在處理以下兩種類型的問題時特別有用：

1. **滑動視窗 (Sliding Window) 問題**：在一個固定大小或可變大小的視窗中尋找最大/最小值。
2. **查找前後第一個更大/更小的元素問題** (通常使用單調棧解決，但原理相通)。

以下是一些經典的單調佇列問題，在 LintCode 或 LeetCode 上都能找到類似題目：

1. **滑動視窗最大值 (Sliding Window Maximum)**
    
    - **問題描述**：給定一個陣列 `nums` 和一個滑動視窗大小 `k`，在每次視窗滑動時，找出視窗中的最大值。
    - **單調佇列應用**：維護一個**單調遞減**的佇列，儲存視窗中元素的索引。佇列頭部始終是當前視窗中的最大值的索引。當新元素進入視窗時，移除佇列尾部所有小於新元素的元素。當視窗滑動時，移除佇列頭部過期的索引。
2. **最短子陣列和 (Shortest Subarray with Sum at Least K)**
    
    - **問題描述**：這正是您提供的程式碼所解決的問題。在陣列中找到一個最短的連續子陣列，其元素和至少為 `k`。
    - **單調佇列應用**：維護一個**單調遞增**的佇列，儲存前綴和及其對應的索引。通過 `prefix_sum - mono_queue[0][0] >= k` 來找到滿足條件的子陣列，並透過 `popleft` 移除舊元素。
3. **子陣列最大/最小值 (Subarray Max/Min)**
    
    - 這是一類更廣泛的問題，通常涉及在所有子陣列中尋找某個屬性（例如，最大值與最小值之差）的總和。單調佇列 (或單調棧) 可以幫助高效地計算每個元素作為最大值或最小值的區間。


